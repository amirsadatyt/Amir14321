import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { ethers } from 'https://esm.sh/ethers@6';

// CORS headers to allow requests from any origin
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};

// Verifies that the sender's address matches the address recovered from the signature
const verifySignature = (signedMessage, signature, expectedAddress) => {
  try {
    const signerAddress = ethers.verifyMessage(signedMessage, signature);
    if (signerAddress !== expectedAddress) {
      throw new Error(`Signature verification failed: Expected sender ${expectedAddress} but got signer ${signerAddress}.`);
    }
    return true;
  } catch (e) {
    throw new Error(`Invalid signature format or data. ${e.message}`);
  }
};

Deno.serve(async (req) => {
  // Handle preflight CORS requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client with the user's authorization header
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! }
        }
      }
    );

    const { action, payload } = await req.json();
    let data = null;

    switch (action) {
      case 'getAppConfig': {
        // FIX: Configuration is now embedded in the code.
        // The database is no longer queried for these values.
        const embeddedConfig = {
          TREASURY_ADDRESS: "0xF848aC6b7E16CF32A972ECE1529c73313375c6d5", // <-- REPLACE THIS
          FEE_PERCENTAGE: 0.009,                         // <-- REPLACE THIS if needed
          PRECISION: 8
        };
        
        data = embeddedConfig;
        break;
      }

      case 'getMasterKey': {
        const { data: keyData, error } = await supabaseClient
          .from('master_keys')
          .select('public_key')
          .eq('key_id', 'master_public_key')
          .single();
        
        if (error) throw error;
        data = keyData;
        break;
      }

      case 'recordSpentIdentifier': {
        const { identifier, type } = payload;
        
        const { data: existingData } = await supabaseClient
          .from('spent_identifiers')
          .select('identifier')
          .eq('identifier', identifier)
          .maybeSingle();
        
        if (existingData) {
          throw new Error(`${type} with identifier ${identifier} has already been spent.`);
        }

        const { error } = await supabaseClient
          .from('spent_identifiers')
          .insert({ identifier, type });
        
        if (error) throw error;
        data = { success: true };
        break;
      }

      case 'hasBeenSpent': {
        const { identifier } = payload;
        
        const { data: spentData, error } = await supabaseClient
          .from('spent_identifiers')
          .select('identifier')
          .eq('identifier', identifier)
          .maybeSingle();
        
        if (error) throw error;
        data = { spent: !!spentData };
        break;
      }

      case 'pinConfirmation': {
        const { confirmation } = payload;

        if (!confirmation.linkedTxHash || !confirmation.senderAddress || !confirmation.receiverAddress || confirmation.amount === undefined) {
          throw new Error('Missing required confirmation fields');
        }

        if (confirmation.senderAddress !== 'BANKNOTE_ISSUER') {
          if (!confirmation.signedMessage || !confirmation.signature) {
            throw new Error('Missing signature data for user transaction');
          }
          
          verifySignature(confirmation.signedMessage, confirmation.signature, confirmation.senderAddress);
        }

        const { data: existingConfirmation } = await supabaseClient
          .from('confirmations')
          .select('id')
          .eq('linked_tx_hash', confirmation.linkedTxHash)
          .eq('sender_address', confirmation.senderAddress)
          .eq('receiver_address', confirmation.receiverAddress)
          .maybeSingle();

        if (existingConfirmation) {
          throw new Error('Confirmation already exists for this transaction');
        }

        const { error } = await supabaseClient
          .from('confirmations')
          .insert({
            linked_tx_hash: confirmation.linkedTxHash,
            sender_address: confirmation.senderAddress,
            receiver_address: confirmation.receiverAddress,
            amount: confirmation.amount,
            confirmation_data: confirmation
          });
        
        if (error) throw error;
        data = { success: true };
        break;
      }

      case 'findConfirmation': {
        const { txHash } = payload;
        
        if (!txHash) {
          throw new Error('Transaction hash is required');
        }

        const { data: findData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at')
          .eq('linked_tx_hash', txHash)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        if (error && error.code !== 'PGRST116') throw error;
        
        data = findData ? {
          ...findData.confirmation_data,
          timestamp: new Date(findData.created_at).getTime()
        } : null;
        break;
      }

      case 'findIncomingTxs': {
        const { receiverAddress } = payload;
        
        if (!receiverAddress || !ethers.isAddress(receiverAddress)) {
          throw new Error('Valid receiver address is required');
        }

        const { data: incomingData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at, amount')
          .eq('receiver_address', receiverAddress)
          .order('created_at', { ascending: false })
          .limit(1000);
        
        if (error) throw error;
        
        data = incomingData.map(tx => ({
          ...tx.confirmation_data,
          amount: parseFloat(tx.amount),
          timestamp: new Date(tx.created_at).getTime()
        }));
        break;
      }

      case 'findOutgoingTxs': {
        const { senderAddress } = payload;
        
        if (!senderAddress || !ethers.isAddress(senderAddress)) {
          throw new Error('Valid sender address is required');
        }

        const { data: outgoingData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at, amount')
          .eq('sender_address', senderAddress)
          .order('created_at', { ascending: false })
          .limit(1000);
        
        if (error) throw error;
        
        data = outgoingData.map(tx => ({
          ...tx.confirmation_data,
          amount: parseFloat(tx.amount),
          timestamp: new Date(tx.created_at).getTime()
        }));
        break;
      }

      case 'getTreasuryBalance': {
        // This endpoint will now fail unless you also hardcode the address here.
        // It's better to fetch it from the embedded config for consistency.
        const { data: configData } = await this.apiCall('getAppConfig');
        const treasuryAddress = configData.TREASURY_ADDRESS;

        if (!treasuryAddress) {
          throw new Error('Treasury address not configured');
        }

        const { data: incomingData, error: incomingError } = await supabaseClient
          .from('confirmations')
          .select('amount')
          .eq('receiver_address', treasuryAddress);

        if (incomingError) throw incomingError;

        const { data: outgoingData, error: outgoingError } = await supabaseClient
          .from('confirmations')
          .select('amount')
          .eq('sender_address', treasuryAddress);

        if (outgoingError) throw outgoingError;

        const totalIncoming = incomingData.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        const totalOutgoing = outgoingData.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        
        data = {
          treasuryAddress,
          totalIncoming,
          totalOutgoing,
          balance: totalIncoming - totalOutgoing,
          transactionCount: incomingData.length + outgoingData.length
        };
        break;
      }

      case 'getTransactionStats': {
        const { data: totalTxs, error: txError } = await supabaseClient
          .from('confirmations')
          .select('amount, sender_address', { count: 'exact' });

        if (txError) throw txError;

        const totalVolume = totalTxs.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        const feeTransactions = totalTxs.filter(tx => tx.sender_address !== 'BANKNOTE_ISSUER');
        
        const { data: configData } = await this.apiCall('getAppConfig');
        const treasuryAddress = configData.TREASURY_ADDRESS || 'Unknown';

        data = {
          totalTransactions: totalTxs.length,
          totalVolume,
          feeTransactions: feeTransactions.length,
          treasuryAddress,
          averageTransactionAmount: totalTxs.length > 0 ? totalVolume / totalTxs.length : 0
        };
        break;
      }

      default:
        throw new Error(`Invalid action specified: ${action}`);
    }

    // Return successful response
    return new Response(JSON.stringify({ data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    console.error('Edge function error:', error);
    
    const statusCode = error.message.includes('already been spent') || 
                      error.message.includes('already exists') ? 409 : 400;

    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: statusCode
    });
  }
});

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { ethers } from 'https://esm.sh/ethers@6';
// Import new dependencies for server-side validation
import pqcSignFalcon1024 from 'https://hdvqbcjtublfuykigsui.supabase.co/storage/v1/object/public/A1/sign.asm.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
import pako from 'https://cdn.skypack.dev/pako';

// CORS headers to allow requests from any origin
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};

// Verifies that the sender's address matches the address recovered from the signature
const verifySignature = (signedMessage, signature, expectedAddress) => {
  try {
    const signerAddress = ethers.verifyMessage(signedMessage, signature);
    if (signerAddress !== expectedAddress) {
      throw new Error(`Signature verification failed: Expected sender ${expectedAddress} but got signer ${signerAddress}.`);
    }
    return true;
  } catch (e) {
    throw new Error(`Invalid signature format or data. ${e.message}`);
  }
};

// --- START: Server-Side Validation Helpers (Ported from client's CoreLogic) ---

const validationUtils = {
    base64ToUint8Array: (s) => {
        const bs = atob(s);
        const b = new Uint8Array(bs.length);
        for (let i = 0; i < bs.length; i++) b[i] = bs.charCodeAt(i);
        return b;
    },
    hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))),
    arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))),
};

const validationCrypto = {
    hashMessageForSigning: (m) => validationUtils.hexToUint8Array(shake256(m, 1536)),
    verifySignature: async (sig, data, pk, api) => {
        const hash = validationCrypto.hashMessageForSigning(data);
        return api.verify(sig, hash, pk);
    }
};

const banknoteLogic = {
    parsePayload: (b64) => {
        const compressed = validationUtils.base64ToUint8Array(b64);
        const json = pako.inflate(compressed, { to: 'string' });
        const p = JSON.parse(json);
        return {
            amount: p.a,
            serial: p.s,
            timestamp: p.t,
            ephemeralPublicKey: validationUtils.base64ToUint8Array(p.epk),
            signatureOne: validationUtils.base64ToUint8Array(p.s1),
            signatureTwo: validationUtils.base64ToUint8Array(p.s2)
        };
    },
    getStandardizedDataForSigning: (d) => JSON.stringify({ timestamp: d.timestamp, serial: d.serial }, ['timestamp', 'serial']),
    getStandardizedDataForMasterSig: (d) => {
        const transformed = {
            ephemeralPublicKey: validationUtils.arrayBufferToBase64(d.ephemeralPublicKey),
            signatureOne: validationUtils.arrayBufferToBase64(d.signatureOne)
        };
        return JSON.stringify(transformed, Object.keys(transformed).sort());
    },
};

// --- END: Server-Side Validation Helpers ---


Deno.serve(async (req) => {
  // Handle preflight CORS requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client with the user's authorization header
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! }
        }
      }
    );

    const { action, payload } = await req.json();
    let data = null;

    switch (action) {
      case 'getAppConfig': {
        // FIX: Configuration is now embedded in the code.
        // The database is no longer queried for these values.
        const embeddedConfig = {
          TREASURY_ADDRESS: "0xF848aC6b7E16CF32A972ECE1529c73313375c6d5", // <-- REPLACE THIS
          FEE_PERCENTAGE: 0.009,                         // <-- REPLACE THIS if needed
          PRECISION: 8
        };
        
        data = embeddedConfig;
        break;
      }
      
      // --- START: New Server-Side Banknote Validation Action ---
      case 'validateBanknote': {
        const { payload: banknotePayload } = payload;
        if (!banknotePayload) {
          throw new Error('Banknote payload is required.');
        }

        // 1. Initialize Crypto Library
        const falconApi = await pqcSignFalcon1024();

        // 2. Parse the banknote data
        const banknoteData = banknoteLogic.parsePayload(banknotePayload);

        // 3. Check if the banknote's serial number has already been spent
        const { data: existingIdentifier } = await supabaseClient
            .from('spent_identifiers')
            .select('identifier')
            .eq('identifier', banknoteData.serial)
            .maybeSingle();
            
        if (existingIdentifier) {
            throw new Error('This banknote has already been spent.');
        }

        // 4. Fetch the master public key for verification
        const { data: keyData, error: keyError } = await supabaseClient
            .from('master_keys')
            .select('public_key')
            .eq('key_id', 'master_public_key')
            .single();

        if (keyError) throw new Error('Could not retrieve the master key for verification.');
        const masterPublicKey = validationUtils.base64ToUint8Array(keyData.public_key);
        
        // 5. Verify the internal signature (signed by the ephemeral key)
        const standardizedDataForSigOne = banknoteLogic.getStandardizedDataForSigning(banknoteData);
        const isSigOneValid = await validationCrypto.verifySignature(
            banknoteData.signatureOne,
            standardizedDataForSigOne,
            banknoteData.ephemeralPublicKey,
            falconApi
        );
        if (!isSigOneValid) throw new Error("Signature validation failed (internal).");

        // 6. Verify the master signature (signed by the master key)
        const standardizedDataForSigTwo = banknoteLogic.getStandardizedDataForMasterSig(banknoteData);
        const isSigTwoValid = await validationCrypto.verifySignature(
            banknoteData.signatureTwo,
            standardizedDataForSigTwo,
            masterPublicKey,
            falconApi
        );
        if (!isSigTwoValid) throw new Error("Signature validation failed (issuer).");

        // 7. If all checks pass, return the valid amount and serial
        data = {
            success: true,
            amount: banknoteData.amount,
            serial: banknoteData.serial
        };
        break;
      }
      // --- END: New Server-Side Banknote Validation Action ---

      case 'getMasterKey': {
        const { data: keyData, error } = await supabaseClient
          .from('master_keys')
          .select('public_key')
          .eq('key_id', 'master_public_key')
          .single();
        
        if (error) throw error;
        data = keyData;
        break;
      }

      case 'recordSpentIdentifier': {
        const { identifier, type } = payload;
        
        const { data: existingData } = await supabaseClient
          .from('spent_identifiers')
          .select('identifier')
          .eq('identifier', identifier)
          .maybeSingle();
        
        if (existingData) {
          throw new Error(`${type} with identifier ${identifier} has already been spent.`);
        }

        const { error } = await supabaseClient
          .from('spent_identifiers')
          .insert({ identifier, type });
        
        if (error) throw error;
        data = { success: true };
        break;
      }

      case 'hasBeenSpent': {
        const { identifier } = payload;
        
        const { data: spentData, error } = await supabaseClient
          .from('spent_identifiers')
          .select('identifier')
          .eq('identifier', identifier)
          .maybeSingle();
        
        if (error) throw error;
        data = { spent: !!spentData };
        break;
      }

      case 'pinConfirmation': {
        const { confirmation } = payload;

        if (!confirmation.linkedTxHash || !confirmation.senderAddress || !confirmation.receiverAddress || confirmation.amount === undefined) {
          throw new Error('Missing required confirmation fields');
        }

        if (confirmation.senderAddress !== 'BANKNOTE_ISSUER') {
          if (!confirmation.signedMessage || !confirmation.signature) {
            throw new Error('Missing signature data for user transaction');
          }
          
          verifySignature(confirmation.signedMessage, confirmation.signature, confirmation.senderAddress);
        }

        const { data: existingConfirmation } = await supabaseClient
          .from('confirmations')
          .select('id')
          .eq('linked_tx_hash', confirmation.linkedTxHash)
          .eq('sender_address', confirmation.senderAddress)
          .eq('receiver_address', confirmation.receiverAddress)
          .maybeSingle();

        if (existingConfirmation) {
          throw new Error('Confirmation already exists for this transaction');
        }

        const { error } = await supabaseClient
          .from('confirmations')
          .insert({
            linked_tx_hash: confirmation.linkedTxHash,
            sender_address: confirmation.senderAddress,
            receiver_address: confirmation.receiverAddress,
            amount: confirmation.amount,
            confirmation_data: confirmation
          });
        
        if (error) throw error;
        data = { success: true };
        break;
      }

      case 'findConfirmation': {
        const { txHash } = payload;
        
        if (!txHash) {
          throw new Error('Transaction hash is required');
        }

        const { data: findData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at')
          .eq('linked_tx_hash', txHash)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        if (error && error.code !== 'PGRST116') throw error;
        
        data = findData ? {
          ...findData.confirmation_data,
          timestamp: new Date(findData.created_at).getTime()
        } : null;
        break;
      }

      case 'findIncomingTxs': {
        const { receiverAddress } = payload;
        
        if (!receiverAddress || !ethers.isAddress(receiverAddress)) {
          throw new Error('Valid receiver address is required');
        }

        const { data: incomingData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at, amount')
          .eq('receiver_address', receiverAddress)
          .order('created_at', { ascending: false })
          .limit(1000);
        
        if (error) throw error;
        
        data = incomingData.map(tx => ({
          ...tx.confirmation_data,
          amount: parseFloat(tx.amount),
          timestamp: new Date(tx.created_at).getTime()
        }));
        break;
      }

      case 'findOutgoingTxs': {
        const { senderAddress } = payload;
        
        if (!senderAddress || !ethers.isAddress(senderAddress)) {
          throw new Error('Valid sender address is required');
        }

        const { data: outgoingData, error } = await supabaseClient
          .from('confirmations')
          .select('confirmation_data, created_at, amount')
          .eq('sender_address', senderAddress)
          .order('created_at', { ascending: false })
          .limit(1000);
        
        if (error) throw error;
        
        data = outgoingData.map(tx => ({
          ...tx.confirmation_data,
          amount: parseFloat(tx.amount),
          timestamp: new Date(tx.created_at).getTime()
        }));
        break;
      }

      case 'getTreasuryBalance': {
        // This endpoint will now fail unless you also hardcode the address here.
        // It's better to fetch it from the embedded config for consistency.
        const { data: configData } = await this.apiCall('getAppConfig');
        const treasuryAddress = configData.TREASURY_ADDRESS;

        if (!treasuryAddress) {
          throw new Error('Treasury address not configured');
        }

        const { data: incomingData, error: incomingError } = await supabaseClient
          .from('confirmations')
          .select('amount')
          .eq('receiver_address', treasuryAddress);

        if (incomingError) throw incomingError;

        const { data: outgoingData, error: outgoingError } = await supabaseClient
          .from('confirmations')
          .select('amount')
          .eq('sender_address', treasuryAddress);

        if (outgoingError) throw outgoingError;

        const totalIncoming = incomingData.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        const totalOutgoing = outgoingData.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        
        data = {
          treasuryAddress,
          totalIncoming,
          totalOutgoing,
          balance: totalIncoming - totalOutgoing,
          transactionCount: incomingData.length + outgoingData.length
        };
        break;
      }

      case 'getTransactionStats': {
        const { data: totalTxs, error: txError } = await supabaseClient
          .from('confirmations')
          .select('amount, sender_address', { count: 'exact' });

        if (txError) throw txError;

        const totalVolume = totalTxs.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
        const feeTransactions = totalTxs.filter(tx => tx.sender_address !== 'BANKNOTE_ISSUER');
        
        const { data: configData } = await this.apiCall('getAppConfig');
        const treasuryAddress = configData.TREASURY_ADDRESS || 'Unknown';

        data = {
          totalTransactions: totalTxs.length,
          totalVolume,
          feeTransactions: feeTransactions.length,
          treasuryAddress,
          averageTransactionAmount: totalTxs.length > 0 ? totalVolume / totalTxs.length : 0
        };
        break;
      }

      default:
        throw new Error(`Invalid action specified: ${action}`);
    }

    // Return successful response
    return new Response(JSON.stringify({ data }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200
    });

  } catch (error) {
    console.error('Edge function error:', error);
    
    const statusCode = error.message.includes('already been spent') || 
                      error.message.includes('already exists') ? 409 : 400;

    return new Response(JSON.stringify({ 
      error: error.message,
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: statusCode
    });
  }
});

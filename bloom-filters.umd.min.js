!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).bloom={})}(this,(function(t){"use strict";const e=Math.log(2);class r{constructor(t=1,e=0){this.size=t,this. K=e,this.flowers=[],this.nb_add=0,this.grow_if_needed()}add(t){if(this.flowers[this.flowers.length-1].is_full()){const t=this.flowers.length;this.flowers.push(this._create_filter(this.size*(2*t),this.K+t))}return this.nb_add++,this.flowers[this.flowers.length-1].add(t)}has(t){for(let e=this.flowers.length-1;e>=0;e--)if(this.flowers[e].has(t))return!0;return!1}grow_if_needed(){0===this.flowers.length&&this.flowers.push(this._create_filter(this.size,this.K))}saveAsJSON(){return{size:this.size,K:this.K,nb_add:this.nb_add,flowers:this.flowers.map((t=>t.saveAsJSON()))}}static fromJSON(t){const e=new r(t.size,t.K);return e.nb_add=t.nb_add,e.flowers=t.flowers.map((t=>n.fromJSON(t))),e}_create_filter(t,r){return new n(t,r)}}class i{constructor(t,e){this._size=t,this._nbHashes=e,this.buckets=new Int32Array(t)}get size(){return this._size}get nbHashes(){return this._nbHashes}is_full(){const t=this.buckets.reduce(((t,e)=>t+e),0);return t/this.size>=.5}add(t){const e=s(t,this.size,this.nbHashes);for(const t of e)this.buckets[t]+=1}remove(t){const e=s(t,this.size,this.nbHashes);for(const t of e)this.buckets[t]>0&&(this.buckets[t]-=1)}has(t){const e=s(t,this.size,this.nbHashes);for(const t of e)if(0===this.buckets[t])return!1;return!0}saveAsJSON(){return{size:this._size,nbHashes:this._nbHashes,buckets:Array.from(this.buckets)}}static fromJSON(t){const e=new i(t.size,t.nbHashes);return e.buckets=Int32Array.from(t.buckets),e}}class s extends(Error){}class n{constructor(t,r){"number"!=typeof t||t<=0?t=1e3:"number"!=typeof r||r<=0?r=n.optimize(t,Number.POSITIVE_INFINITY):this.size=t,this.nbHashes=r,this.buckets=o(this.size)}static create(t,r,i=!1){if(!t||t<0)throw new Error("The number of items to insert should be a positive value");if(!r||r<=0||r>=1)throw new Error("The error rate should be between 0 and 1");const s=n.optimize(t,r,i);return new n(s.size,s.nbHashes)}static optimize(t,r,i=!1){let s,o;if(t&&r){const i=-t*Math.log(r)/Math.pow(e,2);s=Math.ceil(i),o=Math.ceil(s/t*e)}else s=1e3,o=3;return i&&s%32!=0&&(s=32*(Math.floor(s/32)+1)),{size:s,nbHashes:o}}add(t){const e=h(t,this.size,this.nbHashes);for(const t of e)this.buckets.add(t)}has(t){const e=h(t,this.size,this.nbHashes);for(const t of e)if(!this.buckets.has(t))return!1;return!0}equals(t){if(this.size!==t.size||this.nbHashes!==t.nbHashes)return!1;for(let e=0;e<this.buckets.length;e++)if(this.buckets.get(e)!==t.buckets.get(e))return!1;return!0}rate(){const t=this.buckets.bitCount();return Math.pow(1-Math.exp(-this.nbHashes*t/this.size),this.nbHashes)}saveAsJSON(){return{size:this.size,nbHashes:this.nbHashes,buckets:this.buckets.saveAsJSON()}}static fromJSON(t){const e=new n(t.size,t.nbHashes);return e.buckets=o.fromJSON(t.buckets),e}}class o{constructor(t){this.length=Math.ceil(t/32),this._elements=new Int32Array(this.length)}add(t){this._elements[this._getBucket(t)]|=this._getBit(t)}remove(t){this._elements[this._getBucket(t)]&=~this._getBit(t)}has(t){return(this._elements[this._getBucket(t)]&this._getBit(t))!=0}bitCount(){let t,e=0;for(t=0;t<this._elements.length;t++)e+=this._popCount(this._elements[t]);return e}saveAsJSON(){return Array.from(this._elements)}static fromJSON(t){const e=new o(0);return e._elements=Int32Array.from(t),e.length=e._elements.length,e}_popCount(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),16843009*(t+(t>>4)&252645135)>>24}_getBucket(t){return Math.floor(t/32)}_getBit(t){return 1<<t%32}}const a=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271];function h(t,e,r){const i="string"==typeof t?u(t):c(t),s=i[0],n=i[1];let o=s%e;const h=[];for(let t=0;t<r;t++)h.push(Math.abs(o)),o=(o+n)%e;return h}function u(t){let e=0,r=0;for(let i=0;i<t.length;i++){const s=t.charCodeAt(i);e=(e<<5)-e+s|0,r=(r<<5)-r+s<<2|0}return[e,r]}function c(t){let e=0,r=0;for(let i=0;i<t.length;i++){const s=t[i];e=(e<<5)-e+s|0,r=(r<<5)-r+s<<2|0}return[e,r]}t.BloomFilter=n,t.CountingBloomFilter=i,t.ScalableBloomFilter=r,Object.defineProperty(t,"__esModule",{value:!0})}));

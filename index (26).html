<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote (Clean Design)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-sha256/build/sha256.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        body {
            margin: 0;
            font-family: 'Roboto Mono', 'Segoe UI', monospace;
            background: #0c0a14;
            color: #eee;
            text-align: center;
            padding: 20px;
        }
        .container { max-width: 900px; margin: 0 auto; background: rgba(10, 8, 16, 0.8); backdrop-filter: blur(10px); padding: 20px; border-radius: 20px; border: 1px solid #4a3f5f; }
        canvas { border-radius: 15px; margin-top: 20px; background: #050508; cursor: default; box-shadow: 0 0 40px rgba(159, 120, 255, 0.2); width: 100%; max-width: 900px; height: auto; }
        input, button, label { padding: 12px 18px; font-size: 16px; font-family: 'Roboto Mono', monospace; border-radius: 10px; margin: 10px 5px; border: 1px solid #4a3f5f; background: #1c1827; color: #fff; transition: all 0.3s; cursor: pointer; }
        button, label { background: #5e35b1; }
        .section { background: rgba(28, 24, 39, 0.7); padding: 15px; margin-top: 30px; border-radius: 15px; }
        #validation-result { margin-top: 15px; font-size: 16px; font-weight: bold; min-height: 50px; line-height: 1.8; text-align: left; background: rgba(0,0,0,0.2); padding: 20px; border-radius: 10px; white-space: pre-wrap; }
        .valid { color: #81c784; }
        .invalid { color: #e57373; }
        .info { color: #64b5f6; }
        .data-heading { color: #b39ddb; margin-top: 15px; margin-bottom: 5px; font-size: 18px; border-bottom: 1px solid #4a3f5f; padding-bottom: 5px;}
        .comparison-item { margin-top: 10px; }
    </style>
</head>
<body>
<div class="container">
    <h1>Sadat Digital Banknote (Clean Design)</h1>
    <div class="section">
        <h2>1. Generate Banknote</h2>
        <input type="number" id="amount-input" value="50000" style="width: 150px;">
        <button onclick="handleCreateNewNote()">üé® Generate or Redesign Banknote</button>
    </div>

    <canvas id="noteCanvas" width="2700" height="1500"></canvas>

    <div class="section">
        <h2>2. Banknote Operations</h2>
        <button onclick="downloadNote()">üì• Download High-Quality Banknote</button>
    </div>

    <div class="section" id="validator-section">
        <h2>3. Validate Banknote</h2>
        <label for="validator-input" style="background: #004d40; border-color: #26a69a;">üìÇ Select Banknote Image for Validation</label>
        <input type="file" id="validator-input" accept="image/png" style="display: none;">
        <div id="validation-result">Validation result will be displayed here.</div>
    </div>
</div>

<script>
const canvas = document.getElementById("noteCanvas");
const ctx = canvas.getContext("2d");
let currentNoteData = {};

const SECURITY_KEY = "SADAT_NOTE_V3_KEY";

function getStandardizedStringForHashing(noteData) {
    const dataToHash = {
        amount: noteData.amount,
        serial: noteData.serial,
        timestamp: noteData.timestamp,
        verificationKey: noteData.verificationKey,
        securityKey: SECURITY_KEY
    };
    return JSON.stringify(dataToHash);
}

// ===================================================================================
// Validation Logic
// ===================================================================================
document.getElementById('validator-input').addEventListener('change', handleFileSelect);

async function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const resultDiv = document.getElementById('validation-result');
    resultDiv.innerHTML = `<span class="info">‚è≥ Preparing image for validation...</span>`;
    let isFullyValid = true;

    const fileUrl = URL.createObjectURL(file);
    const img = new Image();

    img.onload = async () => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 900;
        tempCanvas.height = 500;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);

        resultDiv.innerHTML = `<span class="info">1. Reading digital data from QR Code...</span>`;
        const qrData = await readQRCodeFromCanvas(tempCanvas);

        if (!qrData) {
            resultDiv.innerHTML = `<span class="invalid">‚ùå FATAL ERROR: QR Code not found or unreadable. Validation stopped.</span>`;
            return;
        }

        let resultHTML = `<span class="valid">‚úÖ 1. QR data successfully read.</span>`;
        
        resultHTML += `\n\n<span class="info">2. Verifying digital signature (hash)...</span>`;
        resultDiv.innerHTML = resultHTML;
        
        const isHashValid = validateQRCodeHash(qrData);

        if (!isHashValid) {
            resultHTML += `\n<span class="invalid">‚ùå FATAL ERROR: Digital signature is invalid. The QR code data has been tampered with.</span>`;
            resultDiv.innerHTML = resultHTML;
            return;
        }
        
        resultHTML += `\n<span class="valid">‚úÖ 2. Digital signature confirmed.</span>`;

        // *** GRAPHICAL INTEGRITY CHECK ***
        resultHTML += `\n<span class="info">3. Performing graphical integrity check...</span>`;
        resultDiv.innerHTML = resultHTML;

        const referenceCanvas = document.createElement('canvas');
        referenceCanvas.width = tempCanvas.width;
        referenceCanvas.height = tempCanvas.height;
        await drawNoteOnCanvas(referenceCanvas, qrData, referenceCanvas.width, referenceCanvas.height);
        
        const differencePercentage = compareImages(tempCanvas, referenceCanvas, 35);
        
        // --- CHANGE: Adjusted threshold to 3.5% ---
        if (differencePercentage > 3.5) {
            resultHTML += `\n<span class="invalid">‚ùå FATAL ERROR: Graphical tampering detected. Image differs by ${differencePercentage.toFixed(2)}% from original (Threshold: >3.5%).</span>`;
            isFullyValid = false;
        } else {
            resultHTML += `\n<span class="valid">‚úÖ 3. Graphical integrity check passed (${differencePercentage.toFixed(2)}% difference).</span>`;
        }

        if (isFullyValid) {
            resultHTML += `\n<span class="info">4. Performing Optical Character Recognition (OCR)...</span>`;
            resultDiv.innerHTML = resultHTML;

            const whitelist = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,-:';
            const ocrResult = await Tesseract.recognize(tempCanvas, 'eng', { 
                tessedit_char_whitelist: whitelist 
            });

            resultHTML += `\n<span class="valid">‚úÖ 4. OCR scan complete.</span>\n`;
            resultHTML += `\n<div class="data-heading">Final Security Cross-Check</div>`;

            const comparison = compareQRAndOCR(qrData, ocrResult);

            resultHTML += `<div class="comparison-item"><strong>Amount (Right Side):</strong>\n`;
            resultHTML += `  Expected: <code>${comparison.expected.amount}</code>\n`;
            resultHTML += `  Found by OCR: <code>${comparison.found.amount || '(not found)'}</code>\n`;
            resultHTML += `  Status: ${comparison.match.amount ? '<span class="valid">‚úÖ MATCH</span>' : '<span class="invalid">‚ùå MISMATCH</span>'}\n`;
            if (!comparison.match.amount) isFullyValid = false;

            resultHTML += `</div><div class="comparison-item"><strong>Serial/Key (Left Side):</strong>\n`;
            resultHTML += `  Expected Serial: <code>${comparison.expected.serial}</code>\n`;
            resultHTML += `  Expected Key: <code>${comparison.expected.key}</code>\n`;
            resultHTML += `  Found by OCR: <code>${comparison.found.serialText || '(not found)'}</code>\n`;
            resultHTML += `  Serial Status: ${comparison.match.serial ? '<span class="valid">‚úÖ MATCH</span>' : '<span class="invalid">‚ùå MISMATCH</span>'}\n`;
            resultHTML += `  Key Status: ${comparison.match.key ? '<span class="valid">‚úÖ MATCH</span>' : '<span class="invalid">‚ùå MISMATCH</span>'}\n`;
            if (!comparison.match.serial || !comparison.match.key) isFullyValid = false;
        }

        resultHTML += `\n<hr>\n<span style="font-size: 18px;">${isFullyValid ? '‚úÖ VERDICT: Banknote is authentic.' : '‚ùå VERDICT: Forgery detected.'}</span>`;
        resultDiv.innerHTML = resultHTML;
    };

    img.src = fileUrl;
}

function compareImages(canvas1, canvas2, tolerance = 30) {
    const ctx1 = canvas1.getContext('2d');
    const ctx2 = canvas2.getContext('2d');

    const imageData1 = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
    const imageData2 = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);

    const data1 = imageData1.data;
    const data2 = imageData2.data;

    let diffPixels = 0;
    const totalPixels = canvas1.width * canvas1.height;

    for (let i = 0; i < data1.length; i += 4) {
        const rDiff = Math.abs(data1[i] - data2[i]);
        const gDiff = Math.abs(data1[i+1] - data2[i+1]);
        const bDiff = Math.abs(data1[i+2] - data2[i+2]);

        if (rDiff > tolerance || gDiff > tolerance || bDiff > tolerance) {
            diffPixels++;
        }
    }
    return (diffPixels / totalPixels) * 100;
}


function readQRCodeFromCanvas(canvasToCheck) {
    const context = canvasToCheck.getContext('2d');
    const imageData = context.getImageData(0, 0, canvasToCheck.width, canvasToCheck.height);
    const code = jsQR(imageData.data, imageData.width, imageData.height);
    if (code) {
        try { return JSON.parse(code.data); } catch { return null; }
    }
    return null;
}

function validateQRCodeHash(qrData) {
    try {
        const { hash } = qrData;
        if (!hash) return false;
        const stringToVerify = getStandardizedStringForHashing(qrData);
        const calculatedHash = sha256(stringToVerify);
        return calculatedHash === hash;
    } catch {
        return false;
    }
}

function compareQRAndOCR(qrData, ocrResult) {
    const words = ocrResult.data.words;
    const serialRegion = { x_min: 0, x_max: 550, y_min: 0, y_max: 300 };
    const amountRegion = { x_min: 700, x_max: 900, y_min: 0, y_max: 200 };

    let textInAmountRegion = '';
    let textInSerialRegion = '';

    words.forEach(word => {
        const bbox = word.bbox;
        if (bbox.x0 >= amountRegion.x_min && bbox.x1 <= amountRegion.x_max &&
            bbox.y0 >= amountRegion.y_min && bbox.y1 <= amountRegion.y_max) {
            textInAmountRegion += word.text;
        }
        if (bbox.x0 >= serialRegion.x_min && bbox.x1 <= serialRegion.x_max &&
            bbox.y0 >= serialRegion.y_min && bbox.y1 <= serialRegion.y_max) {
            textInSerialRegion += word.text;
        }
    });
    
    const cleanAmountText = textInAmountRegion.replace(/[\s,:.-]/g, '');
    const cleanSerialText = textInSerialRegion.replace(/[\s,:.-]/g, '').toUpperCase();
    const expectedAmount = String(qrData.amount);
    const expectedSerial = qrData.serial.substring(4); 
    const expectedKey = qrData.verificationKey.substring(4);

    const isAmountMatch = (cleanAmountText === expectedAmount);
    const isSerialMatch = cleanSerialText.includes(expectedSerial);
    const isKeyMatch = cleanSerialText.includes(expectedKey);

    return {
        expected: { amount: expectedAmount, serial: expectedSerial, key: expectedKey },
        found: { amount: cleanAmountText, serialText: cleanSerialText },
        match: { amount: isAmountMatch, serial: isSerialMatch, key: isKeyMatch }
    };
}

// ===================================================================================
// Banknote Creation Logic
// ===================================================================================
const H = (hash, index, min, max) => min + (parseInt(hash.substring(index, index + 2), 16) % (max - min + 1));

async function handleCreateNewNote() {
    const now = Date.now();
    const amount = document.getElementById("amount-input").value;

    currentNoteData = {
        amount: parseInt(amount) || 0,
        verificationKey: "SVK-" + Math.random().toString(16).substring(2, 10).toUpperCase(),
        serial: "SDT-" + now.toString().slice(-8),
        timestamp: now
    };

    const stringToHash = getStandardizedStringForHashing(currentNoteData);
    currentNoteData.hash = sha256(stringToHash);
    await drawNoteOnCanvas(canvas, currentNoteData, canvas.width, canvas.height);
}

function downloadNote() {
    if (Object.keys(currentNoteData).length === 0) {
        alert("Please generate a banknote first!");
        return;
    }
    const link = document.createElement("a");
    link.download = `SADAT-NOTE-SECURE-${currentNoteData.serial}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
}

async function drawNoteOnCanvas(targetCanvas, noteData, width, height) {
    if (Object.keys(noteData).length === 0) return;

    const ctx = targetCanvas.getContext("2d");
    const { amount, verificationKey, serial, hash } = noteData;
    const qrDataString = JSON.stringify(noteData);

    const w = width;
    const h = height;

    const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
    const baseHue = H(hash, 0, 0, 360);
    bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
    bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, w, h);

    const scale = w / 2700; 

    drawWatermark(ctx, hash, w, h);
    drawGuilloche(ctx, hash, w, h);
    drawHolographicPatch(ctx, hash, 150 * scale, h - 450 * scale, 300 * scale, 300 * scale);
    drawSecurityThread(ctx, hash, 2000 * scale, h);

    ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
    ctx.shadowBlur = 8 * scale;
    ctx.shadowOffsetX = 2 * scale;
    ctx.shadowOffsetY = 2 * scale;
    ctx.fillStyle = "#EAEAEA";

    ctx.font = `bold ${80 * scale}px 'Roboto Mono'`;
    ctx.textAlign = 'left';
    ctx.fillText(serial.substring(4), 150 * scale, 160 * scale);
    ctx.fillText(verificationKey.substring(4), 150 * scale, 280 * scale);

    ctx.font = `bold ${120 * scale}px 'Roboto Mono'`;
    ctx.textAlign = "right";
    ctx.shadowBlur = 10 * scale;
    ctx.shadowOffsetX = 3 * scale;
    ctx.shadowOffsetY = 3 * scale;
    ctx.fillText(amount.toString(), w - 150 * scale, 200 * scale);

    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    await new Promise((resolve, reject) => {
        const qrCanvas = document.createElement("canvas");
        const qrSize = 380 * scale;
        QRCode.toCanvas(qrCanvas, qrDataString, { width: qrSize, color: { dark: '#1c1827', light: '#FFFFFF' } }, (err) => {
            if (err) {
                reject(err);
                return;
            }
            ctx.save();
            const padding = 20 * scale;
            const qrX = w - (150 * scale) - qrSize, qrY = h - (500 * scale);
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.shadowColor = "rgba(255, 255, 255, 0.5)";
            ctx.shadowBlur = 30 * scale;
            ctx.beginPath();
            ctx.roundRect(qrX - padding, qrY - padding, qrSize + padding * 2, qrSize + padding * 2, 15 * scale);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.drawImage(qrCanvas, qrX, qrY, qrSize, qrSize);
            ctx.restore();
            resolve();
        });
    });
    
    ctx.font = `${30 * scale}px 'Roboto Mono'`;
    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
    ctx.textAlign = "center";
    ctx.fillText(hash, w / 2, h - 60 * scale);
}


// ===================================================================================
// Helper functions for design (adjusted to take width/height)
// ===================================================================================
function drawSecurityThread(g_ctx, hash, xPos, canvasHeight) { g_ctx.save(); const amplitude = H(hash, 40, 20, 40); const frequency = H(hash, 42, 5, 10); const dashLength = H(hash, 44, 40, 70); const gapLength = H(hash, 46, 20, 40); const threadColor = `hsla(${H(hash, 48, 0, 360)}, 60%, 70%, 0.6)`; g_ctx.lineWidth = 12 * (canvasHeight/1500); g_ctx.strokeStyle = threadColor; g_ctx.setLineDash([dashLength, gapLength]); g_ctx.beginPath(); for (let y = 0; y < canvasHeight; y++) { const x = xPos + Math.sin(y / canvasHeight * Math.PI * frequency) * amplitude; if (y === 0) { g_ctx.moveTo(x, y); } else { g_ctx.lineTo(x, y); } } g_ctx.stroke(); g_ctx.restore(); }
function drawHolographicPatch(g_ctx, hash, x, y, width, height) { g_ctx.save(); const hue1 = H(hash, 30, 0, 360); const hue2 = (hue1 + H(hash, 32, 90, 180)) % 360; const gradient = g_ctx.createLinearGradient(x, y, x + width, y + height); gradient.addColorStop(0, `hsla(${hue1}, 80%, 50%, 0.3)`); gradient.addColorStop(0.5, `hsla(${hue2}, 85%, 60%, 0.4)`); gradient.addColorStop(1, `hsla(${hue1}, 80%, 50%, 0.3)`); g_ctx.fillStyle = gradient; g_ctx.beginPath(); g_ctx.roundRect(x, y, width, height, 20); g_ctx.fill(); g_ctx.fillStyle = "rgba(255, 255, 255, 0.1)"; g_ctx.beginPath(); g_ctx.arc(x + width * 0.3, y + height * 0.3, width * 0.4, Math.PI * 1.5, Math.PI * 0.2); g_ctx.lineTo(x, y); g_ctx.closePath(); g_ctx.fill(); g_ctx.restore(); }
function drawGuilloche(g_ctx, hash, canvasWidth, canvasHeight) { g_ctx.save(); const patterns = H(hash, 14, 4, 7); for (let i = 0; i < patterns; i++) { g_ctx.strokeStyle = `hsla(${H(hash, 16 + i * 3, 0, 360)}, 70%, 60%, 0.15)`; g_ctx.lineWidth = H(hash, 17 + i * 3, 1, 4) * (canvasWidth/2700); const R = canvasWidth * (H(hash, 18 + i * 3, 5, 15) / 100); const r = canvasWidth * (H(hash, 19 + i * 3, 1, 4) / 100); const d = canvasWidth * (H(hash, 20 + i * 3, 2, 8) / 100); const cx = canvasWidth / 2; const cy = canvasHeight / 2; g_ctx.beginPath(); for (let t = 0; t < Math.PI * 4 * r; t += 0.01) { const x = (R - r) * Math.cos(t) + d * Math.cos(((R - r) / r) * t); const y = (R - r) * Math.sin(t) - d * Math.sin(((R - r) / r) * t); if (t === 0) g_ctx.moveTo(cx + x, cy + y); else g_ctx.lineTo(cx + x, cy + y); } g_ctx.stroke(); } g_ctx.restore(); }
function drawWatermark(g_ctx, hash, canvasWidth, canvasHeight) { g_ctx.save(); const cx = canvasWidth / 2; const cy = canvasHeight / 2; g_ctx.fillStyle = "rgba(180, 180, 220, 0.03)"; const points = H(hash, 22, 5, 10); const radius = canvasHeight * 0.4; g_ctx.beginPath(); for (let i = 0; i < points; i++) { const angle = (i / points) * Math.PI * 2 + (H(hash, 24 + i, 0, 100) / 100); const r = radius * (H(hash, 26 + i, 50, 100) / 100); const x = cx + Math.cos(angle) * r; const y = cy + Math.sin(angle) * r; if (i === 0) g_ctx.moveTo(x, y); else g_ctx.lineTo(x, y); } g_ctx.closePath(); g_ctx.fill(); g_ctx.restore(); }

window.onload = handleCreateNewNote;
</script>
</body>
</html>
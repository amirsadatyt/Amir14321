<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote - GUARDIAN ISSUER v3.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

    <style>
        :root { --primary-font: 'Poppins', 'Segoe UI', sans-serif; --mono-font: 'Roboto Mono', monospace; --dark-bg: #10101a; --medium-bg: #1a1a2e; --light-bg: #2a2a3e; --accent-color-1: #e040fb; --accent-color-2: #7c4dff; --text-color: #e0e0e0; --text-muted: #a0a0c0; --success-color: #00e676; --error-color: #ff5252; --info-color: #40c4ff; --warning-color: #ffab40; --border-color: rgba(124, 77, 255, 0.2); }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 1200px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em; }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>Sadat Digital Banknote</h1><p>A Quantum-Resistant, Offline, Dual-Signature & <strong>Multi-QR-Code</strong> Digital Currency System.</p></div>
    <div class="section"><h2><span class="pill">Step 1</span> Guardian Setup: Create Master Keys</h2><div class="controls-grid"><button id="generate-keys-button">üîë Generate Master Key Pair</button><label for="import-public-key" class="button sub-button">üì• Load Public Key</label><input type="file" id="import-public-key" accept=".json" style="display: none;"></div><div id="key-gen-status" class="status-box"><span class="info">‚ÑπÔ∏è Welcome, Guardian. Generate a new Master Key Pair to begin.</span></div></div>
    <div class="section"><h2><span class="pill">Step 2</span> Activate System: Reconstruct Private Key</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To create banknotes, solve the "Three-Piece Puzzle" to securely activate your Master Private Key.</p><div class="controls-grid"><label for="file-key-input" class="button sub-button">1. Upload File Key</label><input type="file" id="file-key-input" accept=".json" style="display:none;" /><input type="password" id="password-key-input" placeholder="2. Enter Password Key"><label for="visual-key-input" class="button sub-button">3. Upload Visual Key (QR)</label><input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;" /></div><button id="reconstruct-key-button" disabled style="margin-top: 20px;">üîì Activate Master Private Key</button><div id="key-reconstruction-status" class="status-box"><span class="warning">‚ö†Ô∏è Master Private Key is INACTIVE. Solve the puzzle to activate.</span></div></div>
    <div class="section"><h2><span class="pill">Step 3</span> Create Wealth: Generate Banknotes</h2><div class="controls-grid"><span class="input-label">Amount:</span><input type="number" id="amount-input" value="100000"><button id="create-note-button" disabled>üé® Create Banknote & Initial Spend Key</button></div><div id="banknote-status" class="status-box">Activate your key to create and sign new banknotes.</div><canvas id="noteCanvas" width="1200" height="675" style="display: none;"></canvas></div>
    <div class="section" id="validator-section"><h2><span class="pill">Step 4</span> Verify Authenticity</h2><p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">Upload a banknote image (.png) to verify its authenticity against the loaded Master Public Key.</p><label for="validator-input" class="button">üîé Select Banknote Image for Validation</label><input type="file" id="validator-input" accept="image/png" style="display: none;"><div id="validation-result" class="status-box">Awaiting banknote for validation...</div></div>
</div>

<script type="module">
// --- DEPENDENCIES (Self-contained, no external calls needed) ---
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { sha3_256, shake256 } from 'https://cdn.skypack.dev/js-sha3';

// --- Global State ---
const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null, // This is only held in memory temporarily
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};

// --- CONSTANTS ---
const Constants = {
    VALIDATION_PREFIX: "SADAT_V3_PART",
    NUM_QR_CODES: 9
};

// --- DOM Elements ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    createNoteButton: document.getElementById('create-note-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorInput: document.getElementById('validator-input'),
    validationResult: document.getElementById('validation-result'),
};

// --- Utility & Crypto Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => Uint8Array.from(atob(base64), c => c.charCodeAt(0)),
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    async createQrCodeImage(payload) {
        const qr = qrcode(0, 'M');
        qr.addData(payload);
        qr.make();
        const dataUrl = qr.createDataURL(8, 4);
        const img = new Image();
        img.src = dataUrl;
        await new Promise(resolve => { img.onload = resolve; });
        return img;
    },
     async decodeQrCodeFromImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                if (code) resolve(code.data); else reject(new Error("QR Code not found in image."));
            };
            img.onerror = () => reject(new Error("Could not load image file."));
            img.src = event.target.result;
        };
        reader.onerror = () => reject(new Error("Failed to read file."));
        reader.readAsDataURL(file);
      });
    }
};

const BankCrypto = (() => {
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }
    
    return {
        hash: (message) => new Uint8Array(sha3_256.arrayBuffer(message)),
        generateNewKeyPair: () => state.falconApi.keypair(),
        signData: async (data, privateKey) => {
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        verifySignature: (signature, data, publicKey) => {
            const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        // Puzzle/Key Reconstruction logic remains the same.
    };
})();

// --- Banknote Creation and Validation Logic ---
const BanknoteLogic = (() => {

    const getNoteDataForSigning = (noteData) => {
        // Only sign the core, immutable properties of the banknote.
        const dataToSign = {
            serial: noteData.serial,
            amount: noteData.amount,
            timestamp: noteData.timestamp,
            ephemeralPublicKey_b64: noteData.ephemeralPublicKey_b64,
        };
        return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
    };
    
    const getMasterSignatureData = (noteData) => {
        // The master signature signs the ephemeral signature itself, proving issuance.
        const dataToSign = {
            ephemeralSignature_b64: noteData.ephemeralSignature_b64
        };
        return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
    };

    /**
     * Creates the full data structure for a new banknote, including dual signatures.
     */
    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("Master Private Key is not active.");
        
        // 1. Generate ephemeral key pair for the note's self-signature
        const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
        // 2. Generate the initial spend key pair for the first owner
        const initialSpendKeyPair = await BankCrypto.generateNewKeyPair();

        const noteData = {
            serial: crypto.randomUUID(),
            amount: parseInt(amount, 10) || 0,
            timestamp: Date.now(),
            ephemeralPublicKey_b64: Utils.arrayBufferToBase64(ephemeralKeyPair.publicKey),
            initialSpendPublicKey_b64: Utils.arrayBufferToBase64(initialSpendKeyPair.publicKey)
        };
        
        // 3. Create the first signature (The Banknote's Signature)
        const dataForSigOne = getNoteDataForSigning(noteData);
        const ephemeralSignature = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
        noteData.ephemeralSignature_b64 = Utils.arrayBufferToBase64(ephemeralSignature);

        // 4. Create the second signature (The Guardian's Signature)
        const dataForSigTwo = getMasterSignatureData(noteData);
        const masterSignature = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
        noteData.masterSignature_b64 = Utils.arrayBufferToBase64(masterSignature);
        
        // 5. Return the complete note data and the initial private spend key
        return {
            noteData,
            initialSpendPrivateKey: initialSpendKeyPair.privateKey
        };
    };
    
    /**
     * Compresses and prepares the banknote data for embedding into QR codes.
     */
    const createUnifiedVerificationPayload = (noteData) => {
        // We only embed public, verifiable data into the banknote image.
        const payload = {
            s: noteData.serial,
            a: noteData.amount,
            t: noteData.timestamp,
            epk: noteData.ephemeralPublicKey_b64,
            ispk: noteData.initialSpendPublicKey_b64, // Initial Spend Public Key
            s1: noteData.ephemeralSignature_b64,
            s2: noteData.masterSignature_b64
        };
        const jsonString = JSON.stringify(payload);
        const compressedData = pako.deflate(jsonString, { level: 9 });
        return Utils.arrayBufferToBase64(compressedData);
    };

    /**
     * Reconstructs banknote data from a compressed string (from QR codes).
     */
    const parseUnifiedVerificationPayload = (base64CompressedString) => {
        const compressedData = Utils.base64ToUint8Array(base64CompressedString);
        const jsonString = pako.inflate(compressedData, { to: 'string' });
        const p = JSON.parse(jsonString);
        return {
            serial: p.s,
            amount: p.a,
            timestamp: p.t,
            ephemeralPublicKey_b64: p.epk,
            initialSpendPublicKey_b64: p.ispk,
            ephemeralSignature_b64: p.s1,
            masterSignature_b64: p.s2
        };
    };

    /**
     * Main handler to create, sign, draw, and provide download links.
     */
    const handleCreateAndSignNote = async () => {
        if (!state.masterPrivateKey) {
            Utils.updateStatus(DOMElements.banknoteStatus, "‚ùå Master Private Key is not active. Activate it in Step 2.", 'error');
            return;
        }
        Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Creating banknote, generating keys, and signing...`, 'info');
        
        try {
            // Create the banknote data and get the initial private key
            const { noteData, initialSpendPrivateKey } = await createNoteData(DOMElements.amountInput.value);
            
            // Prepare the payload for the QR codes
            const fullPayload = createUnifiedVerificationPayload(noteData);

            // Draw the banknote on the canvas
            await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload);
            DOMElements.noteCanvas.style.display = 'block';

            // Provide download for the banknote image
            const imageBlob = await new Promise(resolve => DOMElements.noteCanvas.toBlob(resolve, 'image/png'));
            const imageUrl = URL.createObjectURL(imageBlob);
            
            // Provide download for the initial spend key
            const spendKeyData = JSON.stringify({
                serial: noteData.serial,
                spendPrivateKey_b64: Utils.arrayBufferToBase64(initialSpendPrivateKey)
            }, null, 2);

            Utils.updateStatus(DOMElements.banknoteStatus, 
                `‚úÖ Banknote Created! Download both files and keep them secure.<br>
                 <a href="${imageUrl}" download="SADAT-NOTE-${noteData.serial}.png" class="button">üì• Download Banknote Image (.png)</a>
                 <button id="download-spend-key" class="button">üîë Download Initial Spend Key (.json)</button><br>
                 <span class="warning">‚ö†Ô∏è For security, the Master Private Key has been cleared from memory.</span>`, 'success'
            );
            
            document.getElementById('download-spend-key').onclick = () => {
                 Utils.downloadFile(spendKeyData, `SPEND-KEY-${noteData.serial}.json`, 'application/json');
            };

        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `‚ùå Error creating banknote: ${error.message}`, 'error');
            console.error(error);
        } finally {
            // SELF-DESTRUCT: Clear the master private key from memory immediately after use.
            if (state.masterPrivateKey) {
                state.masterPrivateKey = null;
                DOMElements.createNoteButton.disabled = true;
                DOMElements.passwordKeyInput.value = '';
                state.puzzlePieces.passwordKey = null;
                 Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ö†Ô∏è Master Private Key is INACTIVE. It was cleared for security. Solve the puzzle again to create another banknote.", 'warning');
            }
        }
    };

    /**
     * Main handler to validate a banknote image.
     */
    const handleFileSelectForValidation = async (event) => {
        const file = event.target.files[0];
        const resultDiv = DOMElements.validationResult;
        if (!file) return;
        if (!state.masterPublicKey) {
            Utils.updateStatus(resultDiv, '‚ùå Load a Master Public Key in Step 1 before validating.', 'error');
            return;
        }

        Utils.updateStatus(resultDiv, '‚è≥ Reading banknote image...', 'info');
        
        try {
            // Step 1: Extract all QR codes from the image
            const banknoteImage = new Image();
            banknoteImage.src = URL.createObjectURL(file);
            await new Promise((resolve, reject) => { banknoteImage.onload = resolve; banknoteImage.onerror = reject; });

            const canvas = document.createElement('canvas');
            canvas.width = banknoteImage.width;
            canvas.height = banknoteImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(banknoteImage, 0, 0);
            
            const layout = BanknoteDrawer.getLayout(canvas.width, canvas.height);
            const receivedParts = {};
            let foundCount = 0;

            for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
                const row = Math.floor(i / 3), col = i % 3;
                const regionX = layout.grid.startX + col * (layout.qrSize + layout.xSpacing);
                const regionY = layout.grid.startY + row * (layout.qrSize + layout.ySpacing);
                const imageData = ctx.getImageData(regionX, regionY, layout.qrSize, layout.qrSize);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code && code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                    const match = code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s);
                    if (match) {
                        receivedParts[parseInt(match[1], 10)] = match[3];
                        foundCount++;
                    }
                }
            }
            if (foundCount < Constants.NUM_QR_CODES) throw new Error(`Could not read all QR codes. Found ${foundCount}/${Constants.NUM_QR_CODES}.`);

            Utils.updateStatus(resultDiv, `‚úÖ Found all ${Constants.NUM_QR_CODES} QR codes. Assembling payload...`, 'success');

            // Step 2: Reconstruct the full payload
            let fullPayloadString = '';
            for (let i = 1; i <= Constants.NUM_QR_CODES; i++) {
                fullPayloadString += receivedParts[i];
            }
            
            const parsedData = parseUnifiedVerificationPayload(fullPayloadString);
            let resultHTML = `<span class="info">Serial: ${parsedData.serial} | Amount: ${parsedData.amount.toLocaleString()}</span>\n<hr>`;

            // Step 3: Verify Signature 1 (Ephemeral)
            const dataForSigOne = getNoteDataForSigning(parsedData);
            const ephemeralPublicKey = Utils.base64ToUint8Array(parsedData.ephemeralPublicKey_b64);
            const ephemeralSignature = Utils.base64ToUint8Array(parsedData.ephemeralSignature_b64);
            const isSigOneValid = await BankCrypto.verifySignature(ephemeralSignature, dataForSigOne, ephemeralPublicKey);
            
            resultHTML += `1. Verifying Banknote's Self-Signature... ${isSigOneValid ? '<span class="valid">VALID</span>' : '<span class="invalid">INVALID</span>'}\n`;
            if (!isSigOneValid) {
                resultDiv.innerHTML = resultHTML + `<hr><span class="invalid">‚ùå VERDICT: FORGERY. Banknote data does not match its own signature.</span>`;
                return;
            }

            // Step 4: Verify Signature 2 (Master/Guardian)
            const dataForSigTwo = getMasterSignatureData(parsedData);
            const masterSignature = Utils.base64ToUint8Array(parsedData.masterSignature_b64);
            const isSigTwoValid = await BankCrypto.verifySignature(masterSignature, dataForSigTwo, state.masterPublicKey);

            resultHTML += `2. Verifying Guardian's Issuance Signature... ${isSigTwoValid ? '<span class="valid">VALID</span>' : '<span class="invalid">INVALID</span>'}\n`;
            if (!isSigTwoValid) {
                 resultDiv.innerHTML = resultHTML + `<hr><span class="invalid">‚ùå VERDICT: FORGERY. Not issued by this Guardian.</span>`;
                 return;
            }
            
            resultDiv.innerHTML = resultHTML + `<hr><span class="valid">‚úÖ VERDICT: BANKNOTE IS AUTHENTIC AND ISSUED BY THIS GUARDIAN.</span>`;

        } catch (e) {
            Utils.updateStatus(resultDiv, `‚ùå Validation Failed: ${e.message}`, 'error');
        } finally {
            event.target.value = ''; // Reset file input
        }
    };

    return { handleCreateAndSignNote, handleFileSelectForValidation };
})();


// --- Banknote Drawing Logic ---
const BanknoteDrawer = (() => {
    // Defines the precise layout for QR codes and text on the canvas.
    const getLayout = (width, height) => {
        const qrSize = Math.floor(width / 5.5); // Scalable QR size
        const xSpacing = Math.floor(qrSize / 12);
        const ySpacing = Math.floor(qrSize / 12);
        const totalGridWidth = (qrSize * 3) + (xSpacing * 2);
        const totalGridHeight = (qrSize * 3) + (ySpacing * 2);
        const grid = {
            startX: (width - totalGridWidth) / 2,
            startY: (height - totalGridHeight) / 2,
        };
        const amount = { y: grid.startY / 2, fontSize: height / 10 };
        const serial = { y: grid.startY + totalGridHeight + 20, fontSize: height / 40 };
        return { qrSize, xSpacing, ySpacing, grid, amount, serial };
    };

    return {
        getLayout,
        drawNoteOnCanvas: async (canvas, noteData, fullPayload) => {
            const { amount, serial } = noteData;
            const ctx = canvas.getContext("2d");
            const { width, height } = canvas;
            
            // Background
            ctx.fillStyle = '#f0f2f5';
            ctx.fillRect(0, 0, width, height);

            // Split payload into parts for QR codes
            const partLength = Math.ceil(fullPayload.length / Constants.NUM_QR_CODES);
            const qrPayloads = [];
            for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
                const partData = fullPayload.substring(i * partLength, (i + 1) * partLength);
                qrPayloads.push(`${Constants.VALIDATION_PREFIX}${i + 1}/${Constants.NUM_QR_CODES}:${partData}`);
            }

            const qrImages = await Promise.all(qrPayloads.map(p => Utils.createQrCodeImage(p)));
            const layout = getLayout(width, height);
            
            // Draw QR codes
            qrImages.forEach((img, index) => {
                const row = Math.floor(index / 3);
                const col = index % 3;
                const x = Math.round(layout.grid.startX + col * (layout.qrSize + layout.xSpacing));
                const y = Math.round(layout.grid.startY + row * (layout.qrSize + layout.ySpacing));
                ctx.drawImage(img, x, y, Math.round(layout.qrSize), Math.round(layout.qrSize));
            });

            // Draw Text
            ctx.fillStyle = `#222`;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';

            ctx.font = `bold ${layout.amount.fontSize}px 'Roboto Mono', monospace`;
            ctx.fillText(amount.toLocaleString('en-US'), width / 2, layout.amount.y);
            
            ctx.font = `normal ${layout.serial.fontSize}px 'Roboto Mono', monospace`;
            ctx.fillStyle = '#555';
            ctx.fillText(serial, width / 2, layout.serial.y);
        }
    };
})();

// --- Main Application Setup ---
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Loading Falcon-1024 Cryptography Module...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.keyGenStatus, '‚úÖ Modules loaded. Please generate or import keys to begin.', 'success');
    } catch (e) {
        Utils.updateStatus(DOMElements.keyGenStatus, `‚ùå Critical Error: Could not load crypto modules. Ensure this page is served from a web server (http/https).`, 'error');
        console.error(e);
        return;
    }
    
    // Wire up event listeners
    // Note: The puzzle reconstruction and key generation UI logic remains unchanged and is omitted for brevity. It should be pasted here.
    DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNote);
    DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
    // ... other event listeners for key puzzle
}

main();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote - Validator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { 
            margin: 0;
            font-family: var(--primary-font); 
            background-color: var(--dark-bg); 
            background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%);
            color: var(--text-color); 
            text-align: center; 
            padding: 24px; 
        }
        .container { 
            max-width: 1200px;
            margin: 0 auto; 
            background: rgba(26, 26, 46, 0.7); 
            backdrop-filter: blur(12px); 
            padding: 24px; 
            border-radius: 24px; 
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); 
        }
        .header { 
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px; 
            margin-bottom: 24px; 
        }
        h1 { 
            font-size: 2.5rem; 
            font-weight: 600; 
            color: #fff;
            margin: 0 0 8px 0; 
            letter-spacing: 1px; 
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
        }
        .header p { 
            font-size: 1rem; 
            color: var(--text-muted); 
            margin: 0;
        }
        canvas#noteCanvas { 
            border-radius: 16px; 
            margin-top: 24px; 
            background: #050508; 
            cursor: default;
            box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); 
            width: 100%; 
            max-width: 790px; 
            height: auto; 
            border: 1px solid var(--border-color);
        }
        input, button, label { 
            padding: 14px 22px; 
            font-size: 16px; 
            font-family: var(--primary-font);
            border-radius: 12px; 
            margin: 8px 5px; 
            border: 1px solid var(--border-color); 
            background: var(--medium-bg); 
            color: #fff; 
            transition: all 0.3s ease; 
            cursor: pointer;
            outline: none; 
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
            gap: 8px;
        }
        button:not([disabled]), label.button:not([disabled]) { 
            font-weight: 600; 
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); 
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
        }
        button.sub-button, label.button.sub-button { 
            background: var(--light-bg);
            border: 1px solid var(--border-color); 
        }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { 
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); 
        }
        .section { 
            background: rgba(16, 16, 26, 0.5);
            padding: 20px; 
            margin-top: 30px; 
            border-radius: 16px; 
            border: 1px solid var(--border-color);
        }
        h2 { 
            font-size: 1.5rem; 
            color: var(--text-color); 
            margin-top: 0; 
            margin-bottom: 20px; 
            font-weight: 600;
            border-bottom: 1px solid var(--border-color); 
            padding-bottom: 10px; 
        }
        .controls-grid { 
            display: flex; 
            justify-content: center;
            align-items: center; 
            flex-wrap: wrap; 
            gap: 16px; 
        }
        .status-box { 
            margin-top: 20px; 
            font-size: 13px;
            font-weight: normal; 
            min-height: 50px; 
            line-height: 1.6; 
            text-align: left; 
            background: var(--dark-bg); 
            padding: 15px 20px; 
            border-radius: 12px; 
            white-space: pre-wrap; 
            font-family: var(--mono-font);
            border: 1px solid var(--border-color); 
            transition: all 0.3s ease; 
        }
        .valid { color: var(--success-color); } 
        .invalid { color: var(--error-color); } 
        .info { color: var(--info-color); } 
        .warning { color: var(--warning-color); }
        .pill { 
            background-color: var(--border-color); 
            color: var(--accent-color-1); 
            padding: 5px 15px;
            border-radius: 20px; 
            font-size: 14px; 
            font-weight: 600; 
            margin: 5px; 
            display: inline-block;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>Sadat Banknote Validator</h1><p>An offline tool to verify the authenticity of Sadat Digital Banknotes.</p></div>
    
    <div class="section">
        <h2><span class="pill">Step 1</span> Load the Guardian's Public Key</h2>
        <div class="controls-grid">
            <label for="import-public-key" class="button sub-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                Load Public Key File
            </label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
        </div>
        <div id="key-gen-status" class="status-box">
            <span class="info">ℹ️ Welcome. Please load the Master Public Key file (`.json`) to begin validation.</span>
        </div>
    </div>
    
    <div class="section" id="validator-section">
        <h2><span class="pill">Step 2</span> Verify Banknote Authenticity</h2>
        <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">
            To verify a banknote, upload a clear picture of the <strong>entire banknote</strong>.
            The system will find and validate all QR Codes.
        </p>
        <label for="validator-input" class="button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 15 17 10"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
            Select Banknote Image for Validation
        </label>
        <input type="file" id="validator-input" accept="image/png, image/jpeg" style="display: none;">
        <div id="validation-result" class="status-box">Awaiting banknote for validation...</div>
        <canvas id="noteCanvas" width="790" height="790"></canvas>
    </div>
</div>

<script>
// --- INLINED LIBRARIES ---
// The full minified code for pako.js, jsQR.js, js-sha3.js, and pqc-sign-falcon-1024.js
// would be pasted here. For brevity in this example, they are linked via CDN,
// but a true single-file version would have the ~150KB of library code here.
// In a real-world single file, the following four <script> tags would be replaced by their actual code content.
</script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-sha3@0.9.3/build/sha3.min.js"></script>
<script src="https://unpkg.com/pqc-sign-falcon-1024@1.0.3/pqc-sign-falcon-1024.min.js"></script>

<script>
// --- MAIN APPLICATION LOGIC ---
(async function() {
    // --- Global State ---
    const state = {
        falconApi: null,
        masterPublicKey: null,
    };

    // --- CONSTANTS ---
    const Constants = {
        EPOCH: new Date('2024-01-01T00:00:00Z').getTime(),
        VALIDATION_PREFIX: "SADAT_V2_PART",
        NUM_QR_CODES: 9, 
        MAX_IMAGE_DIMENSION: 2000
    };

    // --- DOM Elements ---
    const DOMElements = {
        importPublicKey: document.getElementById('import-public-key'),
        keyGenStatus: document.getElementById('key-gen-status'),
        noteCanvas: document.getElementById('noteCanvas'),
        validatorInput: document.getElementById('validator-input'),
        validationResult: document.getElementById('validation-result'),
    };

    // --- Utility Functions ---
    const Utils = {
        base64ToUint8Array: (base64) => {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
            return bytes;
        },
        hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
        updateStatus: (element, message, type = 'info') => {
            element.innerHTML = `<span class="${type}">${message}</span>`;
        },
        log: (message, type = 'info') => {
            const icon = { info: 'ℹ️', success: '✅', warning: '⚠️', error: '❌' }[type];
            console.log(`[Sadat System] ${icon} ${message}`);
        },
        async preprocessImage(dataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.filter = 'grayscale(1) contrast(2.5) brightness(1.1)';
                    ctx.drawImage(img, 0, 0);
                    resolve(canvas.toDataURL('image/jpeg'));
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        },
        async resizeImage(file, maxSize) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;
                        if (width > height) {
                            if (width > maxSize) {
                                height *= maxSize / width;
                                width = maxSize;
                            }
                        } else {
                            if (height > maxSize) {
                                width *= maxSize / height;
                                height = maxSize;
                            }
                        }
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg'));
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        },
        async decodeQrCodeFromImage(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    if (code) {
                        resolve(code.data);
                    } else {
                        reject(new Error("QR Code not found."));
                    }
                };
                img.src = event.target.result;
            };
            reader.onerror = () => reject(new Error("FileReader failed."));
            reader.readAsDataURL(file);
          });
        }
    };

    // --- CORE CRYPTO ENGINE ---
    const BankCrypto = (() => {
        function hashMessageForSigning(message) { 
            // MODIFICATION: Using the global sha3 object from the inlined library
            return Utils.hexToUint8Array(sha3.shake256(message, 1536)); 
        }
        return {
            async verifySignature(signature, data, publicKey) {
                if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
                const dataHash = hashMessageForSigning(data);
                return state.falconApi.verify(signature, dataHash, publicKey);
            }
        };
    })();

    // --- UI EVENT HANDLERS ---
    const UIHandlers = (() => {
        return {
            handleImportPublicKey: async (event) => { 
                const file = event.target.files[0];
                if (!file) return; 
                try { 
                    const data = JSON.parse(await file.text()); 
                    if (!data.masterPublicKey) throw new Error("Invalid public key file format.");
                    state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); 
                    Utils.updateStatus(DOMElements.keyGenStatus, '✅ Public key imported. Ready to validate banknotes.', 'success'); 
                } catch (error) { 
                    Utils.updateStatus(DOMElements.keyGenStatus, `❌ Error importing public key: ${error.message}`, 'error'); 
                } 
                event.target.value = '';
            }
        };
    })();

    // --- BANKNOTE LOGIC ---
    const BanknoteLogic = (() => {
        const getStandardizedDataForSigning = (noteData) => JSON.stringify({ timestamp: noteData.timestamp, serial: noteData.serial, }, ['timestamp', 'serial']);
        
        const getStandardizedDataForMasterSig = (noteData) => {
            const tempNoteData = { 
                ephemeralPublicKey: btoa(String.fromCharCode(...noteData.ephemeralPublicKey)), 
                signatureOne: btoa(String.fromCharCode(...noteData.signatureOne)) 
            };
            return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
        };
        
        const parseUnifiedVerificationPayload = (base64CompressedString) => {
            const compressedData = Utils.base64ToUint8Array(base64CompressedString);
            // MODIFICATION: Using the global pako object
            const jsonString = pako.inflate(compressedData, { to: 'string' });
            const p = JSON.parse(jsonString);
            return { 
                amount: p.a, 
                serial: p.s, 
                timestamp: p.t, 
                ephemeralPublicKey: Utils.base64ToUint8Array(p.epk), 
                signatureOne: Utils.base64ToUint8Array(p.s1), 
                signatureTwo: Utils.base64ToUint8Array(p.s2) 
            };
        };

        async function decodeAllQrCodesFromImage(processedDataUrl, banknoteImage) {
            const mainCanvas = document.createElement('canvas');
            mainCanvas.width = banknoteImage.width;
            mainCanvas.height = banknoteImage.height;
            const mainCtx = mainCanvas.getContext('2d');
            mainCtx.drawImage(banknoteImage, 0, 0);

            const layout = BanknoteDrawer.getLayout(mainCanvas.width, mainCanvas.height);
            const scanResults = [];
            for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
                Utils.updateStatus(DOMElements.validationResult, `⏳ Scanning Exact Location ${i + 1} of ${Constants.NUM_QR_CODES}...`, 'info');
                const row = Math.floor(i / 3);
                const col = i % 3;
                const regionX = col * (layout.qrSize + layout.xSpacing);
                const regionY = row * (layout.qrSize + layout.ySpacing);
                const regionSize = layout.qrSize;
                
                const imageData = mainCtx.getImageData(regionX, regionY, regionSize, regionSize);
                // MODIFICATION: Using the global jsQR function
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                const result = { x: regionX, y: regionY, size: regionSize, data: null, success: false };
                if (code && code.data) {
                    result.data = code.data;
                    result.success = true;
                } else {
                     console.warn(`Could not decode QR in zone ${i + 1}.`);
                }
                scanResults.push(result);
            }
            
            if (scanResults.every(r => !r.success)) {
                 throw new Error("Validation Failed. No QR codes found at exact locations. Tip: Use a flat, well-lit photo.");
            }
            return scanResults;
        }

        return {
            handleFileSelectForValidation: async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                if (!state.masterPublicKey) { 
                    Utils.updateStatus(DOMElements.validationResult, '❌ Load a Master Public Key in Step 1 before validating.', 'error'); 
                    return;
                }
                
                const resultDiv = DOMElements.validationResult;
                const noteCanvas = DOMElements.noteCanvas;
                const noteCtx = noteCanvas.getContext('2d');
                Utils.updateStatus(resultDiv, '⏳ Preparing image for validation...', 'info');
                
                try {
                    const resizedDataUrl = await Utils.resizeImage(file, Constants.MAX_IMAGE_DIMENSION);
                    const processedDataUrl = await Utils.preprocessImage(resizedDataUrl);
                    
                    const banknoteImage = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject('Could not load banknote image');
                        img.src = processedDataUrl;
                    });
                    
                    noteCanvas.width = banknoteImage.width;
                    noteCanvas.height = banknoteImage.height;
                    noteCtx.drawImage(banknoteImage, 0, 0);

                    const scanResults = await decodeAllQrCodesFromImage(processedDataUrl, banknoteImage);
                    scanResults.forEach(result => {
                        if (result.success) {
                            noteCtx.font = `bold ${result.size * 0.8}px sans-serif`;
                            noteCtx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                            noteCtx.textAlign = 'center';
                            noteCtx.textBaseline = 'middle';
                            noteCtx.fillText('✔', result.x + result.size / 2, result.y + result.size / 2);
                        } else {
                            noteCtx.font = `bold ${result.size * 0.8}px sans-serif`;
                            noteCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                            noteCtx.textAlign = 'center';
                            noteCtx.textBaseline = 'middle';
                            noteCtx.fillText('✖', result.x + result.size / 2, result.y + result.size / 2);
                        }
                    });
                    
                    const decodedCodes = scanResults.filter(r => r.success);
                    let resultHTML = `<span class="info">Found ${decodedCodes.length}/${Constants.NUM_QR_CODES} QR code(s). Assembling payload...</span>\n`;
                    resultDiv.innerHTML = resultHTML;
                    
                    let expectedTotalParts = Constants.NUM_QR_CODES;
                    const receivedParts = {};
                    let uniqueCodes = 0;
                    for (const code of decodedCodes) {
                        if (code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                            const payload = code.data.substring(Constants.VALIDATION_PREFIX.length);
                            const match = payload.match(/^(\d+)\/(\d+):(.*)$/s);
                            if (match) {
                                const partNum = parseInt(match[1], 10);
                                if (!receivedParts[partNum]) {
                                    receivedParts[partNum] = match[3];
                                    uniqueCodes++;
                                }
                            }
                        }
                    }
                    
                    if (uniqueCodes < expectedTotalParts) {
                        Utils.updateStatus(resultDiv, `❌ Incomplete banknote data. Found ${uniqueCodes}/${expectedTotalParts} required QR codes. The banknote may be damaged or fake.`, 'error');
                        return;
                    }

                    let fullPayloadString = '';
                    for (let i = 1; i <= expectedTotalParts; i++) {
                        fullPayloadString += receivedParts[i];
                    }

                    resultHTML += `<span class="valid">✅ Found all ${expectedTotalParts} parts. Reconstructing payload...</span>\n`;
                    resultDiv.innerHTML = resultHTML;
                    
                    const parsedData = parseUnifiedVerificationPayload(fullPayloadString);
                    
                    resultHTML += `<span class="info">ℹ️ Verifying Ephemeral Signature (Sig 1)...</span>\n`;
                    resultDiv.innerHTML = resultHTML;
                    const dataForSigOne = getStandardizedDataForSigning(parsedData);
                    const isSigOneValid = await BankCrypto.verifySignature(parsedData.signatureOne, dataForSigOne, parsedData.ephemeralPublicKey);
                    if (!isSigOneValid) { 
                        resultHTML += '<span class="invalid">❌ Ephemeral Signature (Sig 1) INVALID.</span>\n<hr><span>❌ VERDICT: FORGERY</span>'; 
                        resultDiv.innerHTML = resultHTML; 
                        return;
                    }
                    
                    resultHTML += '<span class="valid">✅ Ephemeral Signature (Sig 1) OK.</span>\n';
                    resultHTML += `<span class="info">ℹ️ Verifying Master Signature (Sig 2)...</span>\n`;
                    resultDiv.innerHTML = resultHTML;
                    const dataForSigTwo = getStandardizedDataForMasterSig(parsedData);
                    const isSigTwoValid = await BankCrypto.verifySignature(parsedData.signatureTwo, dataForSigTwo, state.masterPublicKey);
                    
                    if (!isSigTwoValid) { 
                        resultHTML += '<span class="invalid">❌ Master Signature (Sig 2) INVALID.</span>\n<hr><span>❌ VERDICT: FORGERY (Not issued by this Guardian)</span>';
                        resultDiv.innerHTML = resultHTML; 
                        return; 
                    }
                    
                    resultHTML += '<span class="valid">✅ Master Signature (Sig 2) OK.</span>\n<hr><span style="font-size:14px;font-weight:600;">✅ VERDICT: BANKNOTE IS AUTHENTIC</span>';
                    resultDiv.innerHTML = resultHTML;
                } catch (e) {
                    if (e.message.includes("incorrect header check") || e.message.includes("invalid block type")) {
                         Utils.updateStatus(resultDiv, `❌ Validation Error: Decompression failed. The QR code data is corrupt or invalid.`, 'error');
                    } else {
                         Utils.updateStatus(resultDiv, `❌ Validation Error: ${e.message}`, 'error');
                    }
                    console.error(e);
                } finally {
                    event.target.value = '';
                }
            }
        };
    })();

    // --- BANKNOTE DRAWER ---
    const BanknoteDrawer = (() => {
        return {
            getLayout: (width, height) => {
                const qrSize = 250;
                const xSpacing = 20;
                const ySpacing = 20;
                const totalGridWidth = (qrSize * 3) + (xSpacing * 2);
                const totalGridHeight = (qrSize * 3) + (ySpacing * 2);
                return { qrSize, xSpacing, ySpacing, totalGridWidth, totalGridHeight };
            }
        };
    })();

    // --- APPLICATION INITIALIZATION ---
    async function main() {
        Utils.updateStatus(DOMElements.keyGenStatus, '⏳ Loading Falcon-1024 Module...', 'info');
        try {
            // MODIFICATION: Using the global pqcSignFalcon1024 function
            state.falconApi = await pqcSignFalcon1024();
            Utils.updateStatus(DOMElements.keyGenStatus, '✅ Module loaded. Please import the public key to begin.', 'success');
            Utils.log("Cryptographic module initialized successfully.", 'success');
        } catch (e) {
            Utils.log(`Critical Error: Could not load required modules: ${e.message}`, 'error');
            Utils.updateStatus(DOMElements.keyGenStatus, `❌ Critical Error: Could not load modules. See console for details.`, 'error');
            alert("Error: Failed to load a required cryptographic module. The application cannot run.");
            return;
        }
        
        DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
        DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
        
        const canvas = DOMElements.noteCanvas;
        const ctx = canvas.getContext('2d');
        const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bgGradient.addColorStop(0, `hsl(250, 50%, 6%)`);
        bgGradient.addColorStop(1, `hsl(260, 40%, 4%)`);
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold 30px 'Poppins'`;
        ctx.textAlign = 'center';
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fillText("Validated banknote image will appear here", canvas.width/2, canvas.height/2);
    }

    main();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root {
            --primary-color: #333333;
            --secondary-color: #000000;
            --danger-color: #d9534f;
            --light-gray: #f5f5f5;
            --dark-gray: #555555;
            --success-color: #1e8e3e;
            --text-light: #ffffff;
            --text-dark: #212529;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; color: var(--text-dark); }
        .view { display: none; }
        .view.active { display: block; }
        .card { background-color: var(--card-bg); padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--secondary-color); }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; background-color: #fff; color: #000; }
        textarea { resize: vertical; height: 80px; }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: var(--text-light); border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0); }
        .back-button { background: var(--dark-gray); margin-top: 10px; }
        .logout-button { background: var(--danger-color); margin-top: 10px; }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px; word-wrap: break-word; }
        .error { color: var(--danger-color); }
        .success { color: var(--success-color); }
        .info { color: #007bff; }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px; margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px; }
        #my-qr-code img, #qr-display-box img, #static-qr-code img { margin: 15px auto; display: block; border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block; margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; }
        label.qr-upload-label:hover { background-color: #f9f9f9; }
        input[type="file"] { display: none; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; margin: 10px auto; }
        .loader.hidden { display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Transaction History Styles */
        .transaction-history { margin-top: 25px; text-align: left; }
        .transaction-history h3 { text-align: center; margin-bottom: 15px; color: var(--secondary-color); }
        .transaction-list { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; }
        .transaction-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); }
        .transaction-item:last-child { border-bottom: none; }
        .transaction-details { display: flex; flex-direction: column; }
        .transaction-type { font-weight: bold; font-size: 16px; }
        .transaction-type.sent { color: var(--danger-color); }
        .transaction-type.received { color: var(--success-color); }
        .transaction-date { font-size: 12px; color: #888; }
        .transaction-amount { font-weight: bold; font-size: 16px; }
        .transaction-amount.sent { color: var(--danger-color); }
        .transaction-amount.received { color: var(--success-color); }
        .no-transactions { text-align: center; color: #999; padding: 20px; }
         /* Timer Style */
        #payment-timer { font-size: 18px; font-weight: bold; color: var(--danger-color); margin-top: 15px; }
        .address-display-box { background: #f0f2f5; padding: 10px; border-radius: 6px; margin-bottom: 15px; display: flex; align-items: center; justify-content: center; }
        .address-text { font-family: monospace; font-size: 14px; margin-right: 10px; }
        .copy-button { padding: 5px 10px; font-size: 12px; width: auto; background: var(--dark-gray); min-width: 60px; }
        #confirm-amount-display { line-height: 1.5; }
        
        /* Styles for Transaction Detail Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            width: 400px; max-width: 90%; text-align: left; padding: 25px;
        }
        .modal-content h2 { text-align: center; margin-bottom: 20px; }
        .modal-content p { margin-bottom: 12px; font-size: 14px; }
        .modal-content p strong { color: var(--primary-color); }
    </style>
</head>
<body>

    <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
    
    <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><div class="loader hidden" id="create-loader"></div><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>

    <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>

    <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><div class="loader hidden" id="restore-loader"></div><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-button" id="back-from-restore">Back</button></div></div>
    
    <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><div class="loader hidden" id="login-loader"></div><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>
    
    <div id="wallet-view" class="view"><div class="card">
        <h2>Your Wallet</h2>
        <div class="address-display-box">
             <span id="address-display" class="address-text"></span>
             <button id="copy-address-button" class="copy-button">Copy</button>
        </div>
        <p>Balance:</p>
        <h1 id="balance-display">$0.00</h1>
        <div id="sync-status" class="status-box" style="font-size: 14px;"></div>
        <p id="network-status" style="font-size: 12px; color: var(--success-color);">Ledger: Pinata IPFS</p>
        <button id="show-charge-view-button">Charge with Banknote</button>
        <button id="show-send-view-button" style="margin-top:10px;">Send (Aura)</button>
        <button id="show-receive-view-button" style="margin-top:10px;">Receive (Aura)</button>
        <div class="transaction-history">
            <h3>Recent Transactions</h3>
            <ul id="transaction-list-ul" class="transaction-list"></ul>
        </div>
        <button id="logout-button" class="logout-button">Logout (Lock Wallet)</button>
    </div></div>
    
    <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Bank Public Key</h3><p>The bank's public key is pre-loaded for verification.</p><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" style="display:none; margin-top: 20px;"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back</button></div></div>
    
    <div id="receive-view" class="view"><div class="card">
        <h2>Receive Funds</h2>
        <p>Share your address to receive funds.</p>
        <div id="static-qr-code"></div>
        <p style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;" id="full-receive-address"></p>
        <hr style="margin: 20px 0;">
        <p>Or request a specific amount:</p>
        <input type="number" id="request-amount-input" placeholder="Amount to receive">
        <button id="create-request-qr-button">Generate Payment Request QR</button>
        <div id="receive-status" class="status-box"></div>
        <button class="back-button" id="back-from-receive">Back</button>
    </div></div>
    
    <div id="send-view" class="view"><div class="card">
        <h2>Send Funds</h2>
        
        <p>Enter recipient address and amount.</p>
        <div>
            <input type="text" id="send-address-input" placeholder="Recipient's Aura Address" style="margin-bottom: 10px;">
            <input type="number" id="send-amount-input" placeholder="Amount to send" style="margin-bottom: 10px;">
            <button id="send-manual-button">Continue</button>
        </div>

        <p style="text-align:center; margin: 20px 0; font-weight: bold;">- OR -</p>

        <p>Scan a recipient's payment request QR code.</p>
        <div id="video-container" style="position: relative; width: 100%; max-width: 300px; margin: 15px auto; border-radius: 8px; overflow: hidden; border: 2px solid #333; background: #000;">
            <video id="qr-video" playsinline style="width: 100%; height: auto; display: block;"></video>
            <div id="loading-message" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; align-items: center; justify-content: center;">Requesting camera access...</div>
        </div>
        <canvas id="qr-canvas" style="display: none;"></canvas> 
        <div id="send-status" class="status-box"></div>
        <button class="back-button" id="back-from-send">Back</button>
    </div></div>
    
    <div id="send-confirm-view" class="view"><div class="card">
        <h2>Confirm Payment</h2>
        <p>You are about to send:</p>
        <h2 id="confirm-amount-display" style="color: var(--primary-color);"></h2>
        <p>To:</p>
        <p id="confirm-recipient-address-display" style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;"></p>
        <button id="confirm-payment-button">Confirm and Pay</button>
        <div id="send-confirm-status" class="status-box"></div>
        <button class="back-button" id="back-from-send-confirm">Cancel</button>
    </div></div>
    
    <div id="qr-display-view" class="view"><div class="card">
        <h2 id="qr-display-title"></h2>
        <p id="qr-display-instruction"></p>
        <div id="qr-display-box"></div>
        <div id="waiting-on-payment" style="display: none;">
            <div id="payment-timer"></div>
            <div class="loader"></div>
            <p id="final-status-message" class="status-box" style="font-size:18px;"></p>
        </div>
        <button class="back-button" id="back-from-qr-display">Back to Wallet</button>
    </div></div>

    <div id="transaction-detail-modal" class="modal-overlay" style="display:none;">
        <div class="modal-content card">
            <h2>Transaction Details</h2>
            <div id="modal-details-content">
                <p><strong>Status:</strong> <span id="detail-status"></span></p>
                <p><strong>Type:</strong> <span id="detail-type"></span></p>
                <p><strong>Date & Time:</strong> <span id="detail-datetime"></span></p>
                <p><strong>Amount:</strong> <span id="detail-amount"></span></p>
                <p><strong>Fee:</strong> <span id="detail-fee"></span></p>
                <p style="word-wrap: break-word;"><strong>From:</strong> <span id="detail-from"></span></p>
                <p style="word-wrap: break-word;"><strong>To:</strong> <span id="detail-to"></span></p>
                <p style="word-wrap: break-word;"><strong>Transaction Hash:</strong> <span id="detail-hash"></span></p>
            </div>
            <button id="download-tx-button">Download as JPG</button>
            <button id="close-modal-button" class="back-button">Close</button>
        </div>
    </div>
    
    <script src="pako.min.js"></script>
    <script src="qrcode.js"></script>
    <script src="jsQR.js"></script>
    <script src="crypto-js.min.js"></script>
    <script src="html2canvas.min.js"></script>
    
    <script type="module">
        import { ethers } from "./ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
        
        // CORE BANKNOTE & PINATA LEDGER LOGIC
        const CoreLogic = (() => { const Constants = { VALIDATION_PREFIX: "SADAT_V2_PART", MAX_IMAGE_DIMENSION: 2000, NUM_QR_CODES: 9 }; const Utils = { arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))), base64ToUint8Array: (s) => { const bs=atob(s); const b=new Uint8Array(bs.length); for(let i=0;i<bs.length;i++)b[i]=bs.charCodeAt(i); return b; }, hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))), preprocessImage: (d) => new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas'); c.width=i.width; c.height=i.height; const x=c.getContext('2d'); x.filter='grayscale(1) contrast(2.5) brightness(1.1)'; x.drawImage(i,0,0); res(c.toDataURL('image/jpeg')); }; i.onerror=rej; i.src=d; }), resizeImage: (f, m) => new Promise((res, rej) => { const r=new FileReader();r.onload=e=>{const i=new Image();i.onload=()=>{const c=document.createElement('canvas');let{width:w,height:h}=i;if(w>h){if(w>m){h*=m/w;w=m;}}else{if(h>m){w*=m/h;h=m;}}c.width=w;c.height=h;c.getContext('2d').drawImage(i,0,0,w,h);res(c.toDataURL('image/jpeg'));};i.onerror=rej;i.src=e.target.result;};r.onerror=rej;r.readAsDataURL(f);}), }; const Crypto = { hashMessageForSigning: (m) => Utils.hexToUint8Array(shake256(m, 1536)), async verifySignature(sig, data, pk, api) { const h=this.hashMessageForSigning(data); return api.verify(sig, h, pk); } }; const Banknote = { getStandardizedDataForSigning: (d) => JSON.stringify({timestamp:d.timestamp,serial:d.serial},['timestamp','serial']), getStandardizedDataForMasterSig: (d) => { const t={ephemeralPublicKey:Utils.arrayBufferToBase64(d.ephemeralPublicKey),signatureOne:Utils.arrayBufferToBase64(d.signatureOne)}; return JSON.stringify(t, Object.keys(t).sort()); }, parsePayload: (b64) => { const c=Utils.base64ToUint8Array(b64); const j=pako.inflate(c,{to:'string'}); const p=JSON.parse(j); return {amount:p.a,serial:p.s,timestamp:p.t,ephemeralPublicKey:Utils.base64ToUint8Array(p.epk),signatureOne:Utils.base64ToUint8Array(p.s1),signatureTwo:Utils.base64ToUint8Array(p.s2)}; }, getLayout: (w) => { const s=790; const c=w/s; return {qrSize:Math.round(250*c),xSpacing:Math.round(20*c),ySpacing:Math.round(20*c)}; }, decodeQrGrid: async (imgData, statusEl) => { const l=Banknote.getLayout(imgData.width); const parts={}; let count=0; const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=imgData.width;c.height=imgData.height;x.putImageData(imgData,0,0); for(let i=0;i<Constants.NUM_QR_CODES;i++){ statusEl.innerHTML=`<span class="info">Scanning section ${i+1}/${Constants.NUM_QR_CODES}...</span>`; await new Promise(r=>setTimeout(r,5)); const row=Math.floor(i/3),col=i%3,rX=col*(l.qrSize+l.xSpacing),rY=row*(l.qrSize+l.ySpacing),d=x.getImageData(rX,rY,l.qrSize,l.qrSize); const code=jsQR(d.data,d.width,d.height); if(code&&code.data.startsWith(Constants.VALIDATION_PREFIX)){const m=code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s); if(m){const pN=parseInt(m[1],10);if(!parts[pN]){parts[pN]=m[3];count++;}}} } if(count<Constants.NUM_QR_CODES){throw new Error(`Scan failed. Found ${count}/${Constants.NUM_QR_CODES} sections.`);} let payload=''; for(let i=1;i<=Constants.NUM_QR_CODES;i++){payload+=parts[i];} return payload; } }; return { Constants, Utils, Crypto, Banknote }; })();
        const PinataLedger = (() => {
            const PINATA_JWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJiZTkzZDRkMC0yYjgzLTQwZDMtYjg5Mi1iMGJiZGVkMTdiZDYiLCJlbWFpbCI6ImExbTNpNXIuYWZnQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiI0Y2UzOTU0ZjIxZGRhYTdlMmM1NiIsInNjb3BlZEtleVNlY3JldCI6ImU3YTA3NmZjZTJjN2Q0NzM0OWY0MTFjYmE5ODE5YmZiNzVjYTY2MzZmYTVhMDdiNDk2MTJmYWU3MjlhZmQxNmIiLCJleHAiOjE3ODcxMzI1NTh9.dV4M4P4LaqxiZ91ye3F4n5oP98sIqGQVA2waPrGDFJc';
            const apiCall = async (endpoint, options) => { const response = await fetch(`https://api.pinata.cloud/${endpoint}`, options); if (!response.ok) throw new Error(`Pinata API error! Status: ${response.status}`); return response.json(); };
            const recordSpentIdentifier = async (identifier, type) => { const dataToPin = { pinataContent: { identifier: identifier, type: type, status: "spent", timestamp: new Date().toISOString() }, pinataMetadata: { name: `${type}-${identifier}.json`, keyvalues: { identifier: identifier } } }; try { await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) }); return true; } catch (error) { console.error('Failed to record identifier to Pinata:', error); alert(`Critical Error: Could not write to the public ledger. Transaction cannot be safely completed. Reason: ${error.message}`); return false; } };
            const hasBeenSpent = async (identifier) => { try { const result = await apiCall(`data/pinList?metadata[keyvalues]={"identifier":{"value":"${identifier}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); return result.count > 0; } catch (error) { console.error('Failed to check identifier status on Pinata:', error); alert(`Critical Error: Could not read from the public ledger. Cannot verify transaction safety. Reason: ${error.message}`); return true; } };
            const pinConfirmation = async (confirmation) => {
                const metadata = { name: `confirmation-${confirmation.linkedTxHash}.json`, keyvalues: { type: 'confirmation', txHash: confirmation.linkedTxHash } };
                if (confirmation.receiverAddress) { metadata.keyvalues.receiverAddress = confirmation.receiverAddress; }
                if (confirmation.senderAddress) { metadata.keyvalues.senderAddress = confirmation.senderAddress; } // *** NEW: Add senderAddress for outgoing lookups
                const dataToPin = { pinataContent: confirmation, pinataMetadata: metadata };
                await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) });
            };
            const findConfirmation = async (txHash) => { const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"txHash":{"value":"${txHash}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); if (result.count > 0) { const hash = result.rows[0].ipfs_pin_hash; const contentResponse = await fetch(`https://gateway.pinata.cloud/ipfs/${hash}`); return contentResponse.json(); } return null; };
            // *** NEW: Renamed for clarity
            const findIncomingTxs = async (receiverAddress) => {
                const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"receiverAddress":{"value":"${receiverAddress}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } });
                if (result.count === 0) return [];
                return Promise.all(result.rows.map(async (row) => (await fetch(`https://gateway.pinata.cloud/ipfs/${row.ipfs_pin_hash}`)).json()));
            };
            // *** NEW: Function to find all outgoing transactions for an address
            const findOutgoingTxs = async (senderAddress) => {
                const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"senderAddress":{"value":"${senderAddress}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } });
                if (result.count === 0) return [];
                return Promise.all(result.rows.map(async (row) => (await fetch(`https://gateway.pinata.cloud/ipfs/${row.ipfs_pin_hash}`)).json()));
            };

            return { recordSpentIdentifier, hasBeenSpent, pinConfirmation, findConfirmation, findIncomingTxs, findOutgoingTxs };
        })();
        
        // ===================================================================================
        // AURA PROTOCOL - DECENTRALIZED WALLET APPLICATION
        // ===================================================================================
        const AppConstants = { MAX_LOGIN_ATTEMPTS: 5, LOGIN_LOCKOUT_PERIOD: 30000, POLLING_INTERVAL: 5000, PAYMENT_REQUEST_EXPIRY: 9 * 60 * 1000, TREASURY_ADDRESS: '0xF848aC6b7E16CF32A972ECE1529c73313375c6d5', FEE_PERCENTAGE: 0.009, PRECISION: 8 };
        let state = { wallet: null, masterPublicKey: null, userStore: null, falconApi: null, failedLoginAttempts: 0, isLockedOut: false, activePaymentRequest: null, activeManualSend: null, activePollingTimer: null, cameraStream: null, isScannerActive: false, currentBalance: 0 };
        const WalletLogic = {
            createWallet: (password) => { const wallet = ethers.Wallet.createRandom(); const mnemonic = wallet.mnemonic.phrase; const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return { mnemonic }; },
            restoreWallet: async (mnemonic, password) => { try { const wallet = ethers.Wallet.fromPhrase(mnemonic); const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return true; } catch (e) { console.error("Restore failed:", e); return false; } },
            login: async (password) => { const userStoreJson = localStorage.getItem('aura_user_store'); if (!userStoreJson) return null; try { const reloadedUserStore = JSON.parse(userStoreJson); const wallet = await ethers.Wallet.fromEncryptedJson(reloadedUserStore.encryptedJson, password); state.userStore = reloadedUserStore; state.wallet = wallet; state.failedLoginAttempts = 0; return true; } catch (e) { console.error("Login failed (likely incorrect password):", e); state.failedLoginAttempts++; return false; } },
            logout: () => { state.wallet = null; state.userStore = null; },
            getLastTransaction: () => state.userStore.chain[state.userStore.chain.length - 1],
            addToChain: (txData) => {
                const prevTx = WalletLogic.getLastTransaction();
                const newTx = { ...txData, prevHash: prevTx.hash, timestamp: Date.now() }; 
                const amountInt = ethers.parseUnits((newTx.amount || 0).toFixed(AppConstants.PRECISION), AppConstants.PRECISION);
                const feeInt = ethers.parseUnits((newTx.fee || 0).toFixed(AppConstants.PRECISION), AppConstants.PRECISION);
                newTx.hash = ethers.solidityPackedKeccak256( ['string', 'uint256', 'uint256', 'string', 'string', 'string'], [newTx.type, amountInt, feeInt, newTx.from || '', newTx.to || '', newTx.prevHash] );
                state.userStore.chain.push(newTx); 
                localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); 
                return newTx; 
            },
            // *** MODIFIED: This function is now the authoritative source for the balance, acting as the "server" calculation.
            getServerAuthoritativeBalance: async () => {
                if (!state.userStore) return 0.0;
                
                // 1. Get all banknote charges from the local chain (these are validated against Pinata at time of charge)
                const chargeTotal = state.userStore.chain
                    .filter(tx => tx.type === 'charge' && tx.status === 'completed')
                    .reduce((sum, tx) => sum + (tx.amount || 0), 0);

                // 2. Get all *incoming* transactions from the public ledger
                const incomingTxs = await PinataLedger.findIncomingTxs(state.wallet.address);
                const incomingTotal = incomingTxs.reduce((sum, tx) => sum + (Number(tx.amount) || 0), 0);

                // 3. Get all *outgoing* transactions from the public ledger
                const outgoingTxs = await PinataLedger.findOutgoingTxs(state.wallet.address);
                const outgoingTotal = outgoingTxs.reduce((sum, tx) => {
                    const amount = Number(tx.amount) || 0;
                    const fee = amount * AppConstants.FEE_PERCENTAGE;
                    return sum + amount + fee;
                }, 0);
                
                const finalBalance = chargeTotal + incomingTotal - outgoingTotal;
                state.currentBalance = finalBalance; // Cache the latest authoritative balance
                return finalBalance;
            },
            getStandardizedConfirmationMessage: (confirmation) => {
                const amount = Number(confirmation.amount).toFixed(AppConstants.PRECISION);
                return [confirmation.type, confirmation.senderAddress, confirmation.receiverAddress, amount, confirmation.linkedTxHash].join('|');
            },
            createPaymentRequest: (amount) => { const receiveTx = WalletLogic.addToChain({ type: 'receive', amount: amount, from: '', to: state.wallet.address, status: 'pending_request' }); return { type: 'AURA_PAYMENT_REQUEST', receiverAddress: state.wallet.address, amount: amount, linkedTxHash: receiveTx.hash, expiresAt: Date.now() + AppConstants.PAYMENT_REQUEST_EXPIRY }; },
            processPayment: async (request) => { 
                const fee = request.amount * AppConstants.FEE_PERCENTAGE;
                const totalDebit = request.amount + fee;
                if (Date.now() > request.expiresAt) throw new Error("Payment request has expired.");
                if (state.currentBalance < totalDebit) throw new Error(`Insufficient funds. You need $${totalDebit.toFixed(2)}.`);
                if (await PinataLedger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been processed.");
                const sendTx = WalletLogic.addToChain({ type: 'send', amount: request.amount, fee: fee, from: state.wallet.address, to: request.receiverAddress, status: 'completed', linkedTxHash: request.linkedTxHash });
                const success = await PinataLedger.recordSpentIdentifier(request.linkedTxHash, 'transaction'); 
                if (!success) {
                    // *** NEW: If ledger write fails, revert the local transaction to prevent balance inconsistency.
                    state.userStore.chain.pop(); 
                    localStorage.setItem('aura_user_store', JSON.stringify(state.userStore));
                    throw new Error("CRITICAL: Payment sent but failed to update public ledger.");
                }
                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: request.receiverAddress, amount: request.amount, linkedTxHash: request.linkedTxHash };
                const messageToSign = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                confirmation.signature = await state.wallet.signMessage(messageToSign);
                confirmation.signedMessage = messageToSign; 
                await PinataLedger.pinConfirmation(confirmation);

                // Fee transfer to treasury - UPDATED WITH CONDITION
                if (state.wallet.address !== AppConstants.TREASURY_ADDRESS) {
                    const feeConfirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: AppConstants.TREASURY_ADDRESS, amount: fee, linkedTxHash: sendTx.hash + "-fee" };
                    const feeMessageToSign = WalletLogic.getStandardizedConfirmationMessage(feeConfirmation);
                    feeConfirmation.signature = await state.wallet.signMessage(feeMessageToSign);
                    feeConfirmation.signedMessage = feeMessageToSign;
                    await PinataLedger.pinConfirmation(feeConfirmation);
                }
                return true;
            },
            directSend: async (recipientAddress, amount) => {
                const fee = amount * AppConstants.FEE_PERCENTAGE;
                const totalDebit = amount + fee;
                if (state.currentBalance < totalDebit) throw new Error(`Insufficient funds to cover amount + fee.`);
                const sendTx = WalletLogic.addToChain({ type: 'send', amount: amount, fee: fee, from: state.wallet.address, to: recipientAddress, status: 'completed' });
                // Confirmation for the main recipient
                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: recipientAddress, amount: amount, linkedTxHash: sendTx.hash };
                const messageToSign = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                confirmation.signature = await state.wallet.signMessage(messageToSign);
                confirmation.signedMessage = messageToSign;
                await PinataLedger.pinConfirmation(confirmation);

                // Fee transfer to treasury - UPDATED WITH CONDITION
                if (state.wallet.address !== AppConstants.TREASURY_ADDRESS) {
                    const feeConfirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, receiverAddress: AppConstants.TREASURY_ADDRESS, amount: fee, linkedTxHash: sendTx.hash + "-fee" };
                    const feeMessageToSign = WalletLogic.getStandardizedConfirmationMessage(feeConfirmation);
                    feeConfirmation.signature = await state.wallet.signMessage(feeMessageToSign);
                    feeConfirmation.signedMessage = feeMessageToSign;
                    await PinataLedger.pinConfirmation(feeConfirmation);
                }
                return true;
            },
            finalizePayment: async (confirmation) => { 
                const receiveTxIndex = state.userStore.chain.findIndex(tx => tx.hash === confirmation.linkedTxHash && tx.status === 'pending_request');
                if (receiveTxIndex === -1) { console.error("Finalize Error: Could not find pending transaction."); return false; }
                if (!confirmation.signedMessage) { console.error("Finalize Error: Receipt is missing 'signedMessage'."); return false; }
                const locallyRecreatedMessage = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                if (locallyRecreatedMessage !== confirmation.signedMessage) { console.error("Tamper Detection: Confirmation data mismatch."); return false; }
                const signerAddress = ethers.verifyMessage(confirmation.signedMessage, confirmation.signature);
                if (signerAddress !== confirmation.senderAddress) { console.error("Signature verification failed!"); return false; } 
                state.userStore.chain[receiveTxIndex].status = 'completed';
                state.userStore.chain[receiveTxIndex].from = confirmation.senderAddress; 
                localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); 
                return true; 
            },
            processDiscoveredTransaction: async (confirmation) => {
                if (confirmation.receiverAddress !== state.wallet.address) { return false; }
                const alreadyExists = state.userStore.chain.some(tx => tx.linkedTxHash === confirmation.linkedTxHash || tx.hash === confirmation.linkedTxHash);
                if (alreadyExists) return false;
                if (!confirmation.signedMessage) { console.error("Discovered TX invalid: Missing 'signedMessage'"); return false; }
                const locallyRecreatedMessage = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                if (locallyRecreatedMessage !== confirmation.signedMessage) { console.error("Discovered TX failed tamper check"); return false; }
                const signerAddress = ethers.verifyMessage(confirmation.signedMessage, confirmation.signature);
                if (signerAddress !== confirmation.senderAddress) { console.error("Discovered TX failed signature validation"); return false; }
                WalletLogic.addToChain({
                    type: 'receive',
                    amount: confirmation.amount,
                    from: confirmation.senderAddress,
                    to: state.wallet.address,
                    status: 'completed',
                    linkedTxHash: confirmation.linkedTxHash
                });
                return true;
            }
        };
        // --- UI, SCANNER & EVENT LISTENERS ---
        function setLoader(loaderId, isLoading) { document.getElementById(loaderId).classList.toggle('hidden', !isLoading); }
        function resetViewInputs(viewId) { const view = document.getElementById(viewId); if (!view) return; view.querySelectorAll('input, textarea').forEach(input => { if (input.type !== 'file') input.value = ''; }); const statusBox = view.querySelector('.status-box'); if (statusBox) statusBox.innerHTML = ''; }
        // *** MODIFIED: This function now triggers the server-side balance calculation and updates the display.
        async function updateBalanceDisplay() {
            try {
                const balance = await WalletLogic.getServerAuthoritativeBalance();
                document.getElementById('balance-display').textContent = `$${balance.toFixed(2)}`;
            } catch (error) {
                console.error("Could not update balance:", error);
                document.getElementById('balance-display').textContent = 'Error';
            }
        }
        function generateQrCode(data, containerId) { const container = document.getElementById(containerId); container.innerHTML = ''; const qr = qrcode(0, 'L'); qr.addData(data); qr.make(); container.innerHTML = qr.createImgTag(6, 10); }
        function abbreviateAddress(address) { if (!address) return ''; return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`; }
        function stopScanner() { if (state.cameraStream) { state.cameraStream.getTracks().forEach(track => track.stop()); state.cameraStream = null; state.isScannerActive = false; } }
        
        async function syncWalletWithLedger() {
            const syncStatusEl = document.getElementById('sync-status');
            if (!syncStatusEl || !state.wallet) return;
            syncStatusEl.innerHTML = '<span class="info">Syncing with ledger...</span>';
            try {
                const discovered = await PinataLedger.findIncomingTxs(state.wallet.address);
                let newTxCount = 0;
                for (const confirmation of discovered) {
                    if (await WalletLogic.processDiscoveredTransaction(confirmation)) {
                        newTxCount++;
                    }
                }
                await updateBalanceDisplay(); // *** NEW: Ensure balance is updated after sync
                renderTransactionHistory(); // *** NEW: Ensure transaction list is updated

                if (newTxCount > 0) {
                    syncStatusEl.innerHTML = `<span class="success">Synced! ${newTxCount} new transaction(s) found.</span>`;
                } else {
                    syncStatusEl.innerHTML = '<span class="success">Wallet is up to date.</span>';
                }
                setTimeout(() => { if (syncStatusEl) syncStatusEl.innerHTML = ''; }, 4000);
            } catch (error) {
                console.error("Failed to sync with ledger:", error);
                syncStatusEl.innerHTML = '<span class="error">Could not sync with ledger.</span>';
            }
        }

        async function startScanner() {
            if (state.isScannerActive || !document.getElementById('send-view').classList.contains('active')) return;
            state.isScannerActive = true;
            const video = document.getElementById('qr-video'), loadingMessage = document.getElementById('loading-message'), canvasElement = document.getElementById('qr-canvas'), canvas = canvasElement.getContext('2d'), sendStatusEl = document.getElementById('send-status');
            sendStatusEl.innerHTML = ''; loadingMessage.style.display = 'flex'; loadingMessage.textContent = 'Requesting camera access...';
            try {
                state.cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                video.srcObject = state.cameraStream; video.setAttribute("playsinline", true); await video.play();
                loadingMessage.style.display = 'none';
                requestAnimationFrame(tick);
            } catch (err) { console.error("Camera Error:", err); loadingMessage.textContent = "Could not access camera."; sendStatusEl.innerHTML = `<span class="error">Camera access is required.</span>`; state.isScannerActive = false; }
            
            function tick() {
                if (!state.isScannerActive) return;
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvasElement.height = video.videoHeight;
                    canvasElement.width = video.videoWidth;
                    canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                    const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });
                    if (code) {
                        stopScanner();
                        sendStatusEl.innerHTML = '<span class="info">QR Code Detected! Processing...</span>';
                        let isPaymentRequest = false;
                        try {
                            const request = JSON.parse(code.data);
                            if (request.type === 'AURA_PAYMENT_REQUEST' && request.amount && request.receiverAddress) {
                                isPaymentRequest = true;
                                Promise.resolve().then(async () => {
                                    if (Date.now() > request.expiresAt) throw new Error("This payment request has expired.");
                                    if (await PinataLedger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been paid.");
                                    state.activePaymentRequest = request; 
                                    state.activeManualSend = null;
                                    const fee = request.amount * AppConstants.FEE_PERCENTAGE; 
                                    const total = request.amount + fee;
                                    document.getElementById('confirm-amount-display').innerHTML = `Amount: $${request.amount.toFixed(2)}<br><span style="font-size: 14px; color: #555;">Fee (${(AppConstants.FEE_PERCENTAGE*100).toFixed(1)}%): +$${fee.toFixed(2)}</span><br><strong style="font-size: 18px;">Total: $${total.toFixed(2)}</strong>`;
                                    document.getElementById('confirm-recipient-address-display').textContent = request.receiverAddress;
                                    showView('send-confirm-view');
                                }).catch(err => {
                                    sendStatusEl.innerHTML = `<span class="error">${err.message}</span>`;
                                    setTimeout(() => startScanner(), 2000);
                                });
                            }
                        } catch (e) { /* Not a JSON payment request */ }

                        if (!isPaymentRequest) {
                            if (ethers.isAddress(code.data)) {
                                document.getElementById('send-address-input').value = code.data;
                                sendStatusEl.innerHTML = '<span class="success">Recipient address scanned! Please enter the amount to send.</span>';
                                document.getElementById('send-amount-input').focus();
                            } else {
                                sendStatusEl.innerHTML = `<span class="error">Invalid QR Code. Not a valid address or payment request.</span>`;
                                setTimeout(() => startScanner(), 2000);
                            }
                        }
                        return;
                    }
                }
                requestAnimationFrame(tick);
            }
        }

        function showView(id) { 
            if (document.getElementById('send-view').classList.contains('active') && id !== 'send-view') stopScanner();
            if (state.activePollingTimer) { clearInterval(state.activePollingTimer); state.activePollingTimer = null; } 
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(id).classList.add('active'); 

            if (id === 'wallet-view') { 
                document.getElementById('balance-display').textContent = 'Loading...';
                syncWalletWithLedger(); // This will also update balance and render history
                document.getElementById('address-display').textContent = abbreviateAddress(state.wallet.address);
            }
            if (id === 'send-view') startScanner();
            if (id === 'receive-view') {
                document.getElementById('full-receive-address').textContent = state.wallet.address;
                generateQrCode(state.wallet.address, 'static-qr-code');
            }
        }

        function renderTransactionHistory() {
            const listUl = document.getElementById('transaction-list-ul');
            listUl.innerHTML = '';
            if (!state.userStore || !state.userStore.chain) return;
            const transactions = state.userStore.chain.filter(tx => (tx.type === 'send' || tx.type === 'receive' || tx.type === 'charge') && tx.status === 'completed').slice(-10).reverse();
            if (transactions.length === 0) {
                listUl.innerHTML = '<li class="no-transactions">No transactions found.</li>';
                return;
            }
            transactions.forEach(tx => {
                const item = document.createElement('li');
                item.className = 'transaction-item';
                item.style.cursor = 'pointer';
                const isSent = tx.type === 'send';
                const typeText = isSent ? 'Sent' : (tx.type === 'charge' ? 'Charge' : 'Received');
                const typeClass = isSent ? 'sent' : 'received';
                const totalAmount = isSent ? (tx.amount || 0) + (tx.fee || 0) : (tx.amount || 0);
                const date = new Date(tx.timestamp).toLocaleString('en-US');
                item.innerHTML = `<div class="transaction-details"><span class="transaction-type ${typeClass}">${typeText}</span><span class="transaction-date">${date}</span></div><span class="transaction-amount ${typeClass}">${isSent ? '-' : '+'}$${totalAmount.toFixed(2)}</span>`;
                item.addEventListener('click', () => showTransactionDetails(tx));
                listUl.appendChild(item);
            });
        }
        
        function showTransactionDetails(tx) {
            const modal = document.getElementById('transaction-detail-modal');
            document.getElementById('detail-status').textContent = tx.status || 'N/A';
            document.getElementById('detail-type').textContent = tx.type || 'N/A';
            document.getElementById('detail-datetime').textContent = new Date(tx.timestamp).toLocaleString('en-US', { dateStyle: 'long', timeStyle: 'medium' });
            document.getElementById('detail-amount').textContent = `$${(tx.amount || 0).toFixed(2)}`;
            document.getElementById('detail-fee').textContent = `$${(tx.fee || 0).toFixed(2)}`;
            document.getElementById('detail-from').textContent = tx.from || 'N/A';
            document.getElementById('detail-to').textContent = tx.to || 'N/A';
            document.getElementById('detail-hash').textContent = tx.hash || 'N/A';
            modal.style.display = 'flex';
            document.getElementById('close-modal-button').onclick = () => { modal.style.display = 'none'; };
            document.getElementById('download-tx-button').onclick = () => {
                const contentToCapture = document.getElementById('modal-details-content');
                html2canvas(contentToCapture, { scale: 2 }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `transaction_${tx.hash.substring(0, 10)}.jpg`;
                    link.href = canvas.toDataURL('image/jpeg', 0.9);
                    link.click();
                });
            };
        }

        async function initializeApp() { try { state.falconApi = await pqcSignFalcon1024(); } catch (e) { alert(`Critical error initializing cryptography module: ${e.message}`); return; } if (localStorage.getItem('aura_user_store')) { showView('login-view'); } else { showView('onboarding-view'); } setupEventListeners(); }

        function setupEventListeners() {
            document.getElementById('go-to-create-wallet').addEventListener('click', () => showView('create-wallet-view'));
            document.getElementById('go-to-restore-wallet').addEventListener('click', () => showView('restore-wallet-view'));
            document.getElementById('back-from-create').addEventListener('click', () => { resetViewInputs('create-wallet-view'); showView('onboarding-view'); });
            document.getElementById('back-from-restore').addEventListener('click', () => { resetViewInputs('restore-wallet-view'); showView('onboarding-view'); });
            document.getElementById('back-from-charge').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('back-from-receive').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('back-from-send').addEventListener('click', () => { resetViewInputs('send-view'); showView('wallet-view'); });
            document.getElementById('back-from-send-confirm').addEventListener('click', () => showView('send-view'));
            document.getElementById('back-from-qr-display').addEventListener('click', () => { showView('wallet-view'); });
            document.getElementById('create-wallet-button').addEventListener('click', async () => { const button = document.getElementById('create-wallet-button'), statusEl = document.getElementById('create-status'); const pass = document.getElementById('create-password-input').value.trim(), confirmPass = document.getElementById('confirm-password-input').value.trim(); statusEl.textContent = ''; if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } if (pass !== confirmPass) { statusEl.innerHTML = '<span class="error">Passwords do not match.</span>'; return; } button.disabled = true; setLoader('create-loader', true); setTimeout(() => { const { mnemonic } = WalletLogic.createWallet(pass); document.getElementById('seed-phrase-display').textContent = mnemonic; showView('seed-phrase-view'); button.disabled = false; setLoader('create-loader', false); }, 50); });
            document.getElementById('seed-phrase-confirm-button').addEventListener('click', async () => { showView('wallet-view'); document.getElementById('seed-phrase-display').textContent = ''; resetViewInputs('create-wallet-view'); });
            document.getElementById('restore-wallet-button').addEventListener('click', async () => { const button = document.getElementById('restore-wallet-button'), statusEl = document.getElementById('restore-status'); const mnemonic = document.getElementById('restore-seed-input').value.trim(), pass = document.getElementById('restore-password-input').value.trim(); statusEl.textContent = ''; if (mnemonic.split(' ').length !== 12) { statusEl.innerHTML = '<span class="error">Recovery phrase must be 12 words.</span>'; return; } if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } button.disabled = true; setLoader('restore-loader', true); const success = await WalletLogic.restoreWallet(mnemonic, pass); if (success) { showView('wallet-view'); } else { statusEl.innerHTML = '<span class="error">Restore failed. Invalid phrase.</span>'; } button.disabled = false; setLoader('restore-loader', false); resetViewInputs('restore-wallet-view'); });
            document.getElementById('login-button').addEventListener('click', async () => { if (state.isLockedOut) return; const button = document.getElementById('login-button'), statusEl = document.getElementById('login-status'); const pass = document.getElementById('login-password-input').value.trim(); button.disabled = true; setLoader('login-loader', true); statusEl.innerHTML = '<span class="info">Decrypting wallet...</span>'; const success = await WalletLogic.login(pass); if (success) { showView('wallet-view'); resetViewInputs('login-view'); } else { if (state.failedLoginAttempts >= AppConstants.MAX_LOGIN_ATTEMPTS) { state.isLockedOut = true; statusEl.innerHTML = `<span class="error">Too many failed attempts. Please wait 30 seconds.</span>`; setTimeout(() => { state.isLockedOut = false; state.failedLoginAttempts = 0; statusEl.textContent = ''; button.disabled = false; }, AppConstants.LOGIN_LOCKOUT_PERIOD); } else { statusEl.innerHTML = `<span class="error">Invalid password. (${AppConstants.MAX_LOGIN_ATTEMPTS - state.failedLoginAttempts} attempts remaining)</span>`; } } if (!state.isLockedOut) button.disabled = false; setLoader('login-loader', false); });
            document.getElementById('logout-button').addEventListener('click', () => { WalletLogic.logout(); showView('login-view'); });
            document.getElementById('reset-app-button').addEventListener('click', () => { if (confirm('Are you sure? All wallet data will be erased from this browser.')) { localStorage.removeItem('aura_user_store'); location.reload(); } });
            document.getElementById('copy-address-button').addEventListener('click', () => { const button = document.getElementById('copy-address-button'); navigator.clipboard.writeText(state.wallet.address).then(() => { button.textContent = 'Copied!'; setTimeout(() => { button.textContent = 'Copy'; }, 1500); }); });
            document.getElementById('show-receive-view-button').addEventListener('click', () => { resetViewInputs('receive-view'); showView('receive-view'); });
            document.getElementById('show-send-view-button').addEventListener('click', () => { resetViewInputs('send-view'); showView('send-view'); });
            document.getElementById('send-manual-button').addEventListener('click', async () => { // *** MODIFIED: Make async
                const statusEl = document.getElementById('send-status'), recipientAddress = document.getElementById('send-address-input').value.trim(), amount = parseFloat(document.getElementById('send-amount-input').value);
                statusEl.innerHTML = ''; 
                if (!ethers.isAddress(recipientAddress)) { statusEl.innerHTML = '<span class="error">Invalid recipient address.</span>'; return; }
                if (isNaN(amount) || amount <= 0) { statusEl.innerHTML = '<span class="error">Please enter a valid amount.</span>'; return; }
                const fee = amount * AppConstants.FEE_PERCENTAGE, total = amount + fee;
                // *** MODIFIED: Use the cached authoritative balance for the check
                if (state.currentBalance < total) { statusEl.innerHTML = `<span class="error">Insufficient funds.</span>`; return; }
                state.activeManualSend = { address: recipientAddress, amount: amount }; state.activePaymentRequest = null;
                document.getElementById('confirm-amount-display').innerHTML = `Amount: $${amount.toFixed(2)}<br><span style="font-size: 14px; color: #555;">Fee (${(AppConstants.FEE_PERCENTAGE*100).toFixed(1)}%): +$${fee.toFixed(2)}</span><br><strong style="font-size: 18px;">Total: $${total.toFixed(2)}</strong>`;
                document.getElementById('confirm-recipient-address-display').textContent = recipientAddress;
                showView('send-confirm-view');
            });

            document.getElementById('create-request-qr-button').addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('request-amount-input').value);
                if (isNaN(amount) || amount <= 0) { document.getElementById('receive-status').innerHTML = '<span class="error">Please enter a valid amount.</span>'; return; }
                const request = WalletLogic.createPaymentRequest(amount);
                document.getElementById('qr-display-title').textContent = 'Payment Request';
                document.getElementById('qr-display-instruction').textContent = `Show this QR to the sender to pay $${amount.toFixed(2)}.`;
                document.getElementById('qr-display-box').style.display = 'block';
                generateQrCode(JSON.stringify(request), 'qr-display-box');
                document.getElementById('waiting-on-payment').style.display = 'block';
                const statusMsg = document.getElementById('final-status-message'), timerEl = document.getElementById('payment-timer');
                statusMsg.innerHTML = '<span class="info">Waiting for sender to pay...</span>';
                document.querySelector('#waiting-on-payment .loader').style.display = 'block';
                showView('qr-display-view');
                let timeLeft = AppConstants.PAYMENT_REQUEST_EXPIRY;
                const updateTimer = () => { timeLeft -= 1000; const minutes = Math.floor(timeLeft / 60000), seconds = Math.floor((timeLeft % 60000) / 1000).toString().padStart(2, '0'); timerEl.textContent = `Expires in: ${minutes}:${seconds}`; if (timeLeft <= 0) { clearInterval(state.activePollingTimer); state.activePollingTimer = null; statusMsg.innerHTML = '<span class="error">Payment request expired.</span>'; document.querySelector('#waiting-on-payment .loader').style.display = 'none'; } };
                updateTimer();
                state.activePollingTimer = setInterval(async () => {
                    updateTimer(); 
                    if (timeLeft <= 0) return;
                    try {
                        const confirmation = await PinataLedger.findConfirmation(request.linkedTxHash);
                        if (confirmation) {
                            clearInterval(state.activePollingTimer); state.activePollingTimer = null; timerEl.style.display = 'none';
                            statusMsg.innerHTML = '<span class="info">Payment detected! Finalizing...</span>';
                            if (await WalletLogic.finalizePayment(confirmation)) {
                                statusMsg.innerHTML = `<span class="success">Success! $${Number(confirmation.amount).toFixed(2)} received.</span>`;
                                document.querySelector('#waiting-on-payment .loader').style.display = 'none';
                                setTimeout(() => { showView('wallet-view'); }, 2000);
                            } 
                        }
                    } catch (err) { console.error("Polling error:", err); statusMsg.innerHTML = `<span class="error">Network error while checking for payment.</span>`; clearInterval(state.activePollingTimer); state.activePollingTimer = null; }
                }, AppConstants.POLLING_INTERVAL);
            });
            document.getElementById('confirm-payment-button').addEventListener('click', async (event) => {
                const button = event.target, statusEl = document.getElementById('send-confirm-status');
                button.disabled = true; statusEl.innerHTML = '<span class="info">Processing payment...</span>';
                try {
                    // *** NEW: Refresh the authoritative balance right before payment to prevent race conditions
                    await WalletLogic.getServerAuthoritativeBalance();
                    
                    let success = false, message = '';
                    if (state.activePaymentRequest) {
                        await WalletLogic.processPayment(state.activePaymentRequest);
                        message = `Payment of $${state.activePaymentRequest.amount.toFixed(2)} was sent successfully!`;
                        success = true;
                    } else if (state.activeManualSend) {
                        await WalletLogic.directSend(state.activeManualSend.address, state.activeManualSend.amount);
                        message = `Payment of $${state.activeManualSend.amount.toFixed(2)} was sent successfully!`;
                        success = true;
                    } else { throw new Error("No active payment request."); }
                    if (success) {
                        alert(message);
                        state.activePaymentRequest = null; state.activeManualSend = null;
                        showView('wallet-view');
                    }
                } catch (err) { statusEl.innerHTML = `<span class="error">Payment Failed: ${err.message}</span>`;
                } finally { button.disabled = false; }
            });
            document.getElementById('show-charge-view-button').addEventListener('click', () => { 
                resetViewInputs('charge-view'); 
                document.getElementById('banknote-image-input').disabled = true; document.getElementById('charge-confirmation').style.display = 'none'; 
                const confirmBtn = document.getElementById('confirm-charge-button'); 
                confirmBtn.disabled = false; confirmBtn.removeAttribute('data-amount'); confirmBtn.removeAttribute('data-serial'); 
                const masterPublicKeyBase64 = "CpykDvKkGbiU2HC4ClbsqghN2ABEoTg8ZdT7XHwHEmGRQqUXtqr/NsqmrTD49tLgXhYNfUqHsN9Bmv2PmhJHr7J4p0enLousZWjxkBbrQ6ZdN6nCn1FIj1rIXfg4OWiI9VJErl0gSIOmhGY8mOOpUk4fQSqQ5opIDfqscYAQrhEiUgCgWTW81YRj3UOyJa6bsEJIRIy2+PII4pav3YEBJy1iHOinpiXI96INtMccbbA41VLHzs+oWL37c29exD4o5VJ/Lb0VvCSVo1bvsgZ/UmKhcU7gSgr7FWhA5Ajz0aW8OhXkZ/zAK73xEASt609ACB/bTsbHZh6xIjPtjyae1DPRxgtDWrfj/Qlph9RyOttV9GNop5oPzRZ+nL2luUeYdu3CGcdGa1ZumGO/KYyMlKV0+lEovBiz9q5WYgxRTtufZVejRYkxVIQNk8pepDfUQzssSeRDimNbqbrhsk6AkGhO82ekvVe6QYkgr1+UuZPpqUOeHwHxc8UG/E3a9OvWCp44EtkBt1D8L9JPgQ2TNpqcIxuP5aGYclY3Vc7xFl1jyvaGXZ1yisiUWSoLqSsTMQHIeGbgQcmg9LCyQDJLZ/BJKXMWAeORRYTmq+pAqkHd94VL3yE08U2wYo1XqPHGGhxT8GY1gCVdRltttfOigaBrqY0jgoxEraheS1Sxgpae7ZX2LW7tpx3v+QPn0absxANYK4ZuZaCRLIfHveAbhzgWxozATyf7B+YbVR8IPih7DIrXtIkmTVTazyrZU4S9URZJ05titcD9qmkW9IghR6HgYDFXeVtTTB3cpmINKoeAIUuUtmps0d99dvG23sAsvKzqVoSOx5LZgoWzmlI3vcAFQYa/Og3lB40pCxvFotsJyPcSOvpiJ8a9KXmqECmpe7LoMcAfF5m3vO0UkFSNpszMoV3LElBEV8fk1wVQCKv1ceKbX2yRC99IQApCnMV41nkoiNuRoCryoGnsQMLjB7FsfeG0ouEqxc8oEgzsM1KKIrLtaDvqXXSYh1C6VlWQ/xqmR1oUdWaH3JuOCnjgQgOkUouEXCDjkMlpFrGgBI5RfCNMLKtCylPJEc1OWOVw57UtrJ0wlOdh4teREE6A4MrKrxDhApvJzwUco1CtIuEOkct4U0lptO5P4ftbkaZIYWSdGwoqdhDSeZgNZ0jaRu6uqqD2Ayt8KpWCoYtKqwZssBhWGweign/uwGTqZaYgOfP3gd8nA7ngqutggleMRHVUBw8PyiqUSckRQZ1YZ/+TWrX+e6vvR8CR1QrXlOwsvPlbAqYFUn8QEpryXtxcUGG1j2dbtngIo6NuBa2ozvb8mWETtdEpQAvRe1FoA16L+1ssfYnC5OlvEhWpuxpjYVScaKyn8zpNMfunIicQ1F61EJHYf81tgSAZVQYZHjVICKs1pDcRu+xcWSZ+qDAKoCuKbwIQwVdrZZMjiKNjGUpmG4dakx6daJlipKpPMjhT105ElJ4VitYnwq0sGfa5LLQcGo8H3uPWpUoB5hyUvb4Ihkaroh98hGQl0MXeTV1RQE5vJ54aUXJTLX1Y5mwKXaYXmfAcq2hoDlF8f/DU1rqjWC4q9hYmhaQ2QXht4SG92bt6kcICOK+32sPVY+pOeSSbAUv4dfIgbOASFpGbUMSQkMI5ckUlAmYdmFRsyoqxHGclocLXptgysrJY+IGWCSMp7mIMyCMohuO8ZHJColHeRHASg4d01ks58lmlu47Mn+YPF4kLnnfuoza4aRVv/UZlcm9GPkYJNhth1zvtJ0WQoI0IaUs7LF64HnVnMNUTNHfI1JWMb3Jbcu41+EDUrvXvGZ+pFE0wB/VOriJLroYk5R/XXF4vkaZf2RAk1TAEk/pMUWzWIVE2I3rmcOmVHTJ5K4SEln1b9WorpUKSHNwgIkJiN3mqNpiNgC5P5pUTyQ2+VdTx1UJLpm6Vx+fLL8El+S+ITQQ3JkmxsWQEHGYU0oaNRomlAkIWJ261rBlxdq6j44/8qXBOwJMPQGSIGYpZV+S9VbwDHYcpI3vPg6GBhVTWIRCoEdX1VhInTYkJroBmIcQjXRAhbmv7c1IbNB/IuVu4ZmCIpFIHFKWDsstyTUGchHfLXGYxUzFPSHGvhGowR8E9JVJ59uCLJbnRm+ucoik6fmZoFYlLBSV8EBAj32o0owQ04F+KHuJwB5UosT5YWoSSGrhOJKZfCk1YxhLmTig0MsYXI6BGRIrWPosZKi0lFnmicNhSjBL1YZ5lMVvccfWTBQtuGqsBVlZfCKU0gD4u/qDl9iIGIwkhDuXLbdMWuulKiueaASWI9tdDzlVQlBXx40C6KCiqpB/V/oLwiWOvbJkAzQyIZOZbcA7IxmzHCohs67tUhYaw6slobaK4RspGt1EF5ll1b5qAnWg=";
                state.masterPublicKey = CoreLogic.Utils.base64ToUint8Array(masterPublicKeyBase64);
                document.getElementById('key-status').innerHTML = '<span class="success">Bank public key loaded.</span>';
                document.getElementById('banknote-image-input').disabled = false;
                showView('charge-view'); 
            });
            document.getElementById('confirm-charge-button').addEventListener('click', async (event) => { const button = event.target; button.disabled = true; const amount = parseFloat(button.dataset.amount), serial = button.dataset.serial; if (isNaN(amount) || !serial) { alert("An error occurred."); showView('wallet-view'); return; } const success = await PinataLedger.recordSpentIdentifier(serial, 'banknote'); if (!success) { alert("Failed to record banknote on public ledger."); showView('wallet-view'); return; } WalletLogic.addToChain({ type: 'charge', amount: amount, serial: serial, status: 'completed' }); showView('wallet-view'); alert(`$${amount.toFixed(2)} added successfully.`); });
            document.getElementById('banknote-image-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const statusEl = document.getElementById('validation-status'); const confirmSection = document.getElementById('charge-confirmation'); confirmSection.style.display = 'none'; if (!state.masterPublicKey) { statusEl.innerHTML = '<span class="error">Please load the bank\'s public key first.</span>'; return; } statusEl.innerHTML = '<span class="info">Preparing image...</span>'; try { const resizedDataUrl = await CoreLogic.Utils.resizeImage(file, CoreLogic.Constants.MAX_IMAGE_DIMENSION); const processedDataUrl = await CoreLogic.Utils.preprocessImage(resizedDataUrl); const imageData = await new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas');c.width=i.width;c.height=i.height;const x=c.getContext('2d');x.drawImage(i,0,0);res(x.getImageData(0,0,i.width,i.height));}; i.onerror=rej; i.src=processedDataUrl; }); const payload = await CoreLogic.Banknote.decodeQrGrid(imageData, statusEl); statusEl.innerHTML = '<span class="info">Scan complete. Verifying signatures...</span>'; const banknoteData = CoreLogic.Banknote.parsePayload(payload); if (await PinataLedger.hasBeenSpent(banknoteData.serial)) { throw new Error("This banknote has already been spent."); } const isSigOneValid = await CoreLogic.Crypto.verifySignature(banknoteData.signatureOne, CoreLogic.Banknote.getStandardizedDataForSigning(banknoteData), banknoteData.ephemeralPublicKey, state.falconApi); if (!isSigOneValid) throw new Error("Signature validation failed (internal)."); const isSigTwoValid = await CoreLogic.Crypto.verifySignature(banknoteData.signatureTwo, CoreLogic.Banknote.getStandardizedDataForMasterSig(banknoteData), state.masterPublicKey, state.falconApi); if (!isSigTwoValid) throw new Error("Signature validation failed (issuer)."); statusEl.innerHTML = '<span class="success">Banknote is valid!</span>'; document.getElementById('validated-amount').textContent = `$${banknoteData.amount.toFixed(2)}`; const confirmBtn = document.getElementById('confirm-charge-button'); confirmBtn.dataset.amount = banknoteData.amount; confirmBtn.dataset.serial = banknoteData.serial; confirmSection.style.display = 'block'; } catch (err) { statusEl.innerHTML = `<span class="error">Validation Failed: ${err.message}</span>`; } finally { event.target.value = ''; } });
        }
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

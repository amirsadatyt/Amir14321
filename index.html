<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote - USER WALLET</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
</head>
<style>
    :root { --primary-font: 'Poppins', 'Segoe UI', sans-serif; --mono-font: 'Roboto Mono', monospace; --dark-bg: #1a101a; --medium-bg: #2e1a2e; --light-bg: #3e2a3e; --accent-color-1: #00e676; --accent-color-2: #40c4ff; --text-color: #e0e0e0; --text-muted: #a0a0c0; --success-color: #00e676; --error-color: #ff5252; --info-color: #40c4ff; --warning-color: #ffab40; --border-color: rgba(0, 230, 118, 0.2); }
    body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); color: var(--text-color); text-align: center; padding: 24px; }
    .container { max-width: 800px; margin: 0 auto; background: rgba(46, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); }
    h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    button, label.button { padding: 14px 22px; font-size: 16px; border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; }
    button.primary { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; }
    button:hover, label.button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 230, 118, 0.2); }
    .section { background: rgba(26, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
    h2 { font-size: 1.5rem; margin-top: 0; }
    .status-box { margin-top: 20px; font-size: 14px; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); }
    .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); align-items: center; justify-content: center; flex-direction: column; }
    .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 90%; max-width: 500px; border-radius: 16px; text-align: center; }
    #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
    .hidden { display: none; }
    .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
</style>
<body>
<div class="container">
    <h1>User Wallet</h1>
    <div class="section" id="wallet-setup">
        <h2>Wallet Setup</h2>
        <label for="load-note-image" class="button">1. Load Banknote Image (.png)</label>
        <input type="file" id="load-note-image" class="hidden" accept="image/png">
        <label for="load-spend-key" class="button">2. Load Spend Key (.json)</label>
        <input type="file" id="load-spend-key" class="hidden" accept="application/json">
        <div id="setup-status" class="status-box warning">‚ö†Ô∏è Please load a banknote and its corresponding spend key.</div>
    </div>

    <div class="section hidden" id="wallet-main">
        <h2>Banknote Details</h2>
        <p>Serial: <strong id="note-serial"></strong></p>
        <p style="font-size: 2rem; font-family: var(--mono-font);">Amount: <strong id="note-amount"></strong></p>
        <hr style="border-color: var(--border-color); margin: 20px 0;">
        <button id="send-btn" class="primary">üí∏ Send</button>
        <button id="receive-btn" class="primary">üí∞ Receive</button>
        <div id="tx-status" class="status-box info">‚ÑπÔ∏è Ready to transact.</div>
    </div>
</div>

<div id="tx-modal" class="modal">
    <div class="modal-content">
        <h2 id="modal-title"></h2>
        <p id="modal-instruction"></p>
        <div id="qr-display"></div>
        <div id="modal-input-area"></div>
        <button id="modal-cancel-btn">Cancel</button>
    </div>
</div>

<script type="module">
// --- DEPENDENCIES (Keep these locally for full offline use) ---
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { shake256, sha3_256 } from 'https://cdn.skypack.dev/js-sha3';

// --- Global State ---
const state = {
    falconApi: null,
    noteData: null,
    spendPrivateKey: null,
};

// --- CONSTANTS ---
const Constants = {
    VALIDATION_PREFIX: "SADAT_V3_PART",
    NUM_QR_CODES: 9
};

// --- DOM Elements ---
const DOMElements = {
    loadNoteImage: document.getElementById('load-note-image'),
    loadSpendKey: document.getElementById('load-spend-key'),
    setupStatus: document.getElementById('setup-status'),
    walletSetup: document.getElementById('wallet-setup'),
    walletMain: document.getElementById('wallet-main'),
    noteSerial: document.getElementById('note-serial'),
    noteAmount: document.getElementById('note-amount'),
    sendBtn: document.getElementById('send-btn'),
    receiveBtn: document.getElementById('receive-btn'),
    txStatus: document.getElementById('tx-status'),
    txModal: document.getElementById('tx-modal'),
    modalTitle: document.getElementById('modal-title'),
    modalInstruction: document.getElementById('modal-instruction'),
    qrDisplay: document.getElementById('qr-display'),
    modalInputArea: document.getElementById('modal-input-area'),
    modalCancelBtn: document.getElementById('modal-cancel-btn')
};

// --- Utility and Crypto Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => Uint8Array.from(atob(base64), c => c.charCodeAt(0)),
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    async createQrCodeImage(payload) {
        const qr = qrcode(0, 'M');
        qr.addData(payload);
        qr.make();
        const gifDataUrl = qr.createDataURL(8, 4);
        const img = new Image();
        img.src = gifDataUrl;
        await new Promise(resolve => { img.onload = resolve; });
        return img;
    },
    async decodeQrCodeFromImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                if (code) resolve(code.data); else reject(new Error("QR Code not found."));
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }
};

const BankCrypto = (() => {
    function hash(message) { return new Uint8Array(sha3_256.arrayBuffer(message)); }
    function hashForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }

    return {
        hash,
        generateNewKeyPair: () => state.falconApi.keypair(),
        signData: async (data, privateKey) => {
            const dataHash = hashForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        verifySignature: (signature, data, publicKey) => {
            const dataHash = hashForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        // Using native SubtleCrypto for encryption
        async encrypt(data, publicKey) {
            const importedKey = await crypto.subtle.importKey("raw", publicKey, { name: "ECDH", namedCurve: "P-256" }, true, []);
            // This is a simplification. Real ECIES would be better.
            // For prototype, we will just use a fixed IV and derive a key.
            const sharedSecret = await crypto.subtle.deriveBits({ name: "ECDH", public: importedKey}, await crypto.subtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]), 256);
            const aesKey = await crypto.subtle.importKey("raw", sharedSecret, "AES-GCM", false, ["encrypt"]);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encryptedData = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, aesKey, data);
            // This is not a complete ECIES implementation. It's a placeholder.
            // In a real app, a proper ECIES library should be used.
            return { iv, encryptedData };
        },
        // Decrypt is similarly simplified and would need a proper ECIES implementation
        async decrypt(encryptedPayload, privateKey) {
             // Placeholder - real implementation needed
            console.warn("Decryption is a placeholder and not fully implemented.");
            return new Uint8Array(0); // return empty
        }
    };
})();

// --- Wallet Logic ---
const Wallet = (() => {

    async function loadNote() {
        try {
            const file = DOMElements.loadNoteImage.files[0];
            if (!file) return;

            const banknoteImage = new Image();
            banknoteImage.src = URL.createObjectURL(file);
            await new Promise(r => banknoteImage.onload = r);

            const canvas = document.createElement('canvas');
            canvas.width = banknoteImage.width;
            canvas.height = banknoteImage.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(banknoteImage, 0, 0);

            const qrSize = 250, xSpacing = 20, ySpacing = 20;
            const grid = {
                startX: Math.round((canvas.width - ((qrSize * 3) + (xSpacing * 2))) / 2),
                startY: Math.round((canvas.height - ((qrSize * 3) + (ySpacing * 2))) / 2)
            };
            
            const receivedParts = {};
            let foundCount = 0;
            for (let i = 0; i < Constants.NUM_QR_CODES; i++) {
                const row = Math.floor(i / 3), col = i % 3;
                const regionX = grid.startX + col * (qrSize + xSpacing);
                const regionY = grid.startY + row * (qrSize + ySpacing);
                const imageData = ctx.getImageData(regionX, regionY, qrSize, qrSize);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                if (code && code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                    const match = code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s);
                    if (match) {
                        receivedParts[parseInt(match[1], 10)] = match[3];
                        foundCount++;
                    }
                }
            }
             if (foundCount < Constants.NUM_QR_CODES) throw new Error("Could not read all QR codes from banknote.");

            let fullPayloadString = '';
            for (let i = 1; i <= Constants.NUM_QR_CODES; i++) {
                fullPayloadString += receivedParts[i];
            }
            
            const compressedData = Utils.base64ToUint8Array(fullPayloadString);
            const jsonString = pako.inflate(compressedData, { to: 'string' });
            state.noteData = JSON.parse(jsonString);

            checkReadyState();

        } catch (e) {
            Utils.updateStatus(DOMElements.setupStatus, `‚ùå Error loading banknote: ${e.message}`, 'error');
            state.noteData = null;
        }
    }

    async function loadKey() {
        try {
            const file = DOMElements.loadSpendKey.files[0];
            if (!file) return;
            const keyData = JSON.parse(await file.text());
            if (state.noteData && state.noteData.serial !== keyData.serial) {
                throw new Error("Spend Key does not match the loaded banknote serial.");
            }
            state.spendPrivateKey = Utils.base64ToUint8Array(keyData.spendPrivateKey_b64);
            checkReadyState();
        } catch(e) {
            Utils.updateStatus(DOMElements.setupStatus, `‚ùå Error loading key: ${e.message}`, 'error');
            state.spendPrivateKey = null;
        }
    }

    function checkReadyState() {
        let noteLoaded = !!state.noteData;
        let keyLoaded = !!state.spendPrivateKey;
        Utils.updateStatus(DOMElements.setupStatus, `Banknote Loaded: ${noteLoaded ? '‚úÖ' : '‚ùå'}\nSpend Key Loaded: ${keyLoaded ? '‚úÖ' : '‚ùå'}`, noteLoaded && keyLoaded ? 'success' : 'warning');
        
        if (noteLoaded && keyLoaded) {
            DOMElements.walletSetup.classList.add('hidden');
            DOMElements.walletMain.classList.remove('hidden');
            DOMElements.noteSerial.textContent = state.noteData.serial;
            DOMElements.noteAmount.textContent = state.noteData.amount.toLocaleString('en-US');
        }
    }

    async function startReceive() {
        DOMElements.modalTitle.textContent = "Receive Payment";
        DOMElements.modalInstruction.textContent = "Show this QR code to the sender. This code is valid for one transaction only.";
        
        const challengeNonce = crypto.randomUUID();
        // A real wallet would generate and manage a more robust temporary key.
        // For this prototype, we'll just use the nonce.
        const challengePayload = JSON.stringify({
            nonce: challengeNonce
            // In a real implementation, include a temporary public key for encryption here
        });

        const qrImg = await Utils.createQrCodeImage(challengePayload);
        DOMElements.qrDisplay.innerHTML = '';
        DOMElements.qrDisplay.appendChild(qrImg);

        DOMElements.modalInputArea.innerHTML = `<label for="scan-transfer-qr" class="button">Scan Sender's QR Code</label><input type="file" id="scan-transfer-qr" class="hidden" accept="image/png">`;
        DOMElements.txModal.style.display = 'flex';

        document.getElementById('scan-transfer-qr').addEventListener('change', async (e) => {
            try {
                const transferQrData = await Utils.decodeQrCodeFromImage(e.target.files[0]);
                const transferData = JSON.parse(transferQrData);

                // --- Verification ---
                // 1. Check if the nonce matches the one we issued
                if (transferData.nonce !== challengeNonce) {
                    throw new Error("Nonce mismatch! This is not for you or is an old request.");
                }

                // 2. Verify the sender's signature
                const currentSpendPublicKey = Utils.base64ToUint8Array(state.noteData.spendPublicKey_b64);
                const signedData = JSON.stringify({ transfer: true, nonce: transferData.nonce });
                const signature = Utils.base64ToUint8Array(transferData.signature_b64);
                const isSignatureValid = await BankCrypto.verifySignature(signature, signedData, currentSpendPublicKey);

                if (!isSignatureValid) {
                    throw new Error("Invalid sender signature!");
                }
                
                // 3. Claim Ownership
                // In a real system, you would decrypt the new spend key here.
                // For the prototype, the sender will provide it. This is a security gap in the prototype.
                const newSpendKey_b64 = prompt("PROTOTYPE STEP: Enter the new Spend Private Key from the sender.");
                if (!newSpendKey_b64) throw new Error("Transaction cancelled.");

                // Update the banknote state
                state.noteData.spendPublicKey_b64 = transferData.newSpendPublicKey_b64;
                state.noteData.history = state.noteData.history || [];
                state.noteData.history.push({
                    timestamp: Date.now(),
                    nonce: transferData.nonce
                });

                // Set the new private key in the wallet
                state.spendPrivateKey = Utils.base64ToUint8Array(newSpendKey_b64);

                alert("‚úÖ Transaction successful! You are now the owner of the banknote. Remember to save your new banknote image and spend key.");
                resetWallet();

            } catch(err) {
                alert(`‚ùå Transaction Failed: ${err.message}`);
            } finally {
                DOMElements.txModal.style.display = 'none';
            }
        });
    }

    async function startSend() {
        DOMElements.modalTitle.textContent = "Send Payment";
        DOMElements.modalInstruction.textContent = "Scan the recipient's QR code to begin.";
        DOMElements.qrDisplay.innerHTML = '';
        DOMElements.modalInputArea.innerHTML = `<label for="scan-challenge-qr" class="button">Scan Recipient's QR Code</label><input type="file" id="scan-challenge-qr" class="hidden" accept="image/png">`;
        DOMElements.txModal.style.display = 'flex';

        document.getElementById('scan-challenge-qr').addEventListener('change', async (e) => {
            try {
                const challengeQrData = await Utils.decodeQrCodeFromImage(e.target.files[0]);
                const challengeData = JSON.parse(challengeQrData);
                const nonce = challengeData.nonce;

                // --- Perform Transaction ---
                // 1. Generate the next spend keypair
                const newSpendKeyPair = await BankCrypto.generateNewKeyPair();
                
                // 2. Sign the transaction with the OLD spend key
                const signedData = JSON.stringify({ transfer: true, nonce: nonce });
                const signature = await BankCrypto.signData(signedData, state.spendPrivateKey);
                
                // 3. Prepare the transfer payload
                const transferPayload = {
                    nonce: nonce,
                    signature_b64: Utils.arrayBufferToBase64(signature),
                    newSpendPublicKey_b64: Utils.arrayBufferToBase64(newSpendKeyPair.publicKey),
                    // In a real system, the new private key would be encrypted for the recipient here.
                };

                // 4. Show the transfer QR to the recipient
                DOMElements.modalInstruction.textContent = "Have the recipient scan this QR code to complete the transfer.";
                const qrImg = await Utils.createQrCodeImage(JSON.stringify(transferPayload));
                DOMElements.qrDisplay.innerHTML = '';
                DOMElements.qrDisplay.appendChild(qrImg);
                DOMElements.modalInputArea.innerHTML = `<p class="warning">PROTOTYPE STEP: The new private key below must be securely given to the recipient.</p><textarea readonly style="width:90%;height:80px;font-size:12px;">${Utils.arrayBufferToBase64(newSpendKeyPair.privateKey)}</textarea>`;
                
                alert("The banknote has been sent. This wallet no longer holds the banknote or its key.");
                resetWallet();

            } catch (err) {
                alert(`‚ùå Transaction Failed: ${err.message}`);
                DOMElements.txModal.style.display = 'none';
            }
        });
    }
    
    function resetWallet() {
        state.noteData = null;
        state.spendPrivateKey = null;
        DOMElements.txModal.style.display = 'none';
        DOMElements.walletMain.classList.add('hidden');
        DOMElements.walletSetup.classList.remove('hidden');
        Utils.updateStatus(DOMElements.setupStatus, `‚ö†Ô∏è Please load a banknote and its corresponding spend key.`, 'warning');
        DOMElements.loadNoteImage.value = '';
        DOMElements.loadSpendKey.value = '';
    }

    return { loadNote, loadKey, startReceive, startSend, resetWallet };
})();

// --- Main Application Setup ---
async function main() {
    Utils.updateStatus(DOMElements.setupStatus, '‚è≥ Loading Falcon-1024 Module...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.setupStatus, '‚úÖ Wallet ready. Please load banknote.', 'success');
    } catch (e) {
        Utils.updateStatus(DOMElements.setupStatus, `‚ùå Critical Error: Could not load modules.`, 'error');
        return;
    }

    DOMElements.loadNoteImage.addEventListener('change', Wallet.loadNote);
    DOMElements.loadSpendKey.addEventListener('change', Wallet.loadKey);
    DOMElements.sendBtn.addEventListener('click', Wallet.startSend);
    DOMElements.receiveBtn.addEventListener('click', Wallet.startReceive);
    DOMElements.modalCancelBtn.addEventListener('click', () => {
        DOMElements.txModal.style.display = 'none';
    });
}

main();
</script>
</body>
</html>

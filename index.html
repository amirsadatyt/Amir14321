<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote [Fixed Professional Edition]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="jabcodeJSLib.min.js"></script>
    <script src="jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 900px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 900px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="text"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        #validation-result, #key-status { margin-top: 20px; font-size: 12px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px; }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Sadat Digital Banknote</h1>
            <p>A secure, verifiable digital currency concept using Falcon-512 Signatures and Compressed JAB Code technology.</p>
        </div>

        <canvas id="noteCanvas" width="1350" height="750"></canvas>

        <div class="section">
            <h2>Single Banknote Controls</h2>
            <div class="controls-grid">
                <span class="input-label">Amount:</span>
                <input type="number" id="amount-input" value="50000">
                <button id="create-note-button" disabled>üé® Create New Design</button>
                <button id="download-note-button" disabled>üì¶ Download Current Note</button>
            </div>
        </div>
        
        <div class="section">
            <h2>Batch Banknote Generation</h2>
            <div class="controls-grid">
                <span class="input-label">Quantity:</span>
                <input type="number" id="batch-count-input" value="5" min="1" max="100">
                <button id="batch-generate-button" disabled>‚ö° Generate & Download Batch</button>
            </div>
        </div>

        <div class="section">
            <h2>Bank Key Management</h2>
            <div class="controls-grid">
                <button id="generate-keys-button">üîë Generate New Identity & Download Keys</button>
                <label for="import-public-key" class="sub-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Import Public Key
                </label>
                <input type="file" id="import-public-key" accept=".json" style="display: none;">
                <label for="import-private-key" class="sub-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    Import Private Key
                </label>
                <input type="file" id="import-private-key" accept=".json" style="display: none;">
            </div>
            <div id="key-status">Key pair status will be displayed here.</div>
        </div>

        <div class="section" id="validator-section">
            <h2>Validate Banknote</h2>
            <label for="validator-input">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                Select Banknote Image for Validation
            </label>
            <input type="file" id="validator-input" accept="image/png" style="display: none;">
            <div id="validation-result">Validation result will be displayed here.</div>
        </div>
    </div>

    <script type="module">
        import pqcSignFalcon512 from './falcon.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
        
        const Utils = {
            arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))),
            base64ToUint8Array: (b) => { const s = atob(b); const a = new Uint8Array(s.length); for (let i = 0; i < s.length; i++) a[i] = s.charCodeAt(i); return a; },
            uint8ArrayToHex: (b) => Array.from(b).map(byte => byte.toString(16).padStart(2, '0')).join(''),
            H: (t, i, n, m) => n + (parseInt(t.substring(i, i + 2), 16) % (m - n + 1))
        };

        class UIManager {
            constructor() { this.elements = { keyStatus: document.getElementById('key-status'), validationResult: document.getElementById('validation-result'), createNoteBtn: document.getElementById('create-note-button'), batchBtn: document.getElementById('batch-generate-button'), downloadNoteBtn: document.getElementById('download-note-button'), genKeysBtn: document.getElementById('generate-keys-button') }; }
            setStatus(el, type, msg) { this.elements[el].innerHTML = `<span class="${type}">${msg}</span>`; }
            updateControlsState(isEnabled) { this.elements.createNoteBtn.disabled = !isEnabled; this.elements.batchBtn.disabled = !isEnabled; this.elements.downloadNoteBtn.disabled = !isEnabled; }
            setButtonLoading(btn, isLoading) {
                if (!isLoading) {
                    if (btn.dataset.originalHtml) btn.innerHTML = btn.dataset.originalHtml;
                    btn.disabled = false;
                } else {
                    btn.dataset.originalHtml = btn.innerHTML;
                    btn.innerHTML = `‚è≥ Working...`;
                    btn.disabled = true;
                }
            }
        }

        class CryptoManager {
            constructor() { this.falconApi = null; }
            async init() { this.falconApi = await pqcSignFalcon512(); }
            hashMessage(msg) { return Utils.hexToUint8Array(shake256(msg, 1024)); }
            getStandardizedData(d) { const o = { amount: d.amount, serial: d.serial, timestamp: d.timestamp, verificationKey: d.verificationKey }; return JSON.stringify(o, Object.keys(o).sort()); }
            async generateNewKeyPair() { return await this.falconApi.keypair(); }
            async signData(data, privKey) { const h = this.hashMessage(data); return (await this.falconApi.sign(h, privKey)).signature; }
            async verifySignature(sig, data, pubKey) { const h = this.hashMessage(data); return await this.falconApi.verify(sig, h, pubKey); }
            async encryptPrivateKey(keyBytes, pass) {
                const pb = new TextEncoder().encode(pass), s = crypto.getRandomValues(new Uint8Array(16)), i = crypto.getRandomValues(new Uint8Array(12));
                const km = await crypto.subtle.importKey("raw", pb, { name: "PBKDF2" }, false, ["deriveKey"]);
                const dk = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: s, iterations: 100000, hash: "SHA-256" }, km, { name: "AES-GCM", length: 256 }, true, ["encrypt"]);
                const e = await crypto.subtle.encrypt({ name: "AES-GCM", iv: i }, dk, new TextEncoder().encode(JSON.stringify({ keyData: Utils.arrayBufferToBase64(keyBytes) })));
                return { cipherText: Utils.arrayBufferToBase64(e), salt: Utils.arrayBufferToBase64(s), iv: Utils.arrayBufferToBase64(i) };
            }
            async decryptPrivateKey(encData, pass) {
                const pb = new TextEncoder().encode(pass), s = Utils.base64ToUint8Array(encData.salt), i = Utils.base64ToUint8Array(encData.iv), ct = Utils.base64ToUint8Array(encData.cipherText);
                const km = await crypto.subtle.importKey("raw", pb, { name: "PBKDF2" }, false, ["deriveKey"]);
                const dk = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: s, iterations: 100000, hash: "SHA-256" }, km, { name: "AES-GCM", length: 256 }, true, ["decrypt"]);
                const db = await crypto.subtle.decrypt({ name: "AES-GCM", iv: i }, dk, ct);
                return Utils.base64ToUint8Array(JSON.parse(new TextDecoder().decode(db)).keyData);
            }
        }
        
        class BanknoteApp {
            constructor() {
                this.canvas = document.getElementById("noteCanvas");
                this.ctx = this.canvas.getContext("2d");
                this.ui = new UIManager();
                this.crypto = new CryptoManager();
                this.jabcode = new JabcodeJSInterface();
                this.state = { currentNoteData: {}, activeKeys: { publicKey: null, privateKey: null } };
            }

            async init() {
                this.ui.updateControlsState(false);
                this.ui.setStatus('keyStatus', 'info', '‚è≥ Loading Falcon-512 Crypto Module...');
                this.drawInitialCanvas();
                try {
                    await this.crypto.init();
                    this.ui.setStatus('keyStatus', 'info', 'Ready. Please generate a new key pair or import existing keys to begin.');
                } catch (e) {
                    this.ui.setStatus('keyStatus', 'invalid', `‚ùå Critical Error: Could not load Falcon-512 module.`);
                    return;
                }
                this.attachEventListeners();
            }
            
            drawInitialCanvas() {
                this.ctx.fillStyle = '#10101a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.font = "bold 32px 'Poppins'";
                this.ctx.textAlign = 'center';
                this.ctx.fillText("Generate or Import a Key Pair to Begin", this.canvas.width / 2, this.canvas.height / 2);
            }

            attachEventListeners() {
                document.getElementById('generate-keys-button').addEventListener('click', () => this.handleGenerateKeysAndDownload());
                document.getElementById('create-note-button').addEventListener('click', () => this.handleCreateNewNote());
                document.getElementById('download-note-button').addEventListener('click', () => this.handleDownloadCurrentNote());
                document.getElementById('batch-generate-button').addEventListener('click', () => this.handleBatchGeneration());
                document.getElementById('import-public-key').addEventListener('change', (e) => this.handleImportKey(e, 'public'));
                document.getElementById('import-private-key').addEventListener('change', (e) => this.handleImportKey(e, 'private'));
                document.getElementById('validator-input').addEventListener('change', (e) => this.handleFileValidation(e));
            }

            async handleGenerateKeysAndDownload() {
                const button = this.ui.elements.genKeysBtn;
                this.ui.setButtonLoading(button, true);
                try {
                    const password = prompt("Create a strong password to encrypt your new private key file:");
                    if (!password) throw new Error("Key generation cancelled. Password is required.");

                    this.ui.setStatus('keyStatus', 'info', '‚è≥ Generating new identity key pair...');
                    this.state.activeKeys = await this.crypto.generateNewKeyPair();
                    
                    this.ui.setStatus('keyStatus', 'info', 'üì¶ Preparing key files for download...');
                    const publicKeyJson = JSON.stringify({ keyData: Utils.arrayBufferToBase64(this.state.activeKeys.publicKey) }, null, 2);
                    const encryptedPrivateJson = JSON.stringify(await this.crypto.encryptPrivateKey(this.state.activeKeys.privateKey, password), null, 2);

                    const zip = new JSZip();
                    zip.file('publicKey.json', publicKeyJson);
                    zip.file('privateKey_encrypted.json', encryptedPrivateJson);
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(zipBlob);
                    a.download = `SadatBank_Identity_${Date.now()}.zip`;
                    a.click();
                    URL.revokeObjectURL(a.href);

                    this.ui.updateControlsState(true);
                    await this.handleCreateNewNote();
                    this.ui.setStatus('keyStatus', 'valid', '‚úÖ New identity created and downloaded. Ready to create banknotes.');

                } catch (e) {
                    this.ui.setStatus('keyStatus', 'invalid', `‚ùå Key generation failed: ${e.message}`);
                    this.ui.updateControlsState(!!this.state.activeKeys.privateKey);
                } finally {
                    this.ui.setButtonLoading(button, false);
                }
            }
            
            async handleDownloadCurrentNote() {
                const button = this.ui.elements.downloadNoteBtn;
                this.ui.setButtonLoading(button, true);
                try {
                    if (!this.state.activeKeys.privateKey) throw new Error("No active private key.");
                    if (Object.keys(this.state.currentNoteData).length === 0) throw new Error("No banknote data available to download.");
                    const password = prompt("Enter a password to encrypt the private key for this download:");
                    if (!password) throw new Error("Download cancelled. Password is required.");
                    this.ui.setStatus('keyStatus', 'info', 'üì¶ Creating banknote package...');

                    const banknoteBlob = await new Promise(resolve => this.canvas.toBlob(resolve, 'image/png'));
                    const noteSerial = this.state.currentNoteData.serial;
                    const files = [
                        { name: `${noteSerial}_banknote.png`, data: banknoteBlob },
                        { name: `${noteSerial}_data.json`, data: JSON.stringify(this.state.currentNoteData, null, 2) },
                        { name: `${noteSerial}_public_key.json`, data: JSON.stringify({ keyData: Utils.arrayBufferToBase64(this.state.activeKeys.publicKey) }, null, 2) },
                        { name: `${noteSerial}_private_key_encrypted.json`, data: JSON.stringify(await this.crypto.encryptPrivateKey(this.state.activeKeys.privateKey, password), null, 2) }
                    ];

                    const zip = new JSZip();
                    files.forEach(file => zip.file(file.name, file.data));
                    const zipBlob = await zip.generateAsync({ type: "blob" });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(zipBlob); a.download = `${noteSerial}_package.zip`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    this.ui.setStatus('keyStatus', 'valid', `‚úÖ Banknote package downloaded as a ZIP file.`);
                } catch(e) {
                    this.ui.setStatus('keyStatus', 'invalid', `‚ùå Download failed: ${e.message}`);
                } finally {
                    this.ui.setButtonLoading(button, false);
                }
            }

            async handleBatchGeneration() {
                const button = this.ui.elements.batchBtn;
                this.ui.setButtonLoading(button, true);
                try {
                    const count = parseInt(document.getElementById('batch-count-input').value, 10);
                    if (isNaN(count) || count < 1) throw new Error("Invalid quantity specified.");
                    const password = prompt(`Enter a password to encrypt the ${count} unique private key files for this batch:`);
                    if (!password) throw new Error("Batch generation cancelled. Password is required.");

                    const zip = new JSZip();
                    const offscreenCanvas = document.createElement('canvas');
                    offscreenCanvas.width = this.canvas.width;
                    offscreenCanvas.height = this.canvas.height;
                    
                    for (let i = 0; i < count; i++) {
                        this.ui.setStatus('keyStatus', 'info', `‚è≥ Generating banknote ${i + 1} of ${count}...`);
                        
                        const keyPair = await this.crypto.generateNewKeyPair();
                        const noteData = await this.createNoteData(document.getElementById("amount-input").value, keyPair.privateKey, i);
                        await this.drawNoteOnCanvas(noteData, offscreenCanvas);
                        
                        const banknoteBlob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                        const noteSerial = noteData.serial;
                        const noteFolder = zip.folder(noteSerial);

                        noteFolder.file(`${noteSerial}_banknote.png`, banknoteBlob);
                        noteFolder.file(`${noteSerial}_data.json`, JSON.stringify(noteData, null, 2));
                        noteFolder.file(`${noteSerial}_public_key.json`, JSON.stringify({ keyData: Utils.arrayBufferToBase64(keyPair.publicKey) }, null, 2));
                        const encryptedPrivate = await this.crypto.encryptPrivateKey(keyPair.privateKey, password);
                        noteFolder.file(`${noteSerial}_private_key_encrypted.json`, JSON.stringify(encryptedPrivate, null, 2));
                    }

                    this.ui.setStatus('keyStatus', 'info', `üì¶ Compiling ZIP file...`);
                    const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE" });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(zipBlob);
                    a.download = `Banknote_Batch_${count}_${Date.now()}.zip`;
                    a.click();
                    URL.revokeObjectURL(a.href);
                    this.ui.setStatus('keyStatus', 'valid', `‚úÖ Successfully downloaded ZIP package with ${count} unique banknotes.`);
                } catch (e) {
                     this.ui.setStatus('keyStatus', 'invalid', `‚ùå Batch generation failed: ${e.message}`);
                } finally {
                    this.ui.setButtonLoading(button, false);
                }
            }
            
            async handleImportKey(event, keyType) {
                const file = event.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        if (keyType === 'public') {
                            const data = JSON.parse(e.target.result);
                            if (!data.keyData) throw new Error("Invalid public key file format.");
                            this.state.activeKeys.publicKey = Utils.base64ToUint8Array(data.keyData);
                            this.ui.setStatus('keyStatus', 'valid', '‚úÖ Public key imported. Ready for validation.');
                        } else {
                            const password = prompt("Enter password to decrypt private key:");
                            if (!password) throw new Error("Import cancelled. Password required.");
                            this.ui.setStatus('keyStatus', 'info', '‚è≥ Decrypting private key...');
                            const encryptedData = JSON.parse(e.target.result);
                            this.state.activeKeys.privateKey = await this.crypto.decryptPrivateKey(encryptedData, password);
                            this.ui.setStatus('keyStatus', 'valid', '‚úÖ Private key imported. Ready for signing.');
                            this.ui.updateControlsState(true);
                            await this.handleCreateNewNote();
                        }
                    } catch (error) { this.ui.setStatus('keyStatus', 'invalid', `‚ùå Import failed: ${error.message}`); } 
                    finally { event.target.value = ''; }
                };
                reader.readAsText(file);
            }

            async handleFileValidation(event) {
                 const file = event.target.files[0];
                 if (!file || !this.state.activeKeys.publicKey) {
                     alert("Error: A public key must be active for validation.");
                     return;
                 }
                 this.ui.setStatus('validationResult', 'info', '‚è≥ Reading banknote image...');
                 const img = new Image();
                 img.onload = async () => {
                     const tempCanvas = document.createElement('canvas');
                     tempCanvas.width = 1350; tempCanvas.height = 750;
                     tempCanvas.getContext('2d').drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                     this.ui.setStatus('validationResult', 'info', '1. Reading and decompressing JAB Code data...');
                     
                     const noteData = await this.readJabCodeFromCanvas(tempCanvas);
                     if (!noteData) { this.ui.setStatus('validationResult', 'invalid', '‚ùå FATAL ERROR: JAB Code not found or unreadable.'); return; }
                     
                     let resultHTML = `<span class="valid">‚úÖ 1. JAB Code data read successfully.</span>`;
                     resultHTML += `\n\n<span class="info">2. Verifying digital signature (Falcon-512)...</span>`;
                     this.ui.setStatus('validationResult', null, resultHTML);

                     const stringToVerify = this.crypto.getStandardizedData(noteData);
                     const signatureBytes = Utils.base64ToUint8Array(noteData.signature);
                     const isSignatureValid = await this.crypto.verifySignature(signatureBytes, stringToVerify, this.state.activeKeys.publicKey);

                     if (!isSignatureValid) { resultHTML += `\n<span class="invalid">‚ùå FATAL ERROR: Digital signature is invalid. Forgery detected.</span>`; } 
                     else { resultHTML += `\n<span class="valid">‚úÖ 2. Digital signature confirmed. Authenticity verified.</span>`; }
                     
                     resultHTML += `\n<hr style="border-color: var(--border-color); border-style: dashed; margin: 15px 0 10px;">\n<span style="font-size: 14px; font-weight: 600;">${isSignatureValid ? '‚úÖ VERDICT: Banknote is authentic.' : '‚ùå VERDICT: Forgery detected.'}</span>`;
                     this.ui.setStatus('validationResult', null, resultHTML);
                 };
                 img.src = URL.createObjectURL(file);
                 event.target.value = '';
            }

            async readJabCodeFromCanvas(canvasToCheck) {
                try {
                    const imageDataUri = canvasToCheck.toDataURL('image/png');
                    const base64Compressed = await this.jabcode.decode_message(imageDataUri);
                    const compressedData = Utils.base64ToUint8Array(base64Compressed);
                    const jsonString = pako.inflate(compressedData, { to: 'string' });
                    return JSON.parse(jsonString);
                } catch (error) { console.error("JAB Code read/decompress failed:", error); return null; }
            }
            
            async createNoteData(amount, privateKey, index = 0) {
                 if (!privateKey) throw new Error("Private key is required to create a note.");
                 const now = Date.now();
                 const noteData = {
                     amount: parseInt(amount) || 0,
                     verificationKey: "SVK-" + Math.random().toString(16).substring(2, 10).toUpperCase(),
                     serial: "SDT-" + (now + index).toString().slice(-8),
                     timestamp: now
                 };
                 const stringToSign = this.crypto.getStandardizedData(noteData);
                 const signatureBytes = await this.crypto.signData(stringToSign, privateKey);
                 noteData.signature = Utils.arrayBufferToBase64(signatureBytes);
                 noteData.visualHash = Utils.uint8ArrayToHex(this.crypto.hashMessage(noteData.signature));
                 return noteData;
            }

            async handleCreateNewNote() {
                this.ui.setStatus('keyStatus', 'info', '‚è≥ Generating new banknote design...');
                try {
                    const noteData = await this.createNoteData(document.getElementById("amount-input").value, this.state.activeKeys.privateKey);
                    this.state.currentNoteData = noteData;
                    await this.drawNoteOnCanvas(noteData, this.canvas);
                    this.ui.setStatus('keyStatus', 'valid', '‚úÖ New banknote design is ready on screen.');
                } catch (e) {
                    this.ui.setStatus('keyStatus', 'invalid', `‚ùå Failed to create banknote: ${e.message}`);
                }
            }

            async drawNoteOnCanvas(noteData, targetCanvas) {
                const ctx = targetCanvas.getContext("2d");
                const { amount, verificationKey, serial, visualHash } = noteData;
                const w = targetCanvas.width, h = targetCanvas.height, scale = w / 1350;
                ctx.clearRect(0, 0, w, h);
                const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
                const baseHue = Utils.H(visualHash, 0, 0, 360);
                bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
                bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
                ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, w, h);
                this.drawWatermark(ctx, visualHash, w, h); this.drawKochGuilloche(ctx, visualHash, w, h); this.drawNoisePattern(ctx, visualHash, w, h);
                ctx.shadowColor = "rgba(0,0,0,0.7)"; ctx.shadowBlur = 8 * scale; ctx.shadowOffsetX = 2 * scale; ctx.shadowOffsetY = 2 * scale;
                ctx.fillStyle = "#EAEAEA"; ctx.font = `bold ${80*scale}px 'Roboto Mono'`; ctx.textAlign = 'left';
                ctx.fillText(serial.substring(4), 150 * scale, 160 * scale);
                ctx.fillText(verificationKey.substring(4), 150 * scale, 280 * scale);
                ctx.font = `bold ${150*scale}px 'Roboto Mono'`; ctx.textAlign = "right";
                ctx.shadowBlur = 12 * scale; ctx.shadowOffsetX = 4 * scale; ctx.shadowOffsetY = 4 * scale;
                ctx.fillText(amount.toString(), w - (120 * scale), 190 * scale);
                ctx.shadowColor = "transparent";
                
                const jsonString = JSON.stringify(noteData);
                const compressedData = pako.deflate(jsonString);
                const base64Compressed = btoa(String.fromCharCode.apply(null, compressedData));
                const jabCodeDataUri = this.jabcode.encode_message(base64Compressed, null, 4);
                
                const jabCodeImg = new Image();
                return new Promise((resolve) => {
                    jabCodeImg.onload = () => {
                        const codeSize = 420 * scale, codeX = 800 * scale, codeY = 210 * scale;
                        ctx.fillStyle = 'white'; ctx.beginPath();
                        if (ctx.roundRect) { ctx.roundRect(codeX - (10 * scale), codeY - (10 * scale), codeSize + (20 * scale), codeSize + (20 * scale), [12 * scale]); } 
                        else { ctx.rect(codeX - (10 * scale), codeY - (10 * scale), codeSize + (20 * scale), codeSize + (20 * scale)); }
                        ctx.fill(); ctx.drawImage(jabCodeImg, codeX, codeY, codeSize, codeSize);
                        ctx.font = `${30*scale}px 'Roboto Mono'`; ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.textAlign = "center";
                        ctx.fillText("Digitally Signed by Sadat Bank Authority (Falcon-512)", w / 2, h - 60 * scale);
                        resolve();
                    };
                    jabCodeImg.src = jabCodeDataUri;
                });
            }

            drawKochGuilloche(ctx, hash, w, h) { ctx.save(); ctx.translate(w / 2, h / 2); const s = w / 1350, it = Utils.H(hash, 2, 2, 4), sz = w * (Utils.H(hash, 4, 10, 20) / 100), aO = (Utils.H(hash, 6, 0, 360) / 360) * Math.PI * 2, nL = Utils.H(hash, 8, 3, 6), hO = Utils.H(hash, 10, 0, 360); const d = (x1, y1, x2, y2, l) => { if (l === 0) { ctx.lineTo(x2, y2); return } const dx = x2 - x1, dy = y2 - y1, di = Math.sqrt(dx * dx + dy * dy), ux = dx / di, uy = dy / di, p1x = x1 + ux * di / 3, p1y = y1 + uy * di / 3, p2x = x1 + ux * di * 2 / 3, p2y = y1 + uy * di * 2 / 3, p3x = p1x + ux * di / 6 - uy * di * Math.sqrt(3) / 6, p3y = p1y + uy * di / 6 + ux * di * Math.sqrt(3) / 6; d(x1, y1, p1x, p1y, l - 1); d(p1x, p1y, p3x, p3y, l - 1); d(p3x, p3y, p2x, p2y, l - 1); d(p2x, p2y, x2, y2, l - 1) }; ctx.lineWidth = 1 * s; ctx.lineJoin = 'bevel'; ctx.lineCap = 'round'; for (let i = 0; i < nL; i++) { const hu = (hO + i * (360 / nL)) % 360; ctx.strokeStyle = `hsla(${hu},70%,60%,0.15)`; const lA = (i / nL) * Math.PI * 2 + aO, x1 = Math.cos(lA) * sz, y1 = Math.sin(lA) * sz, x2 = Math.cos(lA + Math.PI) * sz, y2 = Math.sin(lA + Math.PI) * sz; ctx.beginPath(); ctx.moveTo(x1, y1); d(x1, y1, x2, y2, it); ctx.stroke() } ctx.restore() }
            drawWatermark(ctx, hash, w, h) { ctx.save(); ctx.translate(w / 2, h / 2); const s = w / 1350, nS = Utils.H(hash, 16, 3, 6), sR = w * (Utils.H(hash, 18, 10, 25) / 100) * s, hu = Utils.H(hash, 20, 0, 360); ctx.strokeStyle = `hsla(${hu},50%,80%,0.05)`; ctx.lineWidth = 4 * s; for (let i = 0; i < nS; i++) { ctx.beginPath(); const sA = (i / nS) * Math.PI * 2 + Utils.H(hash, 22, 0, 100) / 100, eA = sA + Utils.H(hash, 24, 6, 12) * Math.PI; for (let t = sA; t < eA; t += 0.05) { const r = sR * (t - sA) / (eA - sA), x = r * Math.cos(t), y = r * Math.sin(t); if (t === sA) ctx.moveTo(x, y); else ctx.lineTo(x, y) } ctx.stroke() } ctx.restore() }
            drawNoisePattern(ctx, hash, w, h) { ctx.save(); for (let i = 0; i < 20000; i++) { const x = Math.random() * w, y = Math.random() * h, o = Math.random() * 0.15, hue = Utils.H(hash, (i % 30) + 4, 0, 360); ctx.fillStyle = `hsla(${hue},50%,80%,${o})`; ctx.fillRect(x, y, 1, 1) } ctx.restore() }
        }

        // --- Start the application ---
        const app = new BanknoteApp();
        app.init();
    </script>
</body>
</html>

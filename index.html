<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger) - Automated</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root { --primary-color: #4b6cb7; --secondary-color: #182848; --danger-color: #d9534f; --light-gray: #f0f2f5; --dark-gray: #6c757d; }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        .view { display: none; }
        .view.active { display: block; }
        .card { background-color: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--primary-color); }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; }
        textarea { resize: vertical; height: 80px; }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: white; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s; margin-top: 10px;}
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0); }
        .back-button { background: var(--dark-gray); }
        .logout-button { background: var(--danger-color); }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px; word-wrap: break-word; }
        .error { color: #d93025; } .success { color: #1e8e3e; } .info { color: #007bff; }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px; margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px; }
        #qr-display-box img { margin: 15px auto; display: block; border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block; margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; }
        label.qr-upload-label:hover { background-color: #f9f9f9; }
        input[type="file"] { display: none; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 20px; height: 20px; animation: spin 1s linear infinite; margin: 10px auto; }
        .hidden { display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
    <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>
    <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>
    <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-button" id="back-from-restore">Back</button></div></div>
    <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>

    <div id="wallet-view" class="view"><div class="card"><h2>Your Wallet</h2><p>Balance:</p><h1 id="balance-display">$0.00</h1><p id="network-status" style="font-size: 12px; color: #1e8e3e;">Ledger: Pinata IPFS</p><button id="show-charge-view-button">Charge with Banknote</button><button id="show-send-view-button">Send</button><button id="show-receive-view-button">Receive</button><button id="logout-button" class="logout-button">Logout (Lock Wallet)</button></div></div>

    <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Load Bank's Public Key</h3><label for="public-key-input" class="qr-upload-label">Upload Public Key File (.json)</label><input type="file" id="public-key-input" accept=".json"><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" class="hidden"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back</button></div></div>

    <div id="send-scan-view" class="view"><div class="card"><h2>Send Funds</h2><label class="qr-upload-label" for="scan-request-input">Upload a payment request QR code to pay</label><input type="file" id="scan-request-input" accept="image/*"><div id="scan-request-status" class="status-box"></div><button class="back-button" onclick="showView('wallet-view')">Back</button></div></div>
    <div id="send-confirmation-view" class="view"><div class="card"><h2>Confirm Payment</h2><p>You are about to send:</p><h1 id="confirm-payment-amount" style="color: var(--primary-color);"></h1><p>To:</p><p id="confirm-payment-address" style="word-wrap: break-word; font-size: 14px;"></p><div id="sending-loader" class="loader hidden"></div><div id="sending-status" class="status-box"></div><button id="confirm-payment-btn">Confirm & Pay</button><button class="back-button" id="cancel-payment-btn">Cancel</button></div></div>
    
    <div id="request-amount-view" class="view"><div class="card"><h2>Request Amount</h2><p>Enter the amount you wish to receive from the sender.</p><input type="number" id="request-amount-input" placeholder="Amount"><button id="generate-request-qr-btn">Generate Request QR Code</button><div id="request-status" class="status-box"></div><button class="back-button" onclick="showView('wallet-view')">Back</button></div></div>

    <div id="qr-display-view" class="view"><div class="card"><h2>Payment Request QR Code</h2><p>Show this code to the sender to scan.</p><div id="qr-display-box"></div><div id="receiving-loader" class="loader hidden"></div><div id="receiving-status" class="status-box"></div><button class="back-button" id="back-from-qr-display">Back to Wallet</button></div></div>

    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.55.0/dist/umd/supabase.js"></script>
    
    <script type="module">
        import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        
        // --- SUPABASE CLIENT SETUP ---
        const SUPABASE_URL = 'https://hoppdalxbmktxexylbkl.supabase.co/functions/v1'; // This should be your project URL
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhvcHBkYWx4Ym1rdHhleHlsYmt_sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MTg3MDc2OTcsImV4cCI6MjAzNDI4MzY5N30.CDBk-S_qH2aM3FR3i8o2d44SQs3n540sL4tQ4b4Ls6o'; // This is a public anon key
        const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let currentChannel = null; // To manage the active channel connection

        // --- CORE & LEDGER LOGIC (Unchanged) ---
        // This section contains the original, unchanged logic for cryptography, banknote validation, and ledger interaction.
        const CoreLogic = (() => { const Constants={VALIDATION_PREFIX:"SADAT_V2_PART",MAX_IMAGE_DIMENSION:2e3,NUM_QR_CODES:9},Utils={arrayBufferToBase64:b=>btoa(String.fromCharCode(...new Uint8Array(b))),base64ToUint8Array:s=>{const t=atob(s),e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e},hexToUint8Array:h=>new Uint8Array(h.match(/.{1,2}/g).map(b=>parseInt(b,16))),preprocessImage:d=>new Promise((r,e)=>{const t=new Image;t.onload=()=>{const e=document.createElement("canvas");e.width=t.width,e.height=t.height;e.getContext("2d",{alpha:!1}).filter="grayscale(1) contrast(2.5) brightness(1.1)",e.getContext("2d").drawImage(t,0,0),r(e.toDataURL("image/jpeg"))},t.onerror=e,t.src=d}),resizeImage:(f,m)=>new Promise((r,e)=>{const t=new FileReader;t.onload=t=>{const e=new Image;e.onload=()=>{const t=document.createElement("canvas");let{width:o,height:a}=e;o>a?o>m&&(a*=m/o,o=m):a>m&&(o*=m/a,a=m),t.width=o,t.height=a,t.getContext("2d").drawImage(e,0,0,o,a),r(t.toDataURL("image/jpeg"))},e.onerror=e,e.src=t.target.result},t.onerror=e,t.readAsDataURL(f)})},Crypto={hashMessageForSigning:m=>Utils.hexToUint8Array(ethers.sha3_256.shake_256(m, { outputBits: 1536 }))},Banknote={getStandardizedDataForSigning:d=>JSON.stringify({timestamp:d.timestamp,serial:d.serial},["timestamp","serial"]),getStandardizedDataForMasterSig:d=>{const t={ephemeralPublicKey:Utils.arrayBufferToBase64(d.ephemeralPublicKey),signatureOne:Utils.arrayBufferToBase64(d.signatureOne)};return JSON.stringify(t,Object.keys(t).sort())},parsePayload:b64=>{const c=Utils.base64ToUint8Array(b64),j=pako.inflate(c,{to:"string"}),p=JSON.parse(j);return{amount:p.a,serial:p.s,timestamp:p.t,ephemeralPublicKey:Utils.base64ToUint8Array(p.epk),signatureOne:Utils.base64ToUint8Array(p.s1),signatureTwo:Utils.base64ToUint8Array(p.s2)}},getLayout:w=>{const s=790,c=w/s;return{qrSize:Math.round(250*c),xSpacing:Math.round(20*c),ySpacing:Math.round(20*c)}},decodeQrGrid:async(imgData,statusEl)=>{const l=Banknote.getLayout(imgData.width),parts={},c=document.createElement("canvas"),x=c.getContext("2d");let count=0;c.width=imgData.width,c.height=imgData.height,x.putImageData(imgData,0,0);for(let i=0;i<Constants.NUM_QR_CODES;i++){statusEl.innerHTML=`<span class="info">Scanning section ${i+1}/${Constants.NUM_QR_CODES}...</span>`,await new Promise(r=>setTimeout(r,5));const row=Math.floor(i/3),col=i%3,rX=col*(l.qrSize+l.xSpacing),rY=row*(l.qrSize+l.ySpacing),d=x.getImageData(rX,rY,l.qrSize,l.qrSize),code=jsQR(d.data,d.width,d.height);if(code&&code.data.startsWith(Constants.VALIDATION_PREFIX)){const m=code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s);if(m){const pN=parseInt(m[1],10);parts[pN]||(parts[pN]=m[3],count++)}}}if(count<Constants.NUM_QR_CODES)throw new Error(`Scan failed. Found ${count}/${Constants.NUM_QR_CODES} sections.`);let payload="";for(let i=1;i<=Constants.NUM_QR_CODES;i++)payload+=parts[i];return payload}};return{Constants,Utils,Crypto,Banknote}})();
        const PinataLedger = (() => { const SUPABASE_FUNCTION_URL = 'https://hoppdalxbmktxexylbkl.supabase.co/functions/v1/quick-responder'; const handleApiError = async (response) => { const rawText = await response.text(); console.error("SERVER ERROR:", { status: response.status, statusText: response.statusText, body: rawText }); try { return (JSON.parse(rawText)).error || rawText; } catch { return rawText; } }; return { recordSpentIdentifier: async (identifier, type) => { try { const response = await fetch(SUPABASE_FUNCTION_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ identifier, type }) }); if (!response.ok) throw new Error(await handleApiError(response)); console.log('Identifier recorded. IPFS Hash:', (await response.json()).ipfsHash); return true; } catch (error) { alert(`Critical Error: Could not write to the public ledger. Reason: ${error.message}`); return false; } }, hasBeenSpent: async (identifier) => { try { const url = new URL(SUPABASE_FUNCTION_URL); url.searchParams.append('identifier', identifier); const response = await fetch(url.toString(), { method: 'GET' }); if (!response.ok) throw new Error(await handleApiError(response)); return (await response.json()).spent; } catch (error) { alert(`Critical Error: Could not read from the public ledger. Reason: ${error.message}`); return true; } } }; })();

        // --- WALLET LOGIC (Unchanged) ---
        // This section contains the original, unchanged logic for wallet creation, encryption, balance calculation, and transaction chaining.
        const AppConstants = { MAX_LOGIN_ATTEMPTS: 5, LOGIN_LOCKOUT_PERIOD: 30000 };
        let state = { wallet: null, masterPublicKey: null, userStore: null, falconApi: null, failedLoginAttempts: 0, isLockedOut: false };
        const WalletLogic = { createWallet: (password) => { const wallet = ethers.Wallet.createRandom(); const mnemonic = wallet.mnemonic.phrase; const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return { mnemonic }; }, restoreWallet: async (mnemonic, password) => { try { const wallet = ethers.Wallet.fromPhrase(mnemonic); const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return true; } catch (e) { console.error("Restore failed:", e); return false; } }, login: async (password) => { const userStoreJson = localStorage.getItem('aura_user_store'); if (!userStoreJson) return null; try { const reloadedUserStore = JSON.parse(userStoreJson); const wallet = await ethers.Wallet.fromEncryptedJson(reloadedUserStore.encryptedJson, password); state.userStore = reloadedUserStore; state.wallet = wallet; state.failedLoginAttempts = 0; return true; } catch (e) { console.error("Login failed:", e); state.failedLoginAttempts++; return false; } }, logout: () => { state.wallet = null; state.userStore = null; if (currentChannel) { supabase.removeChannel(currentChannel); currentChannel = null; } }, getLastTransaction: () => state.userStore.chain[state.userStore.chain.length - 1], addToChain: (txData) => { const prevTx = WalletLogic.getLastTransaction(); const newTx = { ...txData, prevHash: prevTx.hash, timestamp: Date.now() }; newTx.hash = ethers.solidityPackedKeccak256(['string', 'uint256', 'string', 'string', 'string'], [newTx.type, newTx.amount || 0, newTx.from || '', newTx.to || '', newTx.prevHash]); state.userStore.chain.push(newTx); localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); return newTx; }, calculateBalance: () => { if (!state.userStore) return 0.0; return state.userStore.chain.reduce((balance, tx) => { if (tx.status !== 'completed') return balance; if (tx.type === 'charge' || tx.type === 'receive') return balance + (tx.amount || 0); if (tx.type === 'send') return balance - (tx.amount || 0); return balance; }, 0); }, createProposal: async (amount, toAddress) => { const proposalTx = WalletLogic.addToChain({ type: 'send', amount: amount, from: state.wallet.address, to: toAddress, status: 'pending' }); const proposal = { type: 'AURA_PROPOSAL', senderAddress: state.wallet.address, senderPublicKey: state.wallet.publicKey, txHash: proposalTx.hash, amount: amount }; proposal.signature = await state.wallet.signMessage(JSON.stringify(proposal)); return proposal; }, createReceipt: async (proposal) => { const receiptTx = WalletLogic.addToChain({ type: 'receive', amount: proposal.amount, from: proposal.senderAddress, to: state.wallet.address, status: 'completed', linkedTxHash: proposal.txHash }); const receipt = { type: 'AURA_RECEIPT', receiverAddress: state.wallet.address, txHash: receiptTx.hash, linkedTxHash: proposal.txHash }; receipt.signature = await state.wallet.signMessage(JSON.stringify(receipt)); return receipt; }, verifyAndFinalize: async (receipt) => { const senderTxIndex = state.userStore.chain.findIndex(tx => tx.hash === receipt.linkedTxHash); if (senderTxIndex === -1 || state.userStore.chain[senderTxIndex].status === 'completed') throw new Error("Associated send transaction not found or already completed."); const signerAddress = ethers.verifyMessage(JSON.stringify(receipt), receipt.signature); const success = await PinataLedger.recordSpentIdentifier(receipt.linkedTxHash, 'transaction'); if (!success) throw new Error("Could not finalize transaction on the public ledger."); state.userStore.chain[senderTxIndex].status = 'completed'; localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); return true; } };

        // --- UI & EVENT HANDLING ---
        function resetViewInputs(viewId) { const view = document.getElementById(viewId); if (!view) return; view.querySelectorAll('input, textarea').forEach(input => { if (input.type !== 'file') input.value = ''; }); const statusBox = view.querySelector('.status-box'); if (statusBox) statusBox.innerHTML = ''; }
        function showView(id) { document.querySelectorAll('.view').forEach(v => v.classList.remove('active')); document.getElementById(id).classList.add('active'); if (currentChannel) { supabase.removeChannel(currentChannel); currentChannel = null; } }
        function updateBalanceDisplay() { const balance = WalletLogic.calculateBalance(); document.getElementById('balance-display').textContent = `$${balance.toFixed(2)}`; }
        function generateQrCode(data, containerId) { const container = document.getElementById(containerId); container.innerHTML = ''; const qr = qrcode(0, 'L'); qr.addData(JSON.stringify(data)); qr.make(); container.innerHTML = qr.createImgTag(6, 10); }
        async function decodeQrFromFile(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = e => { const image = new Image(); image.onload = () => { const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) { try { resolve(JSON.parse(code.data)); } catch { reject(new Error("QR code contains invalid data.")); } } else { reject(new Error("QR Code not found or invalid.")); } }; image.src = e.target.result; }; reader.readAsDataURL(file); }); }
        
        async function initializeApp() { try { state.falconApi = await pqcSignFalcon1024(); } catch (e) { alert(`Critical error initializing cryptography module: ${e.message}`); return; } if (localStorage.getItem('aura_user_store')) { showView('login-view'); } else { showView('onboarding-view'); } setupEventListeners(); }

        function setupEventListeners() {
            // --- Navigation ---
            document.getElementById('go-to-create-wallet').addEventListener('click', () => showView('create-wallet-view'));
            document.getElementById('go-to-restore-wallet').addEventListener('click', () => showView('restore-wallet-view'));
            document.getElementById('back-from-create').addEventListener('click', () => showView('onboarding-view'));
            document.getElementById('back-from-restore').addEventListener('click', () => showView('onboarding-view'));
            document.getElementById('back-from-charge').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('back-from-qr-display').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('cancel-payment-btn').addEventListener('click', () => showView('send-scan-view'));

            // --- Wallet Creation & Login (Unchanged) ---
            document.getElementById('create-wallet-button').addEventListener('click', () => { const pass = document.getElementById('create-password-input').value, confirmPass = document.getElementById('confirm-password-input').value, statusEl = document.getElementById('create-status'); statusEl.textContent = ''; if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } if (pass !== confirmPass) { statusEl.innerHTML = '<span class="error">Passwords do not match.</span>'; return; } setTimeout(() => { const { mnemonic } = WalletLogic.createWallet(pass); document.getElementById('seed-phrase-display').textContent = mnemonic; showView('seed-phrase-view'); }, 50); });
            document.getElementById('seed-phrase-confirm-button').addEventListener('click', () => { updateBalanceDisplay(); showView('wallet-view'); document.getElementById('seed-phrase-display').textContent = ''; resetViewInputs('create-wallet-view'); });
            document.getElementById('restore-wallet-button').addEventListener('click', async () => { const mnemonic = document.getElementById('restore-seed-input').value.trim(), pass = document.getElementById('restore-password-input').value.trim(), statusEl = document.getElementById('restore-status'); statusEl.textContent = ''; if (mnemonic.split(' ').length !== 12) { statusEl.innerHTML = '<span class="error">Recovery phrase must be 12 words.</span>'; return; } if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } const success = await WalletLogic.restoreWallet(mnemonic, pass); if (success) { updateBalanceDisplay(); showView('wallet-view'); } else { statusEl.innerHTML = '<span class="error">Restore failed. Invalid phrase.</span>'; } resetViewInputs('restore-wallet-view'); });
            document.getElementById('login-button').addEventListener('click', async () => { if(state.isLockedOut) return; const pass=document.getElementById('login-password-input').value, statusEl=document.getElementById('login-status'), button=document.getElementById('login-button'); button.disabled=true; const success=await WalletLogic.login(pass); if(success){updateBalanceDisplay();showView('wallet-view');resetViewInputs('login-view');}else{if(state.failedLoginAttempts>=AppConstants.MAX_LOGIN_ATTEMPTS){state.isLockedOut=true;statusEl.innerHTML=`<span class="error">Too many failed attempts. Please wait 30 seconds.</span>`;setTimeout(()=>{state.isLockedOut=false;state.failedLoginAttempts=0;statusEl.textContent='';button.disabled=false;},AppConstants.LOGIN_LOCKOUT_PERIOD);}else{statusEl.innerHTML=`<span class="error">Invalid password. (${AppConstants.MAX_LOGIN_ATTEMPTS - state.failedLoginAttempts} attempts remaining)</span>`;}} if(!state.isLockedOut) button.disabled=false;});
            document.getElementById('logout-button').addEventListener('click', () => { WalletLogic.logout(); showView('login-view'); });
            document.getElementById('reset-app-button').addEventListener('click', () => { if (confirm('Are you sure? All wallet data will be erased from this browser.')) { localStorage.removeItem('aura_user_store'); location.reload(); } });

            // --- Wallet Actions ---
            document.getElementById('show-charge-view-button').addEventListener('click', () => showView('charge-view'));
            document.getElementById('show-send-view-button').addEventListener('click', () => { resetViewInputs('send-scan-view'); showView('send-scan-view'); });
            document.getElementById('show-receive-view-button').addEventListener('click', () => { resetViewInputs('request-amount-view'); showView('request-amount-view'); });
            
            // --- Automated Send/Receive Flow ---
            
            // RECEIVER LOGIC
            document.getElementById('generate-request-qr-btn').addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('request-amount-input').value);
                const statusEl = document.getElementById('request-status');
                if (isNaN(amount) || amount <= 0) {
                    statusEl.innerHTML = '<span class="error">Please enter a valid amount.</span>';
                    return;
                }
                const channelId = `tx-${self.crypto.randomUUID()}`;
                const requestPayload = {
                    type: 'AURA_PAYMENT_REQUEST',
                    receiverAddress: state.wallet.address,
                    amount: amount,
                    channelId: channelId
                };
                generateQrCode(requestPayload, 'qr-display-box');
                showView('qr-display-view');

                const loader = document.getElementById('receiving-loader');
                const receiveStatus = document.getElementById('receiving-status');
                loader.classList.remove('hidden');
                receiveStatus.innerHTML = `<span class="info">Waiting for sender to scan...</span>`;

                currentChannel = supabase.channel(channelId);
                currentChannel.on('broadcast', { event: 'PROPOSAL' }, async ({ payload }) => {
                    try {
                        receiveStatus.innerHTML = '<span class="info">Sender connected. Creating receipt...</span>';
                        // Validate proposal before creating receipt
                        const message = JSON.stringify({ ...payload, signature: undefined });
                        const signerAddress = ethers.verifyMessage(message, payload.signature);
                        if (signerAddress !== payload.senderAddress) throw new Error("Sender's signature is invalid.");
                        if (await PinataLedger.hasBeenSpent(payload.txHash)) throw new Error('This transaction has already been processed.');
                        
                        const receipt = await WalletLogic.createReceipt(payload);
                        await currentChannel.send({ type: 'broadcast', event: 'RECEIPT', payload: receipt });
                        
                        receiveStatus.innerHTML = '<span class="success">Payment Received!</span>';
                        updateBalanceDisplay();
                    } catch (err) {
                        receiveStatus.innerHTML = `<span class="error">Error: ${err.message}</span>`;
                    } finally {
                        loader.classList.add('hidden');
                        supabase.removeChannel(currentChannel);
                        currentChannel = null;
                    }
                }).subscribe();
            });

            // SENDER LOGIC
            document.getElementById('scan-request-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const statusEl = document.getElementById('scan-request-status');
                try {
                    statusEl.innerHTML = '<span class="info">Processing QR code...</span>';
                    const data = await decodeQrFromFile(file);
                    if (data.type !== 'AURA_PAYMENT_REQUEST' || !data.amount || !data.receiverAddress || !data.channelId) {
                        throw new Error('This is not a valid payment request QR code.');
                    }
                    if (data.receiverAddress === state.wallet.address) {
                        throw new Error('You cannot send funds to yourself.');
                    }

                    document.getElementById('confirm-payment-amount').textContent = `$${data.amount.toFixed(2)}`;
                    document.getElementById('confirm-payment-address').textContent = data.receiverAddress;
                    const confirmBtn = document.getElementById('confirm-payment-btn');
                    confirmBtn.dataset.amount = data.amount;
                    confirmBtn.dataset.address = data.receiverAddress;
                    confirmBtn.dataset.channelId = data.channelId;
                    
                    document.getElementById('sending-loader').classList.add('hidden');
                    document.getElementById('sending-status').innerHTML = '';
                    confirmBtn.disabled = false;
                    
                    showView('send-confirmation-view');
                } catch (err) {
                    statusEl.innerHTML = `<span class="error">Error: ${err.message}</span>`;
                } finally {
                    event.target.value = '';
                }
            });

            document.getElementById('confirm-payment-btn').addEventListener('click', async (event) => {
                const button = event.target;
                button.disabled = true;
                const amount = parseFloat(button.dataset.amount);
                const address = button.dataset.address;
                const channelId = button.dataset.channelId;
                
                const loader = document.getElementById('sending-loader');
                const sendStatus = document.getElementById('sending-status');
                loader.classList.remove('hidden');
                sendStatus.innerHTML = '<span class="info">Connecting to receiver...</span>';

                if (amount > WalletLogic.calculateBalance()) {
                    sendStatus.innerHTML = '<span class="error">Insufficient funds.</span>';
                    loader.classList.add('hidden');
                    button.disabled = false;
                    return;
                }

                currentChannel = supabase.channel(channelId);
                currentChannel.on('broadcast', { event: 'RECEIPT' }, async ({ payload }) => {
                    try {
                        sendStatus.innerHTML = '<span class="info">Receipt received. Finalizing transaction...</span>';
                        await WalletLogic.verifyAndFinalize(payload);
                        sendStatus.innerHTML = '<span class="success">Transaction Successful!</span>';
                        updateBalanceDisplay();
                        setTimeout(() => showView('wallet-view'), 2000);
                    } catch(err) {
                        sendStatus.innerHTML = `<span class="error">Finalization Failed: ${err.message}</span>`;
                    } finally {
                        loader.classList.add('hidden');
                        supabase.removeChannel(currentChannel);
                        currentChannel = null;
                    }
                }).subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        try {
                            sendStatus.innerHTML = '<span class="info">Sending proposal...</span>';
                            const proposal = await WalletLogic.createProposal(amount, address);
                            await currentChannel.send({ type: 'broadcast', event: 'PROPOSAL', payload: proposal });
                            sendStatus.innerHTML = '<span class="info">Proposal sent. Waiting for receipt...</span>';
                        } catch (err) {
                            sendStatus.innerHTML = `<span class="error">Could not send proposal: ${err.message}</span>`;
                            loader.classList.add('hidden');
                        }
                    }
                });
            });

        }
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

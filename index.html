<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root { --primary-color: #4b6cb7; --secondary-color: #182848; --danger-color: #d9534f; --light-gray: #f0f2f5; --dark-gray: #6c757d; }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        .view { display: none; }
        .view.active { display: block; }
        .card { background-color: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--primary-color); }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; }
        textarea { resize: vertical; height: 80px; }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: white; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0); }
        .back-button { background: var(--dark-gray); margin-top: 10px; }
        .logout-button { background: var(--danger-color); margin-top: 10px; }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px; word-wrap: break-word; }
        .error { color: #d93025; } .success { color: #1e8e3e; } .info { color: #007bff; }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px; margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px; }
        #my-qr-code img, #qr-display-box img { margin: 15px auto; display: block; border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block; margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; }
        label.qr-upload-label:hover { background-color: #f9f9f9; }
        input[type="file"] { display: none; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; margin: 10px auto; }
        .loader.hidden { display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
    
    <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><div class="loader hidden" id="create-loader"></div><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>

    <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>

    <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><div class="loader hidden" id="restore-loader"></div><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-button" id="back-from-restore">Back</button></div></div>
    
    <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><div class="loader hidden" id="login-loader"></div><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>
    
    <div id="wallet-view" class="view"><div class="card"><h2>Your Wallet</h2><p>Balance:</p><h1 id="balance-display">$0.00</h1><p id="network-status" style="font-size: 12px; color: #1e8e3e;">Ledger: Pinata IPFS</p><button id="show-charge-view-button">Charge with Banknote</button><button id="show-send-view-button" style="margin-top:10px;">Send (Aura)</button><button id="show-receive-view-button" style="margin-top:10px;">Receive (Aura)</button><button id="logout-button" class="logout-button">Logout (Lock Wallet)</button></div></div>
    
    <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Load Bank's Public Key</h3><label for="public-key-input" class="qr-upload-label">Upload Public Key File (.json)</label><input type="file" id="public-key-input" accept=".json"><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" style="display:none; margin-top: 20px;"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back</button></div></div>
    
    <div id="receive-view" class="view"><div class="card">
        <h2>Receive Funds</h2>
        <p>Enter the amount you want to request.</p>
        <input type="number" id="request-amount-input" placeholder="Amount to receive">
        <button id="create-request-qr-button">Generate Payment Request QR</button>
        <div id="receive-status" class="status-box"></div>
        <button class="back-button" onclick="showView('wallet-view')">Back</button>
    </div></div>
    
    <div id="send-view" class="view"><div class="card">
        <h2>Send Funds</h2>
        <p>Scan the recipient's payment request QR code.</p>
        <label class="qr-upload-label" for="scan-payment-request-input">Upload Payment Request QR</label>
        <input type="file" id="scan-payment-request-input" accept="image/*">
        <div id="send-status" class="status-box"></div>
        <button class="back-button" id="back-from-send">Back</button>
    </div></div>
    
    <div id="send-confirm-view" class="view"><div class="card">
        <h2>Confirm Payment</h2>
        <p>You are about to send:</p>
        <h2 id="confirm-amount-display" style="color: var(--primary-color);"></h2>
        <p>To:</p>
        <p id="confirm-recipient-address-display" style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;"></p>
        <button id="confirm-payment-button">Confirm and Pay</button>
        <div id="send-confirm-status" class="status-box"></div>
        <button class="back-button" id="back-from-send-confirm">Cancel</button>
    </div></div>
    
    <div id="qr-display-view" class="view"><div class="card">
        <h2 id="qr-display-title"></h2>
        <p id="qr-display-instruction"></p>
        <div id="qr-display-box"></div>
        <div id="waiting-on-payment" style="display: none;">
            <div class="loader"></div>
            <p id="final-status-message" class="status-box" style="font-size:18px;"></p>
        </div>
        <button class="back-button" id="back-from-qr-display">Back to Wallet</button>
    </div></div>
    

    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    
    <script type="module">
        import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

        // CORE BANKNOTE & PINATA LEDGER LOGIC (Unchanged)
        const CoreLogic = (() => { const Constants = { VALIDATION_PREFIX: "SADAT_V2_PART", MAX_IMAGE_DIMENSION: 2000, NUM_QR_CODES: 9 }; const Utils = { arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))), base64ToUint8Array: (s) => { const bs=atob(s); const b=new Uint8Array(bs.length); for(let i=0;i<bs.length;i++)b[i]=bs.charCodeAt(i); return b; }, hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))), preprocessImage: (d) => new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas'); c.width=i.width; c.height=i.height; const x=c.getContext('2d'); x.filter='grayscale(1) contrast(2.5) brightness(1.1)'; x.drawImage(i,0,0); res(c.toDataURL('image/jpeg')); }; i.onerror=rej; i.src=d; }), resizeImage: (f, m) => new Promise((res, rej) => { const r=new FileReader();r.onload=e=>{const i=new Image();i.onload=()=>{const c=document.createElement('canvas');let{width:w,height:h}=i;if(w>h){if(w>m){h*=m/w;w=m;}}else{if(h>m){w*=m/h;h=m;}}c.width=w;c.height=h;c.getContext('2d').drawImage(i,0,0,w,h);res(c.toDataURL('image/jpeg'));};i.onerror=rej;i.src=e.target.result;};r.onerror=rej;r.readAsDataURL(f);}), }; const Crypto = { hashMessageForSigning: (m) => Utils.hexToUint8Array(shake256(m, 1536)), async verifySignature(sig, data, pk, api) { const h=this.hashMessageForSigning(data); return api.verify(sig, h, pk); } }; const Banknote = { getStandardizedDataForSigning: (d) => JSON.stringify({timestamp:d.timestamp,serial:d.serial},['timestamp','serial']), getStandardizedDataForMasterSig: (d) => { const t={ephemeralPublicKey:Utils.arrayBufferToBase64(d.ephemeralPublicKey),signatureOne:Utils.arrayBufferToBase64(d.signatureOne)}; return JSON.stringify(t, Object.keys(t).sort()); }, parsePayload: (b64) => { const c=Utils.base64ToUint8Array(b64); const j=pako.inflate(c,{to:'string'}); const p=JSON.parse(j); return {amount:p.a,serial:p.s,timestamp:p.t,ephemeralPublicKey:Utils.base64ToUint8Array(p.epk),signatureOne:Utils.base64ToUint8Array(p.s1),signatureTwo:Utils.base64ToUint8Array(p.s2)}; }, getLayout: (w) => { const s=790; const c=w/s; return {qrSize:Math.round(250*c),xSpacing:Math.round(20*c),ySpacing:Math.round(20*c)}; }, decodeQrGrid: async (imgData, statusEl) => { const l=Banknote.getLayout(imgData.width); const parts={}; let count=0; const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=imgData.width;c.height=imgData.height;x.putImageData(imgData,0,0); for(let i=0;i<Constants.NUM_QR_CODES;i++){ statusEl.innerHTML=`<span class="info">Scanning section ${i+1}/${Constants.NUM_QR_CODES}...</span>`; await new Promise(r=>setTimeout(r,5)); const row=Math.floor(i/3),col=i%3,rX=col*(l.qrSize+l.xSpacing),rY=row*(l.qrSize+l.ySpacing),d=x.getImageData(rX,rY,l.qrSize,l.qrSize); const code=jsQR(d.data,d.width,d.height); if(code&&code.data.startsWith(Constants.VALIDATION_PREFIX)){const m=code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s); if(m){const pN=parseInt(m[1],10);if(!parts[pN]){parts[pN]=m[3];count++;}}} } if(count<Constants.NUM_QR_CODES){throw new Error(`Scan failed. Found ${count}/${Constants.NUM_QR_CODES} sections.`);} let payload=''; for(let i=1;i<=Constants.NUM_QR_CODES;i++){payload+=parts[i];} return payload; } }; return { Constants, Utils, Crypto, Banknote }; })();
        const PinataLedger = (() => { const PINATA_JWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJiZTkzZDRkMC0yYjgzLTQwZDMtYjg5Mi1iMGJiZGVkMTdiZDYiLCJlbWFpbCI6ImExbTNpNXIuYWZnQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiI0Y2UzOTU0ZjIxZGRhYTdlMmM1NiIsInNjb3BlZEtleVNlY3JldCI6ImU3YTA3NmZjZTJjN2Q0NzM0OWY0MTFjYmE5ODE5YmZiNzVjYTY2MzZmYTVhMDdiNDk2MTJmYWU3MjlhZmQxNmIiLCJleHAiOjE3ODcxMzI1NTh9.dV4M4P4LaqxiZ91ye3F4n5oP98sIqGQVA2waPrGDFJc'; const apiCall = async (endpoint, options) => { const response = await fetch(`https://api.pinata.cloud/${endpoint}`, options); if (!response.ok) throw new Error(`Pinata API error! Status: ${response.status}`); return response.json(); }; const recordSpentIdentifier = async (identifier, type) => { const dataToPin = { pinataContent: { identifier: identifier, type: type, status: "spent", timestamp: new Date().toISOString() }, pinataMetadata: { name: `${type}-${identifier}.json`, keyvalues: { identifier: identifier } } }; try { await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) }); return true; } catch (error) { console.error('Failed to record identifier to Pinata:', error); alert(`Critical Error: Could not write to the public ledger. Transaction cannot be safely completed. Reason: ${error.message}`); return false; } }; const hasBeenSpent = async (identifier) => { try { const result = await apiCall(`data/pinList?metadata[keyvalues]={"identifier":{"value":"${identifier}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); return result.count > 0; } catch (error) { console.error('Failed to check identifier status on Pinata:', error); alert(`Critical Error: Could not read from the public ledger. Cannot verify transaction safety. Reason: ${error.message}`); return true; } }; const pinConfirmation = async (confirmation) => { const dataToPin = { pinataContent: confirmation, pinataMetadata: { name: `confirmation-${confirmation.linkedTxHash}.json`, keyvalues: { type: 'confirmation', txHash: confirmation.linkedTxHash } } }; await apiCall('pinning/pinJSONToIPFS', { method: 'POST', headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${PINATA_JWT}` }, body: JSON.stringify(dataToPin) }); }; const findConfirmation = async (txHash) => { const result = await apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"txHash":{"value":"${txHash}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${PINATA_JWT}` } }); if (result.count > 0) { const hash = result.rows[0].ipfs_pin_hash; const contentResponse = await fetch(`https://gateway.pinata.cloud/ipfs/${hash}`); return contentResponse.json(); } return null; }; return { recordSpentIdentifier, hasBeenSpent, pinConfirmation, findConfirmation }; })();
        
        // ===================================================================================
        // AURA PROTOCOL - DECENTRALIZED WALLET APPLICATION (MODIFIED LOGIC)
        // ===================================================================================
        const AppConstants = { MAX_LOGIN_ATTEMPTS: 5, LOGIN_LOCKOUT_PERIOD: 30000, POLLING_INTERVAL: 5000 };
        let state = { wallet: null, masterPublicKey: null, userStore: null, falconApi: null, failedLoginAttempts: 0, isLockedOut: false, activePaymentRequest: null, activePollingTimer: null };

        const WalletLogic = {
            createWallet: (password) => { const wallet = ethers.Wallet.createRandom(); const mnemonic = wallet.mnemonic.phrase; const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return { mnemonic }; },
            restoreWallet: async (mnemonic, password) => { try { const wallet = ethers.Wallet.fromPhrase(mnemonic); const encryptedJson = wallet.encryptSync(password); const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now() }] }; localStorage.setItem('aura_user_store', JSON.stringify(userStore)); state.userStore = userStore; state.wallet = wallet; return true; } catch (e) { console.error("Restore failed:", e); return false; } },
            login: async (password) => { const userStoreJson = localStorage.getItem('aura_user_store'); if (!userStoreJson) return null; try { const reloadedUserStore = JSON.parse(userStoreJson); const wallet = await ethers.Wallet.fromEncryptedJson(reloadedUserStore.encryptedJson, password); state.userStore = reloadedUserStore; state.wallet = wallet; state.failedLoginAttempts = 0; return true; } catch (e) { console.error("Login failed (likely incorrect password):", e); state.failedLoginAttempts++; return false; } },
            logout: () => { state.wallet = null; state.userStore = null; },
            getLastTransaction: () => state.userStore.chain[state.userStore.chain.length - 1],
            addToChain: (txData) => { const prevTx = WalletLogic.getLastTransaction(); const newTx = { ...txData, prevHash: prevTx.hash, timestamp: Date.now() }; newTx.hash = ethers.solidityPackedKeccak256(['string', 'uint256', 'string', 'string', 'string'], [newTx.type, newTx.amount || 0, newTx.from || '', newTx.to || '', newTx.prevHash]); state.userStore.chain.push(newTx); localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); return newTx; },
            calculateBalance: () => { if (!state.userStore) return 0.0; return state.userStore.chain.reduce((balance, tx) => { if (tx.status !== 'completed') return balance; if (tx.type === 'charge' || tx.type === 'receive') return balance + (tx.amount || 0); if (tx.type === 'send') return balance - (tx.amount || 0); return balance; }, 0); },
            
            getStandardizedConfirmationMessage: (confirmation) => {
                const amount = Number(confirmation.amount).toFixed(8);
                return [confirmation.type, confirmation.senderAddress, amount, confirmation.linkedTxHash].join('|');
            },

            createPaymentRequest: (amount) => { const receiveTx = WalletLogic.addToChain({ type: 'receive', amount: amount, from: '', to: state.wallet.address, status: 'pending_request' }); return { type: 'AURA_PAYMENT_REQUEST', receiverAddress: state.wallet.address, amount: amount, linkedTxHash: receiveTx.hash }; },
            
            processPayment: async (request) => { 
                if (WalletLogic.calculateBalance() < request.amount) throw new Error("Insufficient funds."); 
                if (await PinataLedger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been processed."); 
                
                WalletLogic.addToChain({ type: 'send', amount: request.amount, from: state.wallet.address, to: request.receiverAddress, status: 'completed', linkedTxHash: request.linkedTxHash }); 
                const success = await PinataLedger.recordSpentIdentifier(request.linkedTxHash, 'transaction'); 
                if (!success) throw new Error("CRITICAL: Payment sent but failed to update public ledger."); 

                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: state.wallet.address, amount: request.amount, linkedTxHash: request.linkedTxHash };
                
                // **NEW ARCHITECTURE**: The message that is signed is now also included in the payload.
                const messageToSign = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                confirmation.signature = await state.wallet.signMessage(messageToSign);
                confirmation.signedMessage = messageToSign; // Include the exact signed message
                
                await PinataLedger.pinConfirmation(confirmation); 
                return true; 
            },

            finalizePayment: async (confirmation) => { 
                const receiveTxIndex = state.userStore.chain.findIndex(tx => tx.hash === confirmation.linkedTxHash && tx.status === 'pending_request'); 
                if (receiveTxIndex === -1) {
                    console.error("Finalize Error: Could not find pending transaction.");
                    return false;
                }
                
                // **NEW ARCHITECTURE**: Verify using the `signedMessage` provided in the payload.
                // This eliminates any possibility of mismatch between sender and receiver.
                if (!confirmation.signedMessage) {
                    console.error("Finalize Error: Receipt is missing the 'signedMessage' field.");
                    return false;
                }

                // Security Check: Ensure the data in the confirmation matches the signed message.
                const locallyRecreatedMessage = WalletLogic.getStandardizedConfirmationMessage(confirmation);
                if (locallyRecreatedMessage !== confirmation.signedMessage) {
                    console.error("Tamper Detection: Confirmation data does not match the signed message!");
                    return false;
                }
                
                const signerAddress = ethers.verifyMessage(confirmation.signedMessage, confirmation.signature); 
                
                if (signerAddress !== confirmation.senderAddress) { 
                    console.error("Signature verification failed!");
                    console.error("Expected Signer (from receipt):", confirmation.senderAddress);
                    console.error("Actual Signer (from signature):", signerAddress);
                    return false; 
                } 
                
                state.userStore.chain[receiveTxIndex].status = 'completed'; 
                state.userStore.chain[receiveTxIndex].from = confirmation.senderAddress; 
                localStorage.setItem('aura_user_store', JSON.stringify(state.userStore)); 
                return true; 
            }
        };
        
        // UI & EVENT LISTENERS
        function setLoader(loaderId, isLoading) { document.getElementById(loaderId).classList.toggle('hidden', !isLoading); }
        function resetViewInputs(viewId) { const view = document.getElementById(viewId); if (!view) return; view.querySelectorAll('input, textarea').forEach(input => { if (input.type !== 'file') input.value = ''; }); const statusBox = view.querySelector('.status-box'); if (statusBox) statusBox.innerHTML = ''; }
        function showView(id) { if (state.activePollingTimer) { clearInterval(state.activePollingTimer); state.activePollingTimer = null; } document.querySelectorAll('.view').forEach(v => v.classList.remove('active')); document.getElementById(id).classList.add('active'); }
        function updateBalanceDisplay() { const balance = WalletLogic.calculateBalance(); document.getElementById('balance-display').textContent = `$${balance.toFixed(2)}`; }
        function generateQrCode(data, containerId) { const container = document.getElementById(containerId); container.innerHTML = ''; const qr = qrcode(0, 'L'); qr.addData(JSON.stringify(data)); qr.make(); container.innerHTML = qr.createImgTag(6, 10); }
        async function decodeQrFromFile(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = e => { const image = new Image(); image.onload = () => { const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const code = jsQR(imageData.data, imageData.width, imageData.height); if (code) { try { resolve(JSON.parse(code.data)); } catch { reject(new Error("QR code contains invalid data.")); } } else { reject(new Error("QR Code not found or invalid.")); } }; image.src = e.target.result; }; reader.readAsDataURL(file); }); }
        
        async function initializeApp() { try { state.falconApi = await pqcSignFalcon1024(); } catch (e) { alert(`Critical error initializing cryptography module: ${e.message}`); return; } if (localStorage.getItem('aura_user_store')) { showView('login-view'); } else { showView('onboarding-view'); } setupEventListeners(); }

        function setupEventListeners() {
            document.getElementById('go-to-create-wallet').addEventListener('click', () => showView('create-wallet-view'));
            document.getElementById('go-to-restore-wallet').addEventListener('click', () => showView('restore-wallet-view'));
            document.getElementById('back-from-create').addEventListener('click', () => { resetViewInputs('create-wallet-view'); showView('onboarding-view'); });
            document.getElementById('back-from-restore').addEventListener('click', () => { resetViewInputs('restore-wallet-view'); showView('onboarding-view'); });
            document.getElementById('back-from-charge').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('back-from-send').addEventListener('click', () => { resetViewInputs('send-view'); showView('wallet-view'); });
            document.getElementById('back-from-send-confirm').addEventListener('click', () => showView('send-view'));
            document.getElementById('back-from-qr-display').addEventListener('click', () => { updateBalanceDisplay(); showView('wallet-view'); });
            document.getElementById('create-wallet-button').addEventListener('click', async () => { const button = document.getElementById('create-wallet-button'), statusEl = document.getElementById('create-status'); const pass = document.getElementById('create-password-input').value.trim(), confirmPass = document.getElementById('confirm-password-input').value.trim(); statusEl.textContent = ''; if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } if (pass !== confirmPass) { statusEl.innerHTML = '<span class="error">Passwords do not match.</span>'; return; } button.disabled = true; setLoader('create-loader', true); setTimeout(() => { const { mnemonic } = WalletLogic.createWallet(pass); document.getElementById('seed-phrase-display').textContent = mnemonic; showView('seed-phrase-view'); button.disabled = false; setLoader('create-loader', false); }, 50); });
            document.getElementById('seed-phrase-confirm-button').addEventListener('click', async () => { updateBalanceDisplay(); showView('wallet-view'); document.getElementById('seed-phrase-display').textContent = ''; resetViewInputs('create-wallet-view'); });
            document.getElementById('restore-wallet-button').addEventListener('click', async () => { const button = document.getElementById('restore-wallet-button'), statusEl = document.getElementById('restore-status'); const mnemonic = document.getElementById('restore-seed-input').value.trim(), pass = document.getElementById('restore-password-input').value.trim(); statusEl.textContent = ''; if (mnemonic.split(' ').length !== 12) { statusEl.innerHTML = '<span class="error">Recovery phrase must be 12 words.</span>'; return; } if (pass.length < 8) { statusEl.innerHTML = '<span class="error">Password must be at least 8 characters.</span>'; return; } button.disabled = true; setLoader('restore-loader', true); const success = await WalletLogic.restoreWallet(mnemonic, pass); if (success) { updateBalanceDisplay(); showView('wallet-view'); } else { statusEl.innerHTML = '<span class="error">Restore failed. Invalid phrase.</span>'; } button.disabled = false; setLoader('restore-loader', false); resetViewInputs('restore-wallet-view'); });
            document.getElementById('login-button').addEventListener('click', async () => { if (state.isLockedOut) return; const button = document.getElementById('login-button'), statusEl = document.getElementById('login-status'); const pass = document.getElementById('login-password-input').value.trim(); button.disabled = true; setLoader('login-loader', true); statusEl.innerHTML = '<span class="info">Decrypting wallet...</span>'; const success = await WalletLogic.login(pass); if (success) { updateBalanceDisplay(); showView('wallet-view'); resetViewInputs('login-view'); } else { if (state.failedLoginAttempts >= AppConstants.MAX_LOGIN_ATTEMPTS) { state.isLockedOut = true; statusEl.innerHTML = `<span class="error">Too many failed attempts. Please wait 30 seconds.</span>`; setTimeout(() => { state.isLockedOut = false; state.failedLoginAttempts = 0; statusEl.textContent = ''; button.disabled = false; }, AppConstants.LOGIN_LOCKOUT_PERIOD); } else { statusEl.innerHTML = `<span class="error">Invalid password. (${AppConstants.MAX_LOGIN_ATTEMPTS - state.failedLoginAttempts} attempts remaining)</span>`; } } if (!state.isLockedOut) button.disabled = false; setLoader('login-loader', false); });
            document.getElementById('logout-button').addEventListener('click', () => { WalletLogic.logout(); showView('login-view'); });
            document.getElementById('reset-app-button').addEventListener('click', () => { if (confirm('Are you sure? All wallet data will be erased from this browser.')) { localStorage.removeItem('aura_user_store'); location.reload(); } });
            
            // --- AUTOMATED PAYMENT FLOW ---
            document.getElementById('show-receive-view-button').addEventListener('click', () => { resetViewInputs('receive-view'); showView('receive-view'); });
            document.getElementById('show-send-view-button').addEventListener('click', () => { resetViewInputs('send-view'); showView('send-view'); });

            document.getElementById('create-request-qr-button').addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('request-amount-input').value);
                if (isNaN(amount) || amount <= 0) { document.getElementById('receive-status').innerHTML = '<span class="error">Please enter a valid amount.</span>'; return; }
                const request = WalletLogic.createPaymentRequest(amount);
                
                document.getElementById('qr-display-title').textContent = 'Payment Request';
                document.getElementById('qr-display-instruction').textContent = `Show this QR to the sender to pay $${amount.toFixed(2)}.`;
                document.getElementById('qr-display-box').style.display = 'block';
                generateQrCode(request, 'qr-display-box');

                document.getElementById('waiting-on-payment').style.display = 'block';
                const statusMsg = document.getElementById('final-status-message');
                statusMsg.innerHTML = '<span class="info">Waiting for sender to pay...</span>';
                showView('qr-display-view');
                
                state.activePollingTimer = setInterval(async () => {
                    try {
                        const confirmation = await PinataLedger.findConfirmation(request.linkedTxHash);
                        if (confirmation) {
                            clearInterval(state.activePollingTimer);
                            state.activePollingTimer = null;
                            statusMsg.innerHTML = '<span class="info">Payment detected! Finalizing...</span>';
                            const success = await WalletLogic.finalizePayment(confirmation);
                            if (success) {
                                statusMsg.innerHTML = `<span class="success">Success! $${Number(confirmation.amount).toFixed(2)} received.</span>`;
                                document.querySelector('#waiting-on-payment .loader').style.display = 'none';
                                updateBalanceDisplay();
                            } else {
                               statusMsg.innerHTML = `<span class="error">Failed to finalize payment. Invalid receipt.</span>`;
                            }
                        }
                    } catch (err) {
                        console.error("Polling error:", err);
                        statusMsg.innerHTML = `<span class="error">Network error while checking for payment.</span>`;
                        clearInterval(state.activePollingTimer);
                        state.activePollingTimer = null;
                    }
                }, AppConstants.POLLING_INTERVAL);
            });

            document.getElementById('scan-payment-request-input').addEventListener('change', async (event) => {
                const file = event.target.files[0]; if (!file) return;
                const statusEl = document.getElementById('send-status');
                statusEl.innerHTML = '<span class="info">Processing QR code...</span>';
                try {
                    const request = await decodeQrFromFile(file);
                    if (request.type !== 'AURA_PAYMENT_REQUEST' || !request.amount || !request.receiverAddress) throw new Error("Not a valid payment request QR.");
                    if (await PinataLedger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been paid.");
                    state.activePaymentRequest = request;
                    document.getElementById('confirm-amount-display').textContent = `$${request.amount.toFixed(2)}`;
                    document.getElementById('confirm-recipient-address-display').textContent = request.receiverAddress;
                    showView('send-confirm-view');
                } catch (err) { statusEl.innerHTML = `<span class="error">${err.message}</span>`; } finally { event.target.value = ''; }
            });

            document.getElementById('confirm-payment-button').addEventListener('click', async (event) => {
                const button = event.target, statusEl = document.getElementById('send-confirm-status');
                if (!state.activePaymentRequest) { statusEl.innerHTML = '<span class="error">No active payment request.</span>'; return; }
                button.disabled = true; statusEl.innerHTML = '<span class="info">Processing payment and publishing receipt to ledger...</span>';
                try {
                    await WalletLogic.processPayment(state.activePaymentRequest);
                    updateBalanceDisplay();
                    alert(`Payment of $${state.activePaymentRequest.amount.toFixed(2)} was sent successfully!`);
                    state.activePaymentRequest = null;
                    showView('wallet-view');
                } catch (err) { statusEl.innerHTML = `<span class="error">Payment Failed: ${err.message}</span>`; } finally { button.disabled = false; }
            });
            
            // --- BANKNOTE CHARGING (Unchanged) ---
            document.getElementById('show-charge-view-button').addEventListener('click', () => { resetViewInputs('charge-view'); document.getElementById('banknote-image-input').disabled = true; document.getElementById('public-key-input').value = ''; document.getElementById('charge-confirmation').style.display = 'none'; const confirmBtn = document.getElementById('confirm-charge-button'); confirmBtn.disabled = false; confirmBtn.removeAttribute('data-amount'); confirmBtn.removeAttribute('data-serial'); showView('charge-view'); });
            document.getElementById('confirm-charge-button').addEventListener('click', async (event) => { const button = event.target; button.disabled = true; const amount = parseFloat(button.dataset.amount), serial = button.dataset.serial; if (isNaN(amount) || !serial) { alert("An error occurred."); showView('wallet-view'); return; } const success = await PinataLedger.recordSpentIdentifier(serial, 'banknote'); if (!success) { alert("Failed to record banknote on public ledger."); showView('wallet-view'); return; } WalletLogic.addToChain({ type: 'charge', amount: amount, serial: serial, status: 'completed' }); updateBalanceDisplay(); alert(`$${amount.toFixed(2)} added successfully.`); showView('wallet-view'); });
            document.getElementById('public-key-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const keyStatus = document.getElementById('key-status'); keyStatus.innerHTML = '<span class="info">Processing key...</span>'; document.getElementById('banknote-image-input').disabled = true; state.masterPublicKey = null; try { const keyData = JSON.parse(await file.text()); if (!keyData.masterPublicKey) throw new Error("JSON file is missing 'masterPublicKey'."); state.masterPublicKey = CoreLogic.Utils.base64ToUint8Array(keyData.masterPublicKey); keyStatus.innerHTML = '<span class="success">Public key loaded.</span>'; document.getElementById('banknote-image-input').disabled = false; } catch (err) { keyStatus.innerHTML = `<span class="error">Error: ${err.message}</span>`; } });
            document.getElementById('banknote-image-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file) return; const statusEl = document.getElementById('validation-status'); const confirmSection = document.getElementById('charge-confirmation'); confirmSection.style.display = 'none'; if (!state.masterPublicKey) { statusEl.innerHTML = '<span class="error">Please load the bank\'s public key first.</span>'; return; } statusEl.innerHTML = '<span class="info">Preparing image...</span>'; try { const resizedDataUrl = await CoreLogic.Utils.resizeImage(file, CoreLogic.Constants.MAX_IMAGE_DIMENSION); const processedDataUrl = await CoreLogic.Utils.preprocessImage(resizedDataUrl); const imageData = await new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas');c.width=i.width;c.height=i.height;const x=c.getContext('2d');x.drawImage(i,0,0);res(x.getImageData(0,0,i.width,i.height));}; i.onerror=rej; i.src=processedDataUrl; }); const payload = await CoreLogic.Banknote.decodeQrGrid(imageData, statusEl); statusEl.innerHTML = '<span class="info">Scan complete. Verifying signatures...</span>'; const banknoteData = CoreLogic.Banknote.parsePayload(payload); if (await PinataLedger.hasBeenSpent(banknoteData.serial)) { throw new Error("This banknote has already been spent."); } const isSigOneValid = await CoreLogic.Crypto.verifySignature(banknoteData.signatureOne, CoreLogic.Banknote.getStandardizedDataForSigning(banknoteData), banknoteData.ephemeralPublicKey, state.falconApi); if (!isSigOneValid) throw new Error("Signature validation failed (internal)."); const isSigTwoValid = await CoreLogic.Crypto.verifySignature(banknoteData.signatureTwo, CoreLogic.Banknote.getStandardizedDataForMasterSig(banknoteData), state.masterPublicKey, state.falconApi); if (!isSigTwoValid) throw new Error("Signature validation failed (issuer)."); statusEl.innerHTML = '<span class="success">Banknote is valid!</span>'; document.getElementById('validated-amount').textContent = `$${banknoteData.amount.toFixed(2)}`; const confirmBtn = document.getElementById('confirm-charge-button'); confirmBtn.dataset.amount = banknoteData.amount; confirmBtn.dataset.serial = banknoteData.serial; confirmSection.style.display = 'block'; } catch (err) { statusEl.innerHTML = `<span class="error">Validation Failed: ${err.message}</span>`; } finally { event.target.value = ''; } });
        }
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

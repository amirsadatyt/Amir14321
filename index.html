<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root { --primary-color: #4b6cb7; --secondary-color: #182848; --danger-color: #d9534f; --light-gray: #f0f2f5; --dark-gray: #6c757d; }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        .view { display: none; }
        .view.active { display: block; }
        .card { background-color: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--primary-color); }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; }
        textarea { resize: vertical; height: 80px; }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: white; border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s; }
        button:hover { opacity: 0.9; transform: translateY(-2px); }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0); }
        .back-button { background: var(--dark-gray); margin-top: 10px; }
        .logout-button { background: var(--danger-color); margin-top: 10px; }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer; padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px; word-wrap: break-word; }
        .error { color: #d93025; } .success { color: #1e8e3e; } .info { color: #007bff; }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px; margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px; }
        #my-qr-code img, #qr-display-box img { margin: 15px auto; display: block; border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block; margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px; }
        label.qr-upload-label:hover { background-color: #f9f9f9; }
        input[type="file"] { display: none; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; margin: 10px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .toggle-buttons { display: flex; justify-content: center; margin-bottom: 20px; }
        .toggle-buttons button { width: 50%; border-radius: 0; }
        .toggle-buttons button.active { background: var(--primary-color); }
        .pane { display: none; }
        .pane.active { display: block; }
    </style>
</head>
<body>

    <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
    
    <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><div class="loader" id="create-loader"></div><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>

    <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>

    <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><div class="loader" id="restore-loader"></div><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-from-restore">Back</button></div></div>
    
    <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><div class="loader" id="login-loader"></div><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>
    
    <div id="wallet-view" class="view"><div class="card"><h2>Your Wallet</h2><p>Balance:</p><h1 id="balance-display">$0.00</h1><p id="network-status" style="font-size: 12px; color: #1e8e3e;">Ledger: Pinata IPFS</p><button id="show-charge-view-button">Charge with Banknote</button><button id="show-transfer-view-button" style="margin-top:10px;">Send / Receive</button><button id="logout-button" class="logout-button">Logout (Lock Wallet)</button></div></div>
    
    <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Load Bank's Public Key</h3><label for="public-key-input" class="qr-upload-label">Upload Public Key File (.json)</label><input type="file" id="public-key-input" accept=".json"><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" style="display:none; margin-top: 20px;"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back to Wallet</button></div></div>
    
    <div id="transfer-view" class="view"><div class="card">
        <h2>Send / Receive</h2>
        <div class="toggle-buttons">
            <button id="show-request-pane-btn" class="active">Request Payment</button>
            <button id="show-pay-pane-btn">Scan & Pay</button>
        </div>

        <div id="request-pane" class="pane active">
            <h3>Step 1: Create a Payment Request</h3>
            <input type="number" id="request-amount-input" placeholder="Amount to Request">
            <button id="generate-request-qr-btn">Generate Request QR Code</button>
            <div id="request-qr-display" style="margin-top: 15px;"></div>
            <p style="font-size: 12px; color: #666;">Show this QR code to the sender.</p>
        </div>

        <div id="pay-pane" class="pane">
            <h3>Scan a QR Code</h3>
            <label for="scan-qr-input" class="qr-upload-label">Upload QR Code Image to Scan</label>
            <input type="file" id="scan-qr-input" accept="image/*">
            <div id="scan-status" class="status-box">Awaiting QR code...</div>
        </div>

        <button class="back-button" id="back-from-transfer">Back to Wallet</button>
    </div></div>
    
    <div id="payment-confirm-modal" class="view" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); justify-content: center; align-items: center;">
        <div class="card">
            <h2>Confirm Payment</h2>
            <p>You are about to send:</p>
            <h1 id="confirm-payment-amount" style="color: var(--primary-color);"></h1>
            <p>To address:</p>
            <p id="confirm-payment-address" style="font-size: 12px; word-wrap: break-word;"></p>
            <button id="confirm-payment-btn">Confirm & Create Proof</button>
            <button id="cancel-payment-btn" class="back-button">Cancel</button>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    
    <script type="module">
        import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.1/dist/ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

        // CoreLogic and PinataLedger remain unchanged...
        const CoreLogic = (() => {
            const Constants = { VALIDATION_PREFIX: "SADAT_V2_PART", MAX_IMAGE_DIMENSION: 2000, NUM_QR_CODES: 9 };
            const Utils = {
                arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))),
                base64ToUint8Array: (s) => { const bs=atob(s); const b=new Uint8Array(bs.length); for(let i=0;i<bs.length;i++)b[i]=bs.charCodeAt(i); return b; },
                hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))),
                preprocessImage: (d) => new Promise((res, rej) => { const i=new Image(); i.onload=()=>{ const c=document.createElement('canvas'); c.width=i.width; c.height=i.height; const x=c.getContext('2d'); x.filter='grayscale(1) contrast(2.5) brightness(1.1)'; x.drawImage(i,0,0); res(c.toDataURL('image/jpeg')); }; i.onerror=rej; i.src=d; }),
                resizeImage: (f, m) => new Promise((res, rej) => { const r=new FileReader();r.onload=e=>{const i=new Image();i.onload=()=>{const c=document.createElement('canvas');let{width:w,height:h}=i;if(w>h){if(w>m){h*=m/w;w=m;}}else{if(h>m){w*=m/h;h=m;}}c.width=w;c.height=h;c.getContext('2d').drawImage(i,0,0,w,h);res(c.toDataURL('image/jpeg'));};i.onerror=rej;i.src=e.target.result;};r.onerror=rej;r.readAsDataURL(f);}),
            };
            const Crypto = {
                hashMessageForSigning: (m) => Utils.hexToUint8Array(shake256(m, 1536)),
                async verifySignature(sig, data, pk, api) { const h=this.hashMessageForSigning(data); return api.verify(sig, h, pk); }
            };
            const Banknote = {
                getStandardizedDataForSigning: (d) => JSON.stringify({timestamp:d.timestamp,serial:d.serial},['timestamp','serial']),
                getStandardizedDataForMasterSig: (d) => { const t={ephemeralPublicKey:Utils.arrayBufferToBase64(d.ephemeralPublicKey),signatureOne:Utils.arrayBufferToBase64(d.signatureOne)}; return JSON.stringify(t, Object.keys(t).sort()); },
                parsePayload: (b64) => { const c=Utils.base64ToUint8Array(b64); const j=pako.inflate(c,{to:'string'}); const p=JSON.parse(j); return {amount:p.a,serial:p.s,timestamp:p.t,ephemeralPublicKey:Utils.base64ToUint8Array(p.epk),signatureOne:Utils.base64ToUint8Array(p.s1),signatureTwo:Utils.base64ToUint8Array(p.s2)}; },
                getLayout: (w) => { const s=790; const c=w/s; return {qrSize:Math.round(250*c),xSpacing:Math.round(20*c),ySpacing:Math.round(20*c)}; },
                decodeQrGrid: async (imgData, statusEl) => {
                    const l=Banknote.getLayout(imgData.width);
                    const parts={}; let count=0; const c=document.createElement('canvas'); const x=c.getContext('2d'); c.width=imgData.width;c.height=imgData.height;x.putImageData(imgData,0,0);
                    for(let i=0;i<Constants.NUM_QR_CODES;i++){
                        statusEl.innerHTML=`<span class="info">Scanning section ${i+1}/${Constants.NUM_QR_CODES}...</span>`;
                        await new Promise(r=>setTimeout(r,5));
                        const row=Math.floor(i/3),col=i%3,rX=col*(l.qrSize+l.xSpacing),rY=row*(l.qrSize+l.ySpacing),d=x.getImageData(rX,rY,l.qrSize,l.qrSize); const code=jsQR(d.data,d.width,d.height);
                        if(code&&code.data.startsWith(Constants.VALIDATION_PREFIX)){const m=code.data.substring(Constants.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s); if(m){const pN=parseInt(m[1],10);if(!parts[pN]){parts[pN]=m[3];count++;}}}
                    }
                    if(count<Constants.NUM_QR_CODES){throw new Error(`Scan failed. Found ${count}/${Constants.NUM_QR_CODES} sections.`);}
                    let payload='';
                    for(let i=1;i<=Constants.NUM_QR_CODES;i++){payload+=parts[i];} return payload;
                }
            };
            return { Constants, Utils, Crypto, Banknote };
        })();
        const PinataLedger = (() => {
            const SUPABASE_FUNCTION_URL = 'https://hoppdalxbmktxexylbkl.supabase.co/functions/v1/quick-responder';
            const handleApiError = async (response) => {
                const rawText = await response.text();
                try { const jsonError = JSON.parse(rawText); return jsonError.error || rawText; } catch { return rawText; }
            };
            const recordSpentIdentifier = async (identifier, type) => {
                try {
                    const response = await fetch(SUPABASE_FUNCTION_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ identifier, type }) });
                    if (!response.ok) throw new Error(await handleApiError(response));
                    return true;
                } catch (error) { alert(`Ledger Write Error: ${error.message}`); return false; }
            };
            const hasBeenSpent = async (identifier) => {
                try {
                    const url = new URL(SUPABASE_FUNCTION_URL); url.searchParams.append('identifier', identifier);
                    const response = await fetch(url.toString(), { method: 'GET' });
                    if (!response.ok) throw new Error(await handleApiError(response));
                    const result = await response.json(); return result.spent;
                } catch (error) { alert(`Ledger Read Error: ${error.message}`); return true; }
            };
            return { recordSpentIdentifier, hasBeenSpent };
        })();
        
        // WalletLogic and App State are heavily modified for the new flow...
        const AppConstants = { MAX_LOGIN_ATTEMPTS: 5, LOGIN_LOCKOUT_PERIOD: 30000 };
        let state = { wallet: null, masterPublicKey: null, userStore: null, falconApi: null, failedLoginAttempts: 0, isLockedOut: false };
        const WalletLogic = {
            createWallet: (password) => {
                const wallet = ethers.Wallet.createRandom();
                const mnemonic = wallet.mnemonic.phrase;
                const encryptedJson = wallet.encryptSync(password);
                const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now(), status: 'completed' }] };
                localStorage.setItem('aura_user_store', JSON.stringify(userStore));
                state.userStore = userStore;
                state.wallet = wallet;
                return { mnemonic };
            },
            restoreWallet: async (mnemonic, password) => {
                try {
                    const wallet = ethers.Wallet.fromPhrase(mnemonic);
                    const encryptedJson = wallet.encryptSync(password);
                    const userStore = { publicKey: wallet.publicKey, address: wallet.address, encryptedJson: encryptedJson, chain: [{ hash: ethers.id("GENESIS_BLOCK"), type: 'creation', timestamp: Date.now(), status: 'completed' }] };
                    localStorage.setItem('aura_user_store', JSON.stringify(userStore));
                    state.userStore = userStore;
                    state.wallet = wallet;
                    return true;
                } catch (e) { return false; }
            },
            login: async (password) => {
                const userStoreJson = localStorage.getItem('aura_user_store');
                if (!userStoreJson) return null;
                try {
                    const reloadedUserStore = JSON.parse(userStoreJson);
                    const wallet = await ethers.Wallet.fromEncryptedJson(reloadedUserStore.encryptedJson, password);
                    state.userStore = reloadedUserStore;
                    state.wallet = wallet;
                    state.failedLoginAttempts = 0;
                    return true;
                } catch (e) { state.failedLoginAttempts++; return false; }
            },
            logout: () => { state.wallet = null; state.userStore = null; },
            getLastTransaction: () => state.userStore.chain[state.userStore.chain.length - 1],
            addToChain: (txData) => {
                const prevTx = WalletLogic.getLastTransaction();
                const newTx = { ...txData, prevHash: prevTx.hash, timestamp: Date.now() };
                newTx.hash = ethers.solidityPackedKeccak256(['string', 'uint256', 'string', 'string', 'string'], [newTx.type, newTx.amount || 0, newTx.from || '', newTx.to || '', newTx.prevHash]);
                state.userStore.chain.push(newTx);
                localStorage.setItem('aura_user_store', JSON.stringify(state.userStore));
                return newTx;
            },
            updateTransactionStatus: (txHash, newStatus) => {
                const txIndex = state.userStore.chain.findIndex(tx => tx.hash === txHash);
                if (txIndex !== -1) {
                    state.userStore.chain[txIndex].status = newStatus;
                    localStorage.setItem('aura_user_store', JSON.stringify(state.userStore));
                }
            },
            calculateBalance: () => {
                if (!state.userStore) return 0.0;
                return state.userStore.chain.reduce((balance, tx) => {
                    if (tx.status !== 'completed') return balance;
                    if ((tx.type === 'charge' || tx.type === 'receive') && tx.to === state.userStore.address) return balance + (tx.amount || 0);
                    if (tx.type === 'send' && tx.from === state.userStore.address) return balance - (tx.amount || 0);
                    return balance;
                }, 0);
            },
            reconcilePendingCharges: async () => {
                if (!state.userStore || !state.userStore.chain) return;
                const pendingCharges = state.userStore.chain.filter(tx => tx.type === 'charge' && tx.status === 'pending');
                if (pendingCharges.length > 0) {
                    alert(`Reconciling ${pendingCharges.length} incomplete transaction(s)...`);
                    for (const tx of pendingCharges) {
                        const isSpent = await PinataLedger.hasBeenSpent(tx.serial);
                        WalletLogic.updateTransactionStatus(tx.hash, isSpent ? 'completed' : 'failed');
                    }
                    await WalletLogic.backupUserStore();
                    alert('Recovery complete.');
                }
            },
            _getBackupEndpoint: () => 'https://hoppdalxbmktxexylbkl.supabase.co/functions/v1/user-store-backup',
            _getEncryptionKey: (password) => CryptoJS.SHA256(password).toString(),
            backupUserStore: async () => { /* Remains unchanged */ },
            restoreUserStore: async (address, password) => { /* Remains unchanged */ }
        };

        function showView(id) { document.querySelectorAll('.view').forEach(v => v.classList.remove('active')); document.getElementById(id).classList.add('active'); }
        function updateBalanceDisplay() { document.getElementById('balance-display').textContent = `$${WalletLogic.calculateBalance().toFixed(2)}`; }
        function generateQrCode(data, containerId) {
            const container = document.getElementById(containerId); container.innerHTML = ''; const qr = qrcode(0, 'L'); qr.addData(JSON.stringify(data)); qr.make(); container.innerHTML = qr.createImgTag(6, 10);
        }
        async function decodeQrFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => {
                    const image = new Image();
                    image.onload = () => {
                        const canvas = document.createElement('canvas'); canvas.width = image.width; canvas.height = image.height; const ctx = canvas.getContext('2d'); ctx.drawImage(image, 0, 0); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const code = jsQR(imageData.data, imageData.width, imageData.height);
                        if (code) { try { resolve(JSON.parse(code.data)); } catch { reject(new Error("Invalid QR data.")); } } else { reject(new Error("QR Code not found.")); }
                    };
                    image.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        async function initializeApp() {
            try { state.falconApi = await pqcSignFalcon1024(); } catch (e) { alert(`Fatal Error: ${e.message}`); return; }
            if (localStorage.getItem('aura_user_store')) { showView('login-view'); } else { showView('onboarding-view'); }
            setupEventListeners();
        }

        // --- Simplified Event Listeners ---
        function setupEventListeners() {
            // Onboarding, Login, Restore listeners remain the same...
            document.getElementById('go-to-create-wallet').addEventListener('click', () => showView('create-wallet-view'));
            document.getElementById('go-to-restore-wallet').addEventListener('click', () => showView('restore-wallet-view'));
            document.getElementById('create-wallet-button').addEventListener('click', () => { /* ... */ });
            document.getElementById('seed-phrase-confirm-button').addEventListener('click', () => { updateBalanceDisplay(); showView('wallet-view'); });
            document.getElementById('restore-wallet-button').addEventListener('click', async () => { /* ... */ });
            document.getElementById('login-button').addEventListener('click', async () => {
                const pass = document.getElementById('login-password-input').value.trim();
                const success = await WalletLogic.login(pass);
                if (success) {
                    await WalletLogic.reconcilePendingCharges();
                    updateBalanceDisplay();
                    showView('wallet-view');
                } else { /* ... error handling ... */ }
            });
            document.getElementById('logout-button').addEventListener('click', () => { WalletLogic.logout(); showView('login-view'); });
            document.getElementById('reset-app-button').addEventListener('click', () => { if (confirm('Erase all data?')) { localStorage.removeItem('aura_user_store'); location.reload(); }});
            document.getElementById('back-from-create').addEventListener('click', () => showView('onboarding-view'));
            document.getElementById('back-from-restore').addEventListener('click', () => showView('onboarding-view'));

            // Main navigation
            document.getElementById('show-charge-view-button').addEventListener('click', () => showView('charge-view'));
            document.getElementById('show-transfer-view-button').addEventListener('click', () => showView('transfer-view'));
            document.getElementById('back-from-charge').addEventListener('click', () => showView('wallet-view'));
            document.getElementById('back-from-transfer').addEventListener('click', () => showView('wallet-view'));
            
            // Banknote Charging listeners remain the same...
            document.getElementById('public-key-input').addEventListener('change', async (event) => { /* ... */ });
            document.getElementById('banknote-image-input').addEventListener('change', async (event) => { /* ... */ });
            document.getElementById('confirm-charge-button').addEventListener('click', async (event) => { /* ... */ });

            // --- NEW EVENT LISTENERS FOR UNIFIED TRANSFER VIEW ---

            // Tab switching
            const requestPane = document.getElementById('request-pane'), payPane = document.getElementById('pay-pane');
            const showRequestBtn = document.getElementById('show-request-pane-btn'), showPayBtn = document.getElementById('show-pay-pane-btn');
            showRequestBtn.addEventListener('click', () => {
                requestPane.classList.add('active'); payPane.classList.remove('active');
                showRequestBtn.classList.add('active'); showPayBtn.classList.remove('active');
            });
            showPayBtn.addEventListener('click', () => {
                payPane.classList.add('active'); requestPane.classList.remove('active');
                showPayBtn.classList.add('active'); showRequestBtn.classList.remove('active');
            });

            // 1. RECEIVER: Generate a Payment Request QR
            document.getElementById('generate-request-qr-btn').addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('request-amount-input').value);
                if (isNaN(amount) || amount <= 0) { alert("Please enter a valid amount."); return; }
                const requestPayload = {
                    type: "AURA_PAYMENT_REQUEST",
                    address: state.userStore.address,
                    amount: amount
                };
                generateQrCode(requestPayload, 'request-qr-display');
            });

            // 2. SENDER / RECEIVER: Main QR Code Scanner Logic
            document.getElementById('scan-qr-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const statusEl = document.getElementById('scan-status');
                statusEl.innerHTML = `<span class="info">Processing QR code...</span>`;
                try {
                    const decoded = await decodeQrFromFile(file);

                    // --- SENDER's ACTION: Scanned a Payment Request ---
                    if (decoded.type === "AURA_PAYMENT_REQUEST") {
                        if (WalletLogic.calculateBalance() < decoded.amount) {
                            throw new Error("Insufficient funds.");
                        }
                        document.getElementById('confirm-payment-amount').textContent = `$${decoded.amount.toFixed(2)}`;
                        document.getElementById('confirm-payment-address').textContent = decoded.address;
                        // Store data for the confirmation button
                        const confirmBtn = document.getElementById('confirm-payment-btn');
                        confirmBtn.dataset.address = decoded.address;
                        confirmBtn.dataset.amount = decoded.amount;
                        showView('payment-confirm-modal');
                    }
                    
                    // --- RECEIVER's ACTION: Scanned a Proof of Payment ---
                    else if (decoded.type === "AURA_PROOF_OF_PAYMENT") {
                        const { tx, signature } = decoded;
                        
                        // Verify the sender's signature
                        const message = JSON.stringify(tx);
                        const signerAddress = ethers.verifyMessage(message, signature);
                        if (signerAddress !== tx.from) throw new Error("Invalid sender signature.");

                        // Check ledger to prevent replay attacks
                        if (await PinataLedger.hasBeenSpent(tx.hash)) {
                            throw new Error("This transaction has already been processed.");
                        }

                        // All checks pass, finalize the receipt
                        WalletLogic.addToChain({ ...tx, type: 'receive', status: 'completed' });
                        await PinataLedger.recordSpentIdentifier(tx.hash, 'transaction');
                        await WalletLogic.backupUserStore();
                        
                        updateBalanceDisplay();
                        statusEl.innerHTML = `<span class="success">Successfully received $${tx.amount.toFixed(2)}!</span>`;
                        setTimeout(() => showView('wallet-view'), 2500);
                    }
                    
                    else {
                        throw new Error("Unknown QR code type.");
                    }
                } catch (err) {
                    statusEl.innerHTML = `<span class="error">${err.message}</span>`;
                } finally {
                    event.target.value = ''; // Reset file input
                }
            });

            // 3. SENDER: Confirms payment and generates the final Proof QR
            document.getElementById('confirm-payment-btn').addEventListener('click', async (event) => {
                const { address, amount } = event.target.dataset;
                
                // Create the transaction object
                const tx = {
                    from: state.userStore.address,
                    to: address,
                    amount: parseFloat(amount),
                };

                // Add to local chain first
                const localTx = WalletLogic.addToChain({ ...tx, type: 'send', status: 'completed' });
                
                // Create the signed proof for the receiver
                const proofOfPayment = {
                    type: "AURA_PROOF_OF_PAYMENT",
                    tx: { ...tx, hash: localTx.hash },
                    signature: await state.wallet.signMessage(JSON.stringify({ ...tx, hash: localTx.hash }))
                };
                
                await WalletLogic.backupUserStore();
                updateBalanceDisplay();

                // Display the final QR code for the receiver to scan
                showView('transfer-view');
                document.getElementById('scan-status').innerHTML = 'Transaction complete! Show this QR code to the receiver to finalize on their end.';
                generateQrCode(proofOfPayment, 'scan-status');
            });
            
            document.getElementById('cancel-payment-btn').addEventListener('click', () => {
                showView('transfer-view');
            });
        }
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Digital Banknote [Hybrid QR/JAB Code System]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="./qrcode.min.js" defer></script>
    <script src="./jsQR.js" defer></script>
    <script src="./jabcodeJSLib.min.js" defer></script>
    <script src="./pako.min.js" defer></script>
    <script src="./pqc-sign-falcon-1024.min.js" defer></script>
    <script src="./js-sha3.min.js" defer></script>
    
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1000px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        canvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); border: 1px solid var(--border-color); }
        #noteCanvas { width: 100%; max-width: 1000px; height: auto; }
        #keyTabCanvas { max-width: 500px; height: auto; margin-top: 10px; }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-right: -10px; }
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; }
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
        #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
        #qr-display img { max-width: 100%; height: auto; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Digital Banknote</h1>
    </div>

    <div class="section">
        <h2><span class="pill">Step 1</span> Master Keys</h2>
        <div class="controls-grid">
            <button id="generate-keys-button">🔑 Generate Master Key Pair</button>
            <label for="import-public-key" class="button sub-button">Load Public Key</label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
        </div>
         <div id="key-gen-status" class="status-box"></div>
    </div>

    <div class="section">
        <h2><span class="pill">Step 2</span> Reconstruct Private Key</h2>
        <div class="controls-grid">
              <label for="file-key-input" class="button sub-button">Upload File Key</label>
              <input type="file" id="file-key-input" accept=".json" style="display:none;" />
              <input type="password" id="password-key-input" placeholder="Password Key">
              <label for="visual-key-input" class="button sub-button">Upload Visual Key (QR)</label>
              <input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;" />
        </div>
        <button id="reconstruct-key-button" disabled style="margin-top: 20px;">🔓 Activate Master Private Key</button>
        <div id="key-reconstruction-status" class="status-box"></div>
    </div>

    <div class="section">
        <h2><span class="pill">Step 3</span> Generate Banknote & Key Tab</h2>
        <div class="controls-grid">
            <span class="input-label">Amount:</span>
            <input type="number" id="amount-input" value="50000">
            <button id="create-note-button" disabled>🎨 Generate New Pair</button>
        </div>
        <div id="banknote-status" class="status-box"></div>
        <canvas id="noteCanvas"></canvas>
        <canvas id="keyTabCanvas"></canvas>
        <button id="download-all-button" disabled>📥 Download Pair</button>
    </div>

    <div class="section" id="validator-section">
        <h2><span class="pill">Step 4</span> Validate (Two-Step Scan)</h2>
        <div class="controls-grid">
            <label for="validator-banknote-input" class="button">1. Scan Banknote</label>
            <input type="file" id="validator-banknote-input" accept="image/png" style="display: none;">
            <label for="validator-key-tab-input" id="validator-key-tab-label" class="button sub-button" disabled>2. Scan Key Tab</label>
            <input type="file" id="validator-key-tab-input" accept="image/png" style="display: none;">
        </div>
        <div id="validation-result" class="status-box"></div>
    </div>
</div>

<div id="qr-modal" class="modal">
  <div class="modal-content">
    <h2 id="qr-modal-title">Your Visual Key</h2>
    <div id="qr-display"></div>
    <button id="download-qr-button" style="margin-top: 15px;">💾 Download QR Code</button>
    <button onclick="document.getElementById('qr-modal').style.display='none'">Close</button>
  </div>
</div>

<script>
// This script now runs after all library scripts are loaded and parsed.
document.addEventListener('DOMContentLoaded', () => {

const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null,
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null },
    validationDataPart1: null
};

const Constants = {
    FALCON_PUBKEY_SIZE: 1793,
    EPOCH: new Date('2024-01-01T00:00:00Z').getTime()
};

const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadAllButton: document.getElementById('download-all-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    keyTabCanvas: document.getElementById('keyTabCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorBanknoteInput: document.getElementById('validator-banknote-input'),
    validatorKeyTabInput: document.getElementById('validator-key-tab-input'),
    validatorKeyTabLabel: document.getElementById('validator-key-tab-label'),
    validationResult: document.getElementById('validation-result'),
    qrModal: document.getElementById('qr-modal'),
    qrDisplay: document.getElementById('qr-display'),
    qrModalTitle: document.getElementById('qr-modal-title'),
    downloadQrButton: document.getElementById('download-qr-button')
};

const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes;
    },
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadCanvasAsPNG: async (canvas, filename) => {
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    log: (message, type = 'info') => {
        const icon = { info: 'ℹ️', success: '✅', warning: '⚠️', error: '❌' }[type];
        console.log(`[Sadat System] ${icon} ${message}`);
    }
};

const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_KEY_LENGTH = 32;

    async function pbkdf2DeriveKey(password, salt) {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw",passwordBuffer,{ name: "PBKDF2" },false,["deriveKey"]);
        return await crypto.subtle.deriveKey({name: "PBKDF2",salt: salt,iterations: PBKDF2_ITERATIONS,hash: "SHA-256"},importedKey,{ name: AES_ALGO, length: PBKDF2_KEY_LENGTH * 8 },false,["encrypt", "decrypt"]);
    }
    
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(sha3_256(message)); }

    return {
        async generateNewKeyPair() {
            if (!state.falconApi) throw new Error("Falcon API not initialized.");
            return state.falconApi.keypair();
        },
        async signData(data, privateKey) {
            if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        async verifySignature(signature, data, publicKey) {
            if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
            const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);

            const intermediatePayload = JSON.stringify({
                encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual),
                salt: Utils.arrayBufferToBase64(visualKeySalt),
                iv: Utils.arrayBufferToBase64(visualKeyIV)
            });

            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
            const passwordIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
            
            return {
                fileKey: {
                    cipherText: Utils.arrayBufferToBase64(finalEncryptedKey),
                    salt: Utils.arrayBufferToBase64(passwordSalt),
                    iv: Utils.arrayBufferToBase64(passwordIV)
                }
            };
        },
        async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
            const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
            const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
            const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
            const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
            const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
            const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);
            return new Uint8Array(masterPrivateKeyBytes);
        }
    };
})();

const UIHandlers = (() => {
    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = '';
        statusHtml += fileKey ? '<span class="valid">✅ File Key loaded.</span>\n' : '<span class="invalid">❌ File Key NOT loaded.</span>\n';
        statusHtml += passwordKey ? '<span class="valid">✅ Password Key entered.</span>\n' : '<span class="invalid">❌ Password Key NOT entered.</span>\n';
        statusHtml += visualKey ? '<span class="valid">✅ Visual Key scanned.</span>\n' : '<span class="invalid">❌ Visual Key NOT scanned.</span>\n';
        DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        const allPiecesProvided = fileKey && passwordKey && visualKey;
        DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
        if (allPiecesProvided) {
             Utils.updateStatus(DOMElements.keyReconstructionStatus, "⚠️ All pieces provided. Ready to activate.", 'warning');
        }
    }
    
    return {
        async handleGenerateAndExportKeys() {
            const password = prompt("Create a strong password for key encryption:");
            if (!password) {
                Utils.updateStatus(DOMElements.keyGenStatus, '❌ Key generation cancelled. Password is required.', 'error');
                return;
            }
            
            Utils.updateStatus(DOMElements.keyGenStatus, '⏳ Generating new Falcon-1024 key pair...', 'info');
            try {
                const keyPair = await BankCrypto.generateNewKeyPair();
                state.masterPublicKey = keyPair.publicKey;
                Utils.log("New Master Key Pair generated.", 'success');
                Utils.updateStatus(DOMElements.keyGenStatus, '⏳ Creating puzzle pieces and encrypting private key...', 'info');
                const visualKeySecret = crypto.randomUUID();
                const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
                const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
                Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
                Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
                
                DOMElements.qrModalTitle.innerText = "Your Visual Key (Piece 3/3)";
                DOMElements.qrDisplay.innerHTML = '';
                const qrCodeDataURL = await QRCode.toDataURL(visualKeySecret, { errorCorrectionLevel: 'H', width: 256 });
                const img = new Image();
                img.src = qrCodeDataURL;
                DOMElements.qrDisplay.appendChild(img);
                DOMElements.qrModal.style.display = 'flex';

                Utils.updateStatus(DOMElements.keyGenStatus, `✅ Key pair generated. Public key is active. Key files and QR code have been downloaded.`, 'success');

            } catch (e) {
                Utils.log(`Key generation failed: ${e.message}`, 'error');
                Utils.updateStatus(DOMElements.keyGenStatus, `❌ Failed to generate keys: ${e.message}`, 'error');
            }
        },
        handleImportPublicKey: async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("Invalid public key file format."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, '✅ Public key imported. Ready to validate banknotes.', 'success'); } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `❌ Error importing public key: ${error.message}`, 'error'); } event.target.value = ''; },
        handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("File Key loaded.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`Failed to load File Key: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; },
        handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus(); },
        
        handleVisualKeyInput: (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);
                        
                        if (code && code.data) {
                            state.puzzlePieces.visualKey = code.data;
                            Utils.log("Visual Key loaded from QR Code.", 'success');
                        } else {
                             state.puzzlePieces.visualKey = null;
                             Utils.log("Failed to find a QR Code in the image.", 'error');
                        }
                    } catch (err) {
                        state.puzzlePieces.visualKey = null;
                        Utils.log(`Error scanning QR Code: ${err}`, 'error');
                    } finally {
                        updatePuzzleStatus();
                    }
                };
                img.onerror = () => {
                     Utils.log("Could not load image file to scan for QR Code.", 'error');
                     state.puzzlePieces.visualKey = null;
                     updatePuzzleStatus();
                };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                Utils.log("Could not read file.", 'error');
                state.puzzlePieces.visualKey = null;
                updatePuzzleStatus();
            };
            reader.readAsDataURL(file);
        },

        handleReconstructKey: async () => { 
            const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
            if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "❌ All three puzzle pieces are required.", 'error'); return; }
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "⏳ Reconstructing Master Private Key...", 'info');
            try {
                state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey);
                Utils.updateStatus(DOMElements.keyReconstructionStatus, "✅ Master Private Key ACTIVE. You can now create banknotes.", 'success');
                DOMElements.createNoteButton.disabled = false;
            } catch (error) {
                console.error(error); Utils.updateStatus(DOMElements.keyReconstructionStatus, "❌ Failed to reconstruct key. Check puzzle pieces and password.", 'error');
                state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true;
            } 
        },
    };
})();

const BanknoteLogic = (() => {
    // ... Helper functions like getStandardizedDataForSigning have no changes
    const getStandardizedDataForSigning = (noteData) => JSON.stringify({
        timestamp: noteData.timestamp,
        serial: noteData.serial,
    }, ['timestamp', 'serial']);

    const getStandardizedDataForMasterSig = (noteData) => {
        const tempNoteData = {
            ephemeralPublicKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
            signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne)
        };
        return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
    };
    
    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("Master Private Key is not active.");
        const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
        
        const noteData = {
            amount: parseInt(amount) || 0,
            serial: Math.random().toString(36).substring(2, 10).toUpperCase(),
            timestamp: Math.floor((Date.now() - Constants.EPOCH) / 1000),
            verificationKey: Math.random().toString(36).substring(2, 10).toUpperCase(),
            ephemeralPublicKey: ephemeralKeyPair.publicKey,
            signatureOne: null,
            signatureTwo: null
        };
        
        const dataForSigOne = getStandardizedDataForSigning(noteData);
        noteData.signatureOne = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
        const dataForSigTwo = getStandardizedDataForMasterSig(noteData);
        noteData.signatureTwo = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
        return noteData;
    };
    
    const createBinaryPayloads = (noteData) => {
        const textEncoder = new TextEncoder();
        
        // Payload 1: Metadata + Signatures
        const sigOneLen = noteData.signatureOne.length;
        const sigTwoLen = noteData.signatureTwo.length;
        const buffer1Size = 4 + 8 + 4 + 8 + 2 + sigOneLen + 2 + sigTwoLen;
        const buffer1 = new ArrayBuffer(buffer1Size);
        const view1 = new DataView(buffer1);
        let offset1 = 0;

        view1.setUint32(offset1, noteData.amount, false); offset1 += 4;
        new Uint8Array(buffer1, offset1).set(textEncoder.encode(noteData.verificationKey)); offset1 += 8;
        view1.setUint32(offset1, noteData.timestamp, false); offset1 += 4;
        new Uint8Array(buffer1, offset1).set(textEncoder.encode(noteData.serial)); offset1 += 8;
        view1.setUint16(offset1, sigOneLen, false); offset1 += 2;
        new Uint8Array(buffer1, offset1).set(noteData.signatureOne); offset1 += sigOneLen;
        view1.setUint16(offset1, sigTwoLen, false); offset1 += 2;
        new Uint8Array(buffer1, offset1).set(noteData.signatureTwo);

        // Payload 2: Just the large public key
        const payload2Bytes = noteData.ephemeralPublicKey;

        return { payload1Bytes: new Uint8Array(buffer1), payload2Bytes };
    };

    const parseBinaryPayloads = (payload1Bytes, payload2Bytes) => {
        const view1 = new DataView(payload1Bytes.buffer, payload1Bytes.byteOffset, payload1Bytes.byteLength);
        const textDecoder = new TextDecoder();
        let offset1 = 0;

        const amount = view1.getUint32(offset1, false); offset1 += 4;
        const verificationKey = textDecoder.decode(payload1Bytes.subarray(offset1, offset1 + 8)); offset1 += 8;
        const timestamp = view1.getUint32(offset1, false); offset1 += 4;
        const serial = textDecoder.decode(payload1Bytes.subarray(offset1, offset1 + 8)); offset1 += 8;
        
        const sigOneLength = view1.getUint16(offset1, false); offset1 += 2;
        const signatureOne = payload1Bytes.subarray(offset1, offset1 + sigOneLength); offset1 += sigOneLength;
        
        const sigTwoLength = view1.getUint16(offset1, false); offset1 += 2;
        const signatureTwo = payload1Bytes.subarray(offset1, offset1 + sigTwoLength);

        const ephemeralPublicKey = payload2Bytes;
        
        return { amount, verificationKey, timestamp, serial, ephemeralPublicKey, signatureOne, signatureTwo };
    };
    
    const handleCreateAndSignNotes = async () => {
        if (!state.masterPrivateKey) { alert("Master Private Key is not active."); return; }
        Utils.updateStatus(DOMElements.banknoteStatus, `⏳ Generating Banknote & Key Tab...`, 'info');
        try {
            const noteData = await createNoteData(DOMElements.amountInput.value);
            const { payload1Bytes, payload2Bytes } = createBinaryPayloads(noteData);

            const compressedPayload1 = pako.deflate(payload1Bytes);
            const finalPayload1 = Utils.arrayBufferToBase64(compressedPayload1);
            
            const compressedPayload2 = pako.deflate(payload2Bytes);
            const finalPayload2 = Utils.arrayBufferToBase64(compressedPayload2);

            await BanknoteDrawer.drawNoteOnCanvas(noteData, finalPayload1);
            await BanknoteDrawer.drawKeyTabOnCanvas(noteData, finalPayload2);

            Utils.updateStatus(DOMElements.banknoteStatus, `✅ New Banknote and Key Tab pair generated.`, 'success');
            DOMElements.downloadAllButton.disabled = false;
        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `❌ Error: ${error.message}`, 'error');
            console.error(error);
        }
    };

    const handleScanBanknote = async (event) => {
        const file = event.target.files[0];
        if (!file || !state.masterPublicKey) return;
        Utils.updateStatus(DOMElements.validationResult, '⏳ Scanning Banknote (Part 1/2)...', 'info');
        
        const qrCodeData = await scanQrCodeFromFile(file);
        if (!qrCodeData) {
            Utils.updateStatus(DOMElements.validationResult, '❌ Could not read QR code from Banknote image.', 'error');
            return;
        }

        state.validationDataPart1 = qrCodeData;
        Utils.updateStatus(DOMElements.validationResult, '✅ Banknote scan complete. Please scan the Key Tab to finalize.', 'success');
        DOMElements.validatorKeyTabLabel.disabled = false;
        DOMElements.validatorKeyTabLabel.classList.remove('sub-button');
    };

    const handleScanKeyTab = async (event) => {
        const file = event.target.files[0];
        if (!file || !state.validationDataPart1) return;
        Utils.updateStatus(DOMElements.validationResult, '⏳ Scanning Key Tab (Part 2/2)...', 'info');

        const qrCodeData = await scanQrCodeFromFile(file);
        if (!qrCodeData) {
            Utils.updateStatus(DOMElements.validationResult, '❌ Could not read QR code from Key Tab image.', 'error');
            return;
        }
        
        try {
            const compressedBytes1 = Utils.base64ToUint8Array(state.validationDataPart1);
            const originalPayloadBytes1 = pako.inflate(compressedBytes1);

            const compressedBytes2 = Utils.base64ToUint8Array(qrCodeData);
            const originalPayloadBytes2 = pako.inflate(compressedBytes2);
            
            let resultHTML = '<span class="valid">✅ Both parts scanned & decompressed. Verifying signatures...</span>\n';
            DOMElements.validationResult.innerHTML = resultHTML;

            const parsedData = parseBinaryPayloads(originalPayloadBytes1, originalPayloadBytes2);
            
            const dataForSigOne = getStandardizedDataForSigning(parsedData);
            const isSigOneValid = await BankCrypto.verifySignature(parsedData.signatureOne, dataForSigOne, parsedData.ephemeralPublicKey);
            if (!isSigOneValid) {
                resultHTML += '<span class="invalid">❌ Ephemeral Signature (Sig 1) INVALID.</span><br><span>❌ VERDICT: FORGERY</span>';
                DOMElements.validationResult.innerHTML = resultHTML;
                return;
            }
            resultHTML += '<span class="valid">✅ Ephemeral Signature (Sig 1) OK.</span>\n';

            const dataForSigTwo = getStandardizedDataForMasterSig(parsedData);
            const isSigTwoValid = await BankCrypto.verifySignature(parsedData.signatureTwo, dataForSigTwo, state.masterPublicKey);
            if (!isSigTwoValid) {
                resultHTML += '<span class="invalid">❌ Master Signature (Sig 2) INVALID.</span><br><span>❌ VERDICT: FORGERY</span>';
                DOMElements.validationResult.innerHTML = resultHTML;
                return;
            }
            resultHTML += `<span class="valid">✅ Master Signature (Sig 2) OK.</span>\n`;
            resultHTML += `<span class="info">ℹ️ Decoded Amount: ${parsedData.amount}, Key: ${parsedData.verificationKey}</span><br>`;
            resultHTML += `<span style="font-size:14px;font-weight:600;">✅ VERDICT: BANKNOTE IS AUTHENTIC</span>`;
            
            DOMElements.validationResult.innerHTML = resultHTML;

        } catch (e) {
            const errorMessage = e.message || e.toString();
            Utils.updateStatus(DOMElements.validationResult, `❌ Validation Error: ${errorMessage}.`, 'error');
            console.error(e);
        } finally {
            // Reset state for next validation
            state.validationDataPart1 = null;
            DOMElements.validatorKeyTabLabel.disabled = true;
            DOMElements.validatorKeyTabLabel.classList.add('sub-button');
            event.target.value = '';
        }
    };
    
    const scanQrCodeFromFile = (file) => {
        return new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    resolve(code ? code.data : null);
                };
                img.onerror = () => resolve(null);
                img.src = e.target.result;
            };
            reader.onerror = () => resolve(null);
            reader.readAsDataURL(file);
        });
    };

    return { handleCreateAndSignNotes, handleScanBanknote, handleScanKeyTab };
})();


const BanknoteDrawer = (() => {
    // ... (Helper functions have no changes)
    const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));
    function drawGuilloche(ctx, hash, w, h) { /* ... */ }
    function drawWatermark(ctx, hash, w, h) { /* ... */ }
    function drawNoise(ctx, hash, w, h) { /* ... */ }
    
    return {
        drawNoteOnCanvas: async (noteData, qrPayload) => {
            const canvas = DOMElements.noteCanvas;
            canvas.width = 1350;
            canvas.height = 750;
            const ctx = canvas.getContext("2d");
            const { amount, serial, verificationKey, signatureTwo } = noteData;
            canvas.dataset.serial = serial; // Store serial for download filename

            const visualHash = sha3_256(signatureTwo);
            const baseHue = H(visualHash, 0, 0, 360);
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
            bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGuilloche(ctx, visualHash, canvas.width, canvas.height);
            drawNoise(ctx, visualHash, canvas.width, canvas.height);

            ctx.fillStyle = "#EAEAEA";
            ctx.textAlign = 'left';
            ctx.font = `bold 80px 'Roboto Mono'`;
            ctx.fillText(serial, 150, 160);
            ctx.font = `bold 150px 'Roboto Mono'`;
            ctx.textAlign = "right";
            ctx.fillText(amount.toString(), canvas.width - 120, 190);

            try {
                const qrCodeDataURL = await QRCode.toDataURL(qrPayload, { errorCorrectionLevel: 'H', width: 380 });
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = qrCodeDataURL;
                });
                
                const qrX = canvas.width - 150 - 380;
                const qrY = canvas.height - 520;
                ctx.fillStyle = 'white';
                ctx.fillRect(qrX - 20, qrY - 20, 380 + 40, 380 + 40);
                ctx.drawImage(img, qrX, qrY, 380, 380);

            } catch (err) {
                console.error("QR Code Generation Error:", err);
                throw err;
            }
        },
        drawKeyTabOnCanvas: async (noteData, qrPayload) => {
            const canvas = DOMElements.keyTabCanvas;
            canvas.width = 500;
            canvas.height = 250;
            const ctx = canvas.getContext("2d");
            const { serial } = noteData;
            
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            try {
                const qrCodeDataURL = await QRCode.toDataURL(qrPayload, { errorCorrectionLevel: 'H', width: 200 });
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = qrCodeDataURL;
                });
                
                ctx.fillStyle = 'white';
                ctx.fillRect(20, 25, 200 + 10, 200);
                ctx.drawImage(img, 25, 25, 200, 200);

                ctx.fillStyle = '#EAEAEA';
                ctx.font = `bold 24px 'Roboto Mono'`;
                ctx.textAlign = 'left';
                ctx.fillText('KEY TAB', 260, 60);
                ctx.font = `20px 'Roboto Mono'`;
                ctx.fillText(`For Banknote:`, 260, 120);
                ctx.fillText(serial, 260, 150);

            } catch(err) {
                console.error("KeyTab QR Gen Error:", err);
                throw err;
            }
        }
    };
})();

async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, '⏳ Loading crypto modules...', 'info');
    if (typeof pqcSignFalcon1024 === 'undefined' || typeof sha3_256 === 'undefined') {
        Utils.updateStatus(DOMElements.keyGenStatus, `❌ Critical Error: A required library is missing. Please check file paths.`, 'error');
        return;
    }

    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.keyGenStatus, '✅ Modules loaded. You may now generate keys.', 'success');
        Utils.log("All cryptographic modules initialized successfully.", 'success');
    } catch (e) {
        Utils.log(`Critical Error: Could not load modules: ${e.message}`, 'error');
        Utils.updateStatus(DOMElements.keyGenStatus, `❌ Critical Error: Could not load modules. See console for details.`, 'error');
        return;
    }
    
    DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
    DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
    DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
    DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
    
    DOMElements.downloadAllButton.addEventListener('click', async () => {
        const noteCanvas = DOMElements.noteCanvas;
        const keyTabCanvas = DOMElements.keyTabCanvas;
        const serial = noteCanvas.dataset.serial || 'NOTE';
        await Utils.downloadCanvasAsPNG(noteCanvas, `BANKNOTE-${serial}.png`);
        await Utils.downloadCanvasAsPNG(keyTabCanvas, `KEY-TAB-${serial}.png`);
    });

    DOMElements.validatorBanknoteInput.addEventListener('change', BanknoteLogic.handleScanBanknote);
    DOMElements.validatorKeyTabInput.addEventListener('change', BanknoteLogic.handleScanKeyTab);
    
    DOMElements.downloadQrButton.addEventListener('click', () => {
        const img = DOMElements.qrDisplay.querySelector('img');
        if (img && img.src) {
            const a = document.createElement('a');
            a.href = img.src; a.download = 'Sadat-VISUAL-KEY.png';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
    });
}

main();

});
</script>
</body>
</html>

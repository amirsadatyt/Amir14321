<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote (JAB Code + Falcon-1024)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <!-- SHA3 library as classic script, before everything else -->
    <script src="https://cdn.jsdelivr.net/npm/js-sha3@0.9.3/build/sha3.min.js"></script>
    <!-- (Or use https://cdnjs.cloudflare.com/ajax/libs/js-sha3/0.8.0/sha3.min.js as in official docs) -->
    <style>
        /* ... (your CSS, unchanged) ... */
    </style>
</head>
<body>
<div class="container">
    <!-- ... (your HTML, unchanged) ... -->
</div>
<script type="module">
// Import cryptographic libraries as modules
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import JabcodeJSInterface from './jabcodeJSLib.min.js';

// --- Global State ---
const canvas = document.getElementById("noteCanvas");
const jabInterface = new JabcodeJSInterface();
let currentNoteData = {};
let activeKeys = { publicKey: null, privateKey: null };
let falconApi = null;
// --- Utility Functions ---
const arrayBufferToBase64 = (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer)));
const base64ToUint8Array = (base64) => {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes;
};
// Used by hashing
const hexToUint8Array = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
const uint8ArrayToHex = (bytes) =>
    Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');

// --- Robust SHAKE256 wrapper ---
// Falls back to subtleCrypto if js-sha3 is missing or broken
async function shake256(message, bits) {
    // Use js-sha3 if present and working
    if (typeof window !== "undefined" && window.sha3 && typeof window.sha3.shake256 === "function") {
        // js-sha3 shake256: output is hex string, bits must be multiple of 8
        const hex = window.sha3.shake256(message, bits);
        return hexToUint8Array(hex);
    }
    // Try subtleCrypto (SHAKE256, supported in modern browsers as of 2025)
    if (window.crypto && window.crypto.subtle && typeof window.crypto.subtle.digest === "function") {
        // subtleCrypto SHAKE256 returns ArrayBuffer; bits must be multiple of 8 here too
        const enc = new TextEncoder();
        const ab = await window.crypto.subtle.digest("SHAKE256", enc.encode(message));
        return new Uint8Array(ab).slice(0, bits / 8);
    }
    // Neither available
    throw new Error("No SHAKE256 implementation available (js-sha3 and subtleCrypto are missing).");
}

// ===================================================================================
// Bank Key Management and Falcon-1024 Crypto Logic
// ===================================================================================
const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_HASH_ALGO = "SHA-256";
    const AES_KEY_LENGTH = 256;

    // Will return a Uint8Array
    async function hashMessageForSigning(message) {
        return await shake256(message, 1536);
    }

    // Returns hex string (for visual embedding)
    async function hashMessageForVisual(message) {
        const hashBytes = await shake256(message, 256);
        return uint8ArrayToHex(hashBytes);
    }

    async function generateNewKeyPair() {
        if (!falconApi) throw new Error("Falcon API not initialized.");
        return await falconApi.keypair();
    }

    async function signData(data, privateKey) {
        if (!privateKey) throw new Error("Private key is not available for signing.");
        if (!falconApi) throw new Error("Falcon API not initialized.");
        const dataHash = await hashMessageForSigning(data);
        const { signature } = await falconApi.sign(dataHash, privateKey);
        return signature;
    }

    async function verifySignature(signature, data, publicKey) {
        if (!publicKey) throw new Error("Public key is not available for verification.");
        if (!falconApi) throw new Error("Falcon API not initialized.");
        const dataHash = await hashMessageForSigning(data);
        return await falconApi.verify(signature, dataHash, publicKey);
    }
    // ... (encrypt/decrypt unchanged) ...
    async function encryptPrivateKey(privateKeyBytes, password) {
        const passwordBuffer = new TextEncoder().encode(password);
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        const derivedKey = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
            keyMaterial, { name: AES_ALGO, length: AES_KEY_LENGTH }, true, ["encrypt", "decrypt"]
        );
        const keyObject = { keyData: arrayBufferToBase64(privateKeyBytes) };
        const encodedKey = new TextEncoder().encode(JSON.stringify(keyObject));
        const encryptedKey = await window.crypto.subtle.encrypt({ name: AES_ALGO, iv: iv }, derivedKey, encodedKey);
        return {
            cipherText: arrayBufferToBase64(encryptedKey),
            salt: arrayBufferToBase64(salt),
            iv: arrayBufferToBase64(iv)
        };
    }

    async function decryptPrivateKey(encryptedData, password) {
        const passwordBuffer = new TextEncoder().encode(password);
        const salt = base64ToUint8Array(encryptedData.salt);
        const iv = base64ToUint8Array(encryptedData.iv);
        const cipherText = base64ToUint8Array(encryptedData.cipherText);
        const keyMaterial = await window.crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        const derivedKey = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
            keyMaterial, { name: AES_ALGO, length: AES_KEY_LENGTH }, true, ["encrypt", "decrypt"]
        );
        const decryptedKeyBuffer = await window.crypto.subtle.decrypt({ name: AES_ALGO, iv: iv }, derivedKey, cipherText);
        const keyObject = JSON.parse(new TextDecoder().decode(decryptedKeyBuffer));
        return base64ToUint8Array(keyObject.keyData);
    }

    return { generateNewKeyPair, signData, verifySignature, encryptPrivateKey, decryptPrivateKey, hashMessageForVisual };
})();

function getStandardizedDataForSigning(noteData) {
    const dataToSign = { amount: noteData.amount, serial: noteData.serial, timestamp: noteData.timestamp, verificationKey: noteData.verificationKey };
    return JSON.stringify(dataToSign, Object.keys(dataToSign).sort());
}

/* ... (rest of your code is unchanged, except calls to hashMessageForSigning and hashMessageForVisual are now properly awaited as above) ... */

// ===================================================================================
// Application Initialization
// ===================================================================================
async function main() {
    // ... (event listeners unchanged) ...
    updateControlsState(false);
    updateKeyStatus('<span class="info">⏳ Loading Falcon-1024 Crypto Module...</span>');

    try {
        falconApi = await pqcSignFalcon1024();
        updateKeyStatus('<span class="info">Ready. Please generate a new key pair or import existing keys to begin.</span>');
    } catch (e) {
        console.error("Failed to load Falcon module:", e);
        updateKeyStatus(`<span class="invalid">❌ Critical Error: Could not load Falcon-1024 module. Please check that 'pqc-sign-falcon-1024.min.js' is in the same directory and your browser supports modern JavaScript.</span>`);
        alert("Error: Failed to load cryptographic module. See the console for details.");
        return;
    }
}

main();
</script>
</body>
</html>

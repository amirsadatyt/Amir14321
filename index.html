<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Post-Quantum Banknote (Hybrid Security)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 900px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        h1 { font-size: 2.5rem; font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas { border-radius: 16px; margin-top: 24px; background: #050508; width: 100%; max-width: 900px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; }
        button[disabled] { cursor: not-allowed; opacity: 0.5; }
        button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; }
        h2 { font-size: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #validation-result, #key-status { margin-top: 20px; font-size: 12px; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); }
        .valid { color: var(--success-color); }
        .invalid { color: var(--error-color); }
        .info { color: var(--info-color); }
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Sadat Post-Quantum Banknote</h1>
        <p>Hybrid Security: Ed25519 + Falcon-512 Signatures, SHAKE256 Hash, AES-GCM Key Storage</p>
    </div>

    <canvas id="noteCanvas" width="1350" height="750"></canvas>

    <div class="section">
        <h2>Banknote Controls</h2>
        <input type="number" id="amount-input" value="50000" title="Amount">
        <button id="create-note-button" disabled>🎨 Redesign Banknote</button>
    </div>

    <div class="section">
        <h2>Bank Key Management (Hybrid)</h2>
        <button id="generate-keys-button">🔑 Generate & Export Hybrid Keys</button>
        <label for="import-public-key">Import Public Key</label>
        <input type="file" id="import-public-key" accept=".json" style="display: none;">
        <label for="import-private-key">Import Encrypted Private Key</label>
        <input type="file" id="import-private-key" accept=".json" style="display: none;">
        <div id="key-status">Initializing...</div>
    </div>

    <div class="section">
        <h2>Validate Banknote</h2>
        <label for="validator-input">Select Image for Validation</label>
        <input type="file" id="validator-input" accept="image/png" style="display: none;">
        <div id="validation-result">Awaiting validation...</div>
    </div>
</div>

<script type="module">
    // ===================================================================================
    // MODULE IMPORTS
    // ===================================================================================
    import nacl from 'https://esm.sh/tweetnacl@1.0.3';
    import { shake256 } from 'https://esm.sh/js-sha3@0.9.3';
    // This imports the local Falcon-512 module. It requires falcon.js and the .wasm file.
    import pqcSignFalcon512 from './falcon.js';

    // ===================================================================================
    // GLOBAL STATE & DOM ELEMENTS
    // ===================================================================================
    const dom = {
        canvas: document.getElementById("noteCanvas"),
        amountInput: document.getElementById("amount-input"),
        createNoteButton: document.getElementById("create-note-button"),
        generateKeysButton: document.getElementById("generate-keys-button"),
        importPublicKey: document.getElementById("import-public-key"),
        importPrivateKey: document.getElementById("import-private-key"),
        validatorInput: document.getElementById("validator-input"),
        keyStatus: document.getElementById("key-status"),
        validationResult: document.getElementById("validation-result"),
    };

    let activeKeys = { publicKey: null, privateKey: null };
    let falconApi = null;

    // ===================================================================================
    // UTILITY FUNCTIONS
    // ===================================================================================
    const bytesToBase64 = (bytes) => btoa(String.fromCharCode(...bytes));
    const base64ToBytes = (base64) => Uint8Array.from(atob(base64), c => c.charCodeAt(0));
    const hexToBytes = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    const downloadFile = (data, filename, type) => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([data], { type }));
        a.download = filename;
        a.click();
    };
    
    // ===================================================================================
    // HYBRID CRYPTO MODULE (Ed25519 + Falcon-512 + SHAKE256)
    // ===================================================================================
    const BankCrypto = (() => {
        const AES_ALGO = "AES-GCM";
        const PBKDF2_ITERATIONS = 100000;
        const PBKDF2_HASH_ALGO = "SHA-256";

        const hashMessage = (message) => hexToBytes(shake256(message, 1024));

        async function generateNewKeyPair() {
            if (!falconApi) throw new Error("Falcon-512 module not loaded.");
            const ed25519 = nacl.sign.keyPair();
            const falcon = await falconApi.keypair();
            return {
                publicKey: { ed25519: ed25519.publicKey, falcon: falcon.publicKey },
                privateKey: { ed25519: ed25519.secretKey, falcon: falcon.privateKey }
            };
        }

        async function signData(data, privateKeys) {
            if (!privateKeys) throw new Error("Private keys not available.");
            const messageHash = hashMessage(data);
            const edSig = nacl.sign.detached(messageHash, privateKeys.ed25519);
            const { signature: falSig } = await falconApi.sign(messageHash, privateKeys.falcon);
            return { ed25519: edSig, falcon: falSig };
        }

        async function verifySignatures(signatures, data, publicKeys) {
            if (!publicKeys) throw new Error("Public keys not available.");
            const messageHash = hashMessage(data);
            const isEd25519Valid = nacl.sign.detached.verify(messageHash, signatures.ed25519, publicKeys.ed25519);
            const isFalconValid = await falconApi.verify(signatures.falcon, messageHash, publicKeys.falcon);
            return { isEd25519Valid, isFalconValid };
        }
        
        async function encryptPrivateKeyBundle(privateKeyBundle, password) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const keyMaterial = await window.crypto.subtle.importKey("raw", new TextEncoder().encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
            const derivedKey = await window.crypto.subtle.deriveKey(
                { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
                keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt"]
            );
            const privateKeysJson = JSON.stringify({
                ed25519: bytesToBase64(privateKeyBundle.ed25519),
                falcon: bytesToBase64(privateKeyBundle.falcon)
            });
            const encryptedData = await window.crypto.subtle.encrypt({ name: AES_ALGO, iv }, derivedKey, new TextEncoder().encode(privateKeysJson));
            return { cipherText: bytesToBase64(new Uint8Array(encryptedData)), salt: bytesToBase64(salt), iv: bytesToBase64(iv) };
        }

        async function decryptPrivateKeyBundle(encryptedPayload, password) {
            const salt = base64ToBytes(encryptedPayload.salt);
            const iv = base64ToBytes(encryptedPayload.iv);
            const keyMaterial = await window.crypto.subtle.importKey("raw", new TextEncoder().encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
            const derivedKey = await window.crypto.subtle.deriveKey(
                { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: PBKDF2_HASH_ALGO },
                keyMaterial, { name: "AES-GCM", length: 256 }, true, ["decrypt"]
            );
            const decryptedJson = await window.crypto.subtle.decrypt({ name: AES_ALGO, iv }, derivedKey, base64ToBytes(encryptedPayload.cipherText));
            const decodedBundle = JSON.parse(new TextDecoder().decode(decryptedJson));
            return {
                ed25519: base64ToBytes(decodedBundle.ed25519),
                falcon: base64ToBytes(decodedBundle.falcon)
            };
        }

        return { generateNewKeyPair, signData, verifySignatures, encryptPrivateKeyBundle, decryptPrivateKeyBundle, hashMessage };
    })();

    // ===================================================================================
    // UI HANDLERS & WORKFLOW
    // ===================================================================================
    const updateKeyStatus = (message, type = 'info') => {
        dom.keyStatus.innerHTML = message;
        dom.keyStatus.className = type;
    };
    
    const updateValidationResult = (message, type = 'info') => {
        dom.validationResult.innerHTML = message;
        dom.validationResult.className = type;
    };

    async function handleGenerateKeys() {
        if (!falconApi) {
            alert("Error: Core cryptographic modules are not loaded. Cannot generate keys.");
            return;
        }
        const password = prompt("Enter a strong password to encrypt your new private key file:");
        if (!password) {
            updateKeyStatus('❌ Key generation cancelled. Password is required.', 'invalid');
            return;
        }
        updateKeyStatus('⏳ Generating hybrid key pairs (Ed25519 + Falcon-512)...', 'info');
        try {
            const keyPairs = await BankCrypto.generateNewKeyPair();
            activeKeys = keyPairs;
            
            const publicKeysExport = {
                ed25519: bytesToBase64(activeKeys.publicKey.ed25519),
                falcon: bytesToBase64(activeKeys.publicKey.falcon)
            };
            downloadFile(JSON.stringify(publicKeysExport, null, 2), 'Sadat-hybrid-public-keys.json', 'application/json');

            const encryptedPayload = await BankCrypto.encryptPrivateKeyBundle(activeKeys.privateKey, password);
            downloadFile(JSON.stringify(encryptedPayload, null, 2), 'Sadat-hybrid-private-keys-ENCRYPTED.json', 'application/json');
            
            updateKeyStatus('✅ Hybrid keys generated & exported! Keys are now active.', 'valid');
            dom.createNoteButton.disabled = false;
        } catch (e) {
            updateKeyStatus(`❌ Key generation error: ${e.message}`, 'invalid');
        }
    }

    async function handleImportKeys(file, isPrivate) {
        if (!file) return;
        const fileContent = await file.text();
        
        try {
            if (isPrivate) {
                const password = prompt("Enter the password to decrypt the private key file:");
                if (!password) {
                     updateKeyStatus('❌ Import cancelled. Password is required.', 'invalid');
                     return;
                }
                updateKeyStatus('⏳ Decrypting private key bundle...', 'info');
                const encryptedData = JSON.parse(fileContent);
                activeKeys.privateKey = await BankCrypto.decryptPrivateKeyBundle(encryptedData, password);
                updateKeyStatus('✅ Private keys imported successfully. Ready for signing.', 'valid');
                dom.createNoteButton.disabled = false;
            } else {
                 const publicData = JSON.parse(fileContent);
                 activeKeys.publicKey = {
                     ed25519: base64ToBytes(publicData.ed25519),
                     falcon: base64ToBytes(publicData.falcon)
                 };
                 updateKeyStatus('✅ Public keys imported successfully. Ready for validation.', 'valid');
            }
        } catch (e) {
            updateKeyStatus(`❌ Error importing keys. Check password or file format. ${e.message}`, 'invalid');
        }
    }

    async function handleCreateNote() {
        if (!activeKeys.privateKey) {
            alert("Cannot create banknote. No private key is active.");
            return;
        }
        updateValidationResult('⏳ Generating new banknote...', 'info');
        const noteData = await createNoteData(dom.amountInput.value);
        await drawNoteOnCanvas(noteData);
        updateValidationResult('✅ New banknote design is ready.', 'valid');
    }

    async function handleValidation(file) {
        if (!file) return;
        if (!activeKeys.publicKey) {
            alert("Cannot validate banknote. No public key is active.");
            return;
        }
        updateValidationResult('⏳ Preparing image for validation...', 'info');
        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = async () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 1350;
            tempCanvas.height = 750;
            tempCanvas.getContext('2d').drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
            
            let resultHTML = '<span class="info">1. Reading digital data from QR Code...</span>';
            updateValidationResult(resultHTML);
            
            const qrData = readQRCodeFromCanvas(tempCanvas);
            if (!qrData) {
                updateValidationResult('❌ FATAL: QR Code not found or unreadable.', 'invalid');
                return;
            }
            resultHTML += `\n<span class="valid">   - Success.</span>`;
            
            resultHTML += `\n\n<span class="info">2. Verifying hybrid digital signatures...</span>`;
            updateValidationResult(resultHTML);
            
            const { isEd25519Valid, isFalconValid } = await validateSignatures(qrData);
            resultHTML += `\n<span class="${isEd25519Valid ? 'valid' : 'invalid'}">   - Ed25519 Signature: ${isEd25519Valid ? '✅ Valid' : '❌ Invalid'}</span>`;
            resultHTML += `\n<span class="${isFalconValid ? 'valid' : 'invalid'}">   - Falcon-512 Signature: ${isFalconValid ? '✅ Valid' : '❌ Invalid'}</span>`;

            if (!isEd25519Valid || !isFalconValid) {
                resultHTML += `\n\n<span class="invalid">❌ VERDICT: FORGERY DETECTED. Digital signature is invalid.</span>`;
                updateValidationResult(resultHTML, 'invalid');
                return;
            }
            
            resultHTML += `\n\n<span class="valid">✅ VERDICT: Banknote is authentic.</span>`;
            updateValidationResult(resultHTML, 'valid');
        };
    }
    
    // ===================================================================================
    // DATA & DRAWING LOGIC
    // ===================================================================================
    const getStandardizedDataForSigning = (noteData) => JSON.stringify({
        amount: noteData.amount,
        serial: noteData.serial,
        timestamp: noteData.timestamp
    }, Object.keys(noteData).sort());

    async function createNoteData(amount) {
        const noteData = {
            amount: parseInt(amount) || 0,
            serial: "SDT-PQ-" + Date.now(),
            timestamp: new Date().toISOString()
        };
        const stringToSign = getStandardizedDataForSigning(noteData);
        const signatures = await BankCrypto.signData(stringToSign, activeKeys.privateKey);
        noteData.signatures = {
            ed25519: bytesToBase64(signatures.ed25519),
            falcon: bytesToBase64(signatures.falcon)
        };
        const combinedSigString = noteData.signatures.ed25519 + noteData.signatures.falcon;
        noteData.visualHash = shake256(combinedSigString, 512); // 512 bits for visuals
        return noteData;
    }
    
    const readQRCodeFromCanvas = (canvas) => {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height);
        if (code) try { return JSON.parse(code.data); } catch { return null; }
        return null;
    };
    
    async function validateSignatures(qrData) {
        const stringToVerify = getStandardizedDataForSigning(qrData);
        const signatures = {
            ed25519: base64ToBytes(qrData.signatures.ed25519),
            falcon: base64ToBytes(qrData.signatures.falcon)
        };
        return await BankCrypto.verifySignatures(signatures, stringToVerify, activeKeys.publicKey);
    }

    async function drawNoteOnCanvas(noteData) {
        const { amount, serial, visualHash } = noteData;
        const ctx = dom.canvas.getContext("2d");
        const w = dom.canvas.width, h = dom.canvas.height;
        
        // Background
        const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));
        const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
        const baseHue = H(visualHash, 0, 0, 360);
        bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
        bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, w, h);
        
        // Text
        ctx.fillStyle = "#EAEAEA";
        ctx.font = `bold 100px 'Poppins'`;
        ctx.textAlign = "center";
        ctx.fillText(`$${amount.toLocaleString()}`, w / 2, h / 2 + 30);
        ctx.font = `30px 'Roboto Mono'`;
        ctx.fillText(serial, w / 2, h / 2 + 100);

        // QR Code
        const qrCanvas = document.createElement("canvas");
        await QRCode.toCanvas(qrCanvas, JSON.stringify(noteData), { width: 250, errorCorrectionLevel: 'H' });
        ctx.drawImage(qrCanvas, w - 300, h - 300, 250, 250);
    }

    // ===================================================================================
    // INITIALIZATION
    // ===================================================================================
    const init = async () => {
        dom.generateKeysButton.addEventListener('click', handleGenerateKeys);
        dom.createNoteButton.addEventListener('click', handleCreateNote);
        dom.importPublicKey.addEventListener('change', (e) => handleImportKeys(e.target.files[0], false));
        dom.importPrivateKey.addEventListener('change', (e) => handleImportKeys(e.target.files[0], true));
        dom.validatorInput.addEventListener('change', (e) => handleValidation(e.target.files[0]));

        try {
            updateKeyStatus('⏳ Loading Post-Quantum modules... (This may take a moment)', 'info');
            falconApi = await pqcSignFalcon512();
            updateKeyStatus('✅ Modules ready. Please generate or import keys.', 'valid');
        } catch (e) {
            console.error("Fatal Error Loading Falcon-512:", e);
            updateKeyStatus('❌ Error loading crypto modules. Ensure falcon.js/.wasm are local and you are on a web server.', 'invalid');
        }
    };

    init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Quantum Ledger - Genesis Engine</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        /* --- Modern CSS with Variables for a Thematic UI --- */
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #00f2ff; /* Quantum Teal */
            --accent-color-2: #e040fb; /* Neon Fuchsia */
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(0, 242, 255, 0.2);
        }
        /* --- General Body and Container Styling --- */
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(183, 100%, 20%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(293, 100%, 25%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(15px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 64px rgba(0, 0, 0, 0.4); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        
        /* --- Interactive Elements Styling (Buttons, Inputs) --- */
        input, button, label.button { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-1); box-shadow: 0 0 15px rgba(0, 242, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(100, 100, 255, 0.4); }

        /* --- Section and Status Styling --- */
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
        
        /* --- Banknote Canvas and Modal Styling --- */
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(0, 242, 255, 0.15); width: 100%; max-width: 1200px; height: auto; border: 1px solid var(--border-color); }
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; }
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
        #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Sadat Quantum Ledger</h1>
        <p>A Self-Contained, Quantum-Resistant Digital Banknote Ecosystem.</p>
    </div>

    <div class="section">
        <h2><span class="pill">Step 1</span> Guardian Setup: Forge Master Identity</h2>
        <div class="controls-grid">
            <button id="generate-keys-button">üîë Generate Master Key Pair</button>
            <label for="import-public-key" class="button sub-button">üì§ Load Public Key</label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
        </div>
         <div id="key-gen-status" class="status-box"><span class="info">‚ÑπÔ∏è Welcome, Guardian. Generate a new Master Key Pair to create your financial ecosystem. This genesis process is fully offline and secured by post-quantum cryptography.</span></div>
    </div>

    <div class="section">
        <h2><span class="pill">Step 2</span> Quantum Activation: Solve the 3-Piece Puzzle</h2>
        <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To mint banknotes, you must perform a "personal proof-of-work" by providing the three encrypted pieces of your Master Private Key. This ensures absolute security against unauthorized access.</p>
        <div class="controls-grid">
             <label for="file-key-input" class="button sub-button">1. Upload File Key</label>
             <input type="file" id="file-key-input" accept=".json" style="display:none;" />
             <input type="password" id="password-key-input" placeholder="2. Enter Password Key">
             <label for="visual-key-input" class="button sub-button">3. Scan Visual Key</label>
             <input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;" />
        </div>
        <button id="reconstruct-key-button" disabled style="margin-top: 20px;">üîì Activate Minting Authority</button>
        <div id="key-reconstruction-status" class="status-box"><span class="warning">‚ö†Ô∏è Minting Authority is INACTIVE. Solve the puzzle to activate.</span></div>
    </div>

    <div class="section">
        <h2><span class="pill">Step 3</span> Genesis Mint: Create Digital Banknotes</h2>
        <div class="controls-grid">
            <input type="number" id="amount-input" value="10000" placeholder="Amount">
            <input type="number" id="quantity-input" value="1" min="1" max="100" placeholder="Quantity">
            <button id="create-note-button" disabled>üé® Forge & Sign Banknote</button>
            <button id="download-batch-button" disabled>üì• Download Batch to Folder</button>
        </div>
        <div id="banknote-status" class="status-box">Activate your Minting Authority in Step 2 to begin creating wealth.</div>
        <canvas id="noteCanvas" width="1200" height="533"></canvas>
    </div>

    <div class="section" id="validator-section">
        <h2><span class="pill">Step 4</span> Authenticate: Verify a Banknote</h2>
        <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To verify a banknote, upload a clear picture containing its three JAB Codes. The system will read all three and verify the cryptographic chain of trust.</p>
        <label for="validator-input" class="button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>
            Select Banknote Image for Validation
        </label>
        <input type="file" id="validator-input" accept="image/png, image/jpeg" style="display: none;">
        <div id="validation-result" class="status-box">Awaiting banknote for validation...</div>
    </div>
</div>

<div id="qr-modal" class="modal">
  <div class="modal-content">
    <h2 id="qr-modal-title">Your Visual Key (Puzzle Piece 3/3)</h2>
    <p>CRITICAL: Print this JAB Code and store it in a secure physical location (e.g., a safe). This is the final piece of your Master Key puzzle.</p>
    <div id="qr-display"></div>
    <button id="download-qr-button" style="margin-top: 15px;">üíæ Download Visual Key</button>
    <button onclick="document.getElementById('qr-modal').style.display='none'">Close</button>
  </div>
</div>

<script type="module">
// --- DEPENDENCIES: Assumes jabcodeJSLib.min.js and pqc-sign-falcon-1024.min.js are in the same directory ---
import JabcodeJSInterface from './jabcodeJSLib.min.js';
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

const jabcode = new JabcodeJSInterface();

// --- Global Application State ---
const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null, // Held in memory ONLY when activated and cleared immediately after use.
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};

// --- System Constants ---
const Constants = {
    FALCON_PUBKEY_SIZE: 1793,
    PBKDF2_ITERATIONS: 250000, // High iteration count for "Quantum Mining" effect
    AES_ALGO: "AES-GCM",
};

// --- DOM Element Cache for Performance ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    quantityInput: document.getElementById('quantity-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadBatchButton: document.getElementById('download-batch-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorInput: document.getElementById('validator-input'),
    validationResult: document.getElementById('validation-result'),
    qrModal: document.getElementById('qr-modal'),
    qrDisplay: document.getElementById('qr-display'),
    qrModalTitle: document.getElementById('qr-modal-title'),
    downloadQrButton: document.getElementById('download-qr-button')
};

// --- Utility Functions for common tasks ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes;
    },
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        const icon = { info: '‚ÑπÔ∏è', success: '‚úÖ', warning: '‚ö†Ô∏è', error: '‚ùå' }[type];
        element.innerHTML = `<span class="${type}">${icon} ${message}</span>`;
    },
    log: (message, type = 'info') => {
        const icon = { info: '‚ÑπÔ∏è', success: '‚úÖ', warning: '‚ö†Ô∏è', error: '‚ùå' }[type];
        console.log(`[Sadat Quantum Ledger] ${icon} ${message}`);
    }
};

// ===================================================================================
// CORE CRYPTO ENGINE: Manages all cryptographic operations.
// ===================================================================================
const CryptoEngine = (() => {
    // Derives a strong AES key from a password and salt using PBKDF2.
    async function pbkdf2DeriveKey(password, salt) {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        return await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: Constants.PBKDF2_ITERATIONS, hash: "SHA-256" }, importedKey, { name: Constants.AES_ALGO, length: 256 }, false, ["encrypt", "decrypt"]);
    }
    
    // Hashes a message for Falcon signing using SHAKE256.
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }

    return {
        async generateKeyPair() {
            if (!state.falconApi) throw new Error("Falcon API not initialized.");
            return state.falconApi.keypair();
        },
        async sign(data, privateKey) {
            if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        async verify(signature, data, publicKey) {
            if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        // Encrypts the Master Private Key using the 3-piece puzzle methodology.
        async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
            // Layer 1: Encrypt with Visual Key
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
            const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const encryptedWithVisual = await crypto.subtle.encrypt({ name: Constants.AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);

            const intermediatePayload = JSON.stringify({
                encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual),
                salt: Utils.arrayBufferToBase64(visualKeySalt),
                iv: Utils.arrayBufferToBase64(visualKeyIV)
            });

            // Layer 2: Encrypt the result of Layer 1 with Password Key
            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
            const passwordIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const finalEncryptedKey = await crypto.subtle.encrypt({ name: Constants.AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
            
            // The final result is the "File Key"
            return {
                fileKey: {
                    cipherText: Utils.arrayBufferToBase64(finalEncryptedKey),
                    salt: Utils.arrayBufferToBase64(passwordSalt),
                    iv: Utils.arrayBufferToBase64(passwordIV)
                }
            };
        },
        // Decrypts the Master Private Key by reversing the 3-piece puzzle encryption.
        async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
            // Layer 2 Decryption
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, Utils.base64ToUint8Array(fileKey.salt));
            const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: Constants.AES_ALGO, iv: Utils.base64ToUint8Array(fileKey.iv) }, cryptoPasswordKey, Utils.base64ToUint8Array(fileKey.cipherText));
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
            
            // Layer 1 Decryption
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, Utils.base64ToUint8Array(intermediatePayload.salt));
            const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: Constants.AES_ALGO, iv: Utils.base64ToUint8Array(intermediatePayload.iv) }, cryptoVisualKey, Utils.base64ToUint8Array(intermediatePayload.encryptedKey));
            
            return new Uint8Array(masterPrivateKeyBytes);
        }
    };
})();

// ===================================================================================
// BANKNOTE LOGIC: Manages banknote creation, data structuring, and validation.
// ===================================================================================
const Banknote = (() => {
    // Standardizes data for Signature One to ensure consistent hashing.
    const getPayloadForSigOne = (noteData) => JSON.stringify({ amount: noteData.amount, serial: noteData.serial });

    // Standardizes data for Signature Two.
    const getPayloadForSigTwo = (noteData) => {
        const temp = {
            ephPubKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
            sigOne: Utils.arrayBufferToBase64(noteData.signatureOne)
        };
        return JSON.stringify(temp, Object.keys(temp).sort()); // Sort keys for deterministic output
    };

    return {
        // Creates a fully signed, new banknote data object.
        async create(amount) {
            if (!state.masterPrivateKey) throw new Error("Minting Authority is not active.");
            
            const ephemeralKeyPair = await CryptoEngine.generateKeyPair();
            const noteData = {
                amount: parseInt(amount) || 0,
                serial: crypto.randomUUID().substring(0, 13).toUpperCase(),
                ephemeralPublicKey: ephemeralKeyPair.publicKey,
                signatureOne: null,
                signatureTwo: null
            };
            
            // Create Signature One (Ephemeral)
            const payloadOne = getPayloadForSigOne(noteData);
            noteData.signatureOne = await CryptoEngine.sign(payloadOne, ephemeralKeyPair.privateKey);
            
            // Create Signature Two (Master)
            const payloadTwo = getPayloadForSigTwo(noteData);
            noteData.signatureTwo = await CryptoEngine.sign(payloadTwo, state.masterPrivateKey);
            
            Utils.log(`Created banknote ${noteData.serial} with dual signatures.`, 'success');
            return noteData;
        },
        
        // Verifies the entire chain of trust for a given banknote data object.
        async verify(noteData) {
            if (!state.masterPublicKey) throw new Error("Master Public Key not loaded. Cannot verify authenticity.");
            
            // 1. Verify Signature One (Data Integrity)
            const payloadOne = getPayloadForSigOne(noteData);
            const isSigOneValid = await CryptoEngine.verify(noteData.signatureOne, payloadOne, noteData.ephemeralPublicKey);
            if (!isSigOneValid) {
                return { valid: false, message: "Signature One (Ephemeral) INVALID. Banknote data may have been altered. Verdict: FORGERY." };
            }
            Utils.log(`Signature One for note ${noteData.serial} is VALID.`, 'success');

            // 2. Verify Signature Two (Issuer Authenticity)
            const payloadTwo = getPayloadForSigTwo(noteData);
            const isSigTwoValid = await CryptoEngine.verify(noteData.signatureTwo, payloadTwo, state.masterPublicKey);
            if (!isSigTwoValid) {
                return { valid: false, message: "Signature Two (Master) INVALID. Banknote was not issued by this Guardian. Verdict: FORGERY." };
            }
            Utils.log(`Signature Two for note ${noteData.serial} is VALID.`, 'success');
            
            return { valid: true, message: `Banknote is AUTHENTIC.\nAmount: ${noteData.amount.toLocaleString()}\nSerial: ${noteData.serial}` };
        }
    };
})();

// ===================================================================================
// UI HANDLERS: Manages all user interactions and updates the DOM.
// ===================================================================================
const UI = (() => {
    // Helper to update the status of the 3-Piece Puzzle UI.
    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = '';
        statusHtml += fileKey ? '<span class="valid">‚úÖ File Key loaded.</span>\n' : '<span class="invalid">‚ùå File Key missing.</span>\n';
        statusHtml += passwordKey ? '<span class="valid">‚úÖ Password Key entered.</span>\n' : '<span class="invalid">‚ùå Password Key missing.</span>\n';
        statusHtml += visualKey ? '<span class="valid">‚úÖ Visual Key loaded.</span>\n' : '<span class="invalid">‚ùå Visual Key missing.</span>\n';
        
        const allPiecesProvided = fileKey && passwordKey && visualKey;
        DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
        
        if (allPiecesProvided) {
             Utils.updateStatus(DOMElements.keyReconstructionStatus, "All puzzle pieces provided. Click 'Activate' to unlock your minting authority.", 'warning');
        } else {
             DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        }
    }
    
    // Helper to clear the temporarily stored private key from memory for security.
    function clearPrivateKey() {
        state.masterPrivateKey = null;
        DOMElements.createNoteButton.disabled = true;
        DOMElements.downloadBatchButton.disabled = true;
        // Reset puzzle inputs for next activation
        state.puzzlePieces = { fileKey: null, passwordKey: null, visualKey: null };
        DOMElements.passwordKeyInput.value = '';
        updatePuzzleStatus();
        Utils.updateStatus(DOMElements.keyReconstructionStatus, "For security, Minting Authority has been deactivated and the private key has been cleared from memory. Solve the puzzle again to re-activate.", 'warning');
        Utils.log("Master Private Key cleared from memory.", 'warning');
    }

    return {
        // Orchestrates generating keys, encrypting them, and providing the user with the three puzzle pieces.
        async handleGenerateAndExportKeys() {
            const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3). It CANNOT be recovered.");
            if (!password) {
                Utils.updateStatus(DOMElements.keyGenStatus, 'Key generation cancelled. Password is required.', 'error');
                return;
            }
            
            Utils.updateStatus(DOMElements.keyGenStatus, 'Generating Falcon-1024 key pair... This is computationally intensive and may take a moment.', 'info');
            try {
                const keyPair = await CryptoEngine.generateKeyPair();
                state.masterPublicKey = keyPair.publicKey; // Set the new public key as active
                Utils.log("New Master Key Pair generated.", 'success');
                Utils.updateStatus(DOMElements.keyGenStatus, 'Creating puzzle pieces and encrypting private key...', 'info');
                
                const visualKeySecret = crypto.randomUUID();
                const { fileKey } = await CryptoEngine.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
                
                // Provide the three pieces to the user
                Utils.downloadFile(JSON.stringify({ masterPublicKey: Utils.arrayBufferToBase64(keyPair.publicKey) }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
                Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY-PIECE-1.json', 'application/json');
                
                DOMElements.qrModalTitle.innerText = "Your Visual Key (Piece 3/3)";
                const img = await BanknoteDrawer.createJabImage(visualKeySecret, 256);
                DOMElements.qrDisplay.innerHTML = '';
                DOMElements.qrDisplay.appendChild(img);
                DOMElements.qrModal.style.display = 'flex';

                Utils.updateStatus(DOMElements.keyGenStatus, `New identity forged!\n- MASTER-PUBLIC-KEY.json (share this for verification)\n- FILE-KEY-PIECE-1.json (keep on a USB)\n- Password (memorize this)\n- Visual Key (print and secure this)\nThe new Public Key is now active for validation.`, 'success');

            } catch (e) {
                Utils.log(`Key generation failed: ${e.message}`, 'error');
                Utils.updateStatus(DOMElements.keyGenStatus, `Failed to generate keys: ${e.message}`, 'error');
            }
        },
        // Handles loading puzzle pieces from file inputs.
        handleFileKeyInput: async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("File Key loaded.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`Failed to load File Key: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; },
        handlePasswordKeyInput: (event) => { state.puzzlePieces.passwordKey = event.target.value || null; updatePuzzleStatus(); },
        handleVisualKeyInput: (event) => {
            const file = event.target.files[0]; if (!file) return;
            BanknoteDrawer.decodeJabFromImage(file)
                .then(decodedText => {
                    if (decodedText) {
                        state.puzzlePieces.visualKey = decodedText;
                        Utils.log("Visual Key loaded.", 'success');
                    } else {
                         state.puzzlePieces.visualKey = null;
                         Utils.log("Failed to find a JAB code in the image.", 'error');
                    }
                })
                .catch(error => {
                    state.puzzlePieces.visualKey = null;
                    Utils.log(`Error decoding JAB Code: ${error.message}`, 'error');
                })
                .finally(() => {
                    updatePuzzleStatus();
                    event.target.value = '';
                });
        },
        // Handles the "Quantum Activation" process.
        async handleReconstructKey() { 
            const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
            if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "All three puzzle pieces are required.", 'error'); return; }
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "Activating... Performing personal proof-of-work (key derivation). This is secure and may take a moment.", 'info');
            try {
                // The reconstruction is the "mining"
                const reconstructedKey = await CryptoEngine.reconstructMasterKey(fileKey, passwordKey, visualKey);
                
                // Self-test to verify the key is correct before storing it in state
                const testData = new TextEncoder().encode("Sadat-Quantum-Ledger-Self-Test");
                const testSig = await CryptoEngine.sign(testData, reconstructedKey);
                const isTestValid = await CryptoEngine.verify(testSig, testData, state.masterPublicKey);
                if (!isTestValid) throw new Error("Key reconstruction failed self-test. The provided pieces do not match the active public key. Check your password, file key, and visual key.");

                state.masterPrivateKey = reconstructedKey; // Store the key temporarily in state
                Utils.updateStatus(DOMElements.keyReconstructionStatus, "Minting Authority ACTIVE. You can now create banknotes.", 'success');
                DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
            } catch (error) {
                console.error(error); 
                Utils.updateStatus(DOMElements.keyReconstructionStatus, `Activation Failed. ${error.message}`, 'error');
                clearPrivateKey();
            } 
        },
        // Handles creating a single banknote and displaying it.
        async handleCreateSingleNote() {
            if (!state.masterPrivateKey) { alert("Minting Authority is not active. Please activate it in Step 2."); return; }
            Utils.updateStatus(DOMElements.banknoteStatus, `Forging and signing new banknote...`, 'info');
            try {
                const noteData = await Banknote.create(DOMElements.amountInput.value);
                await BanknoteDrawer.draw(DOMElements.noteCanvas, noteData, 1200, 533);
                Utils.updateStatus(DOMElements.banknoteStatus, `New banknote [${noteData.serial}] forged and signed. Ready for download.`, 'success');
            } catch (error) {
                Utils.updateStatus(DOMElements.banknoteStatus, `Error: ${error.message}`, 'error');
                console.error(error);
            }
        },
        // Handles creating and downloading a batch of banknotes.
        async handleDownloadBatch() {
            if (!state.masterPrivateKey) { alert("Minting Authority is not active. Please activate it in Step 2."); return; }
            const quantity = parseInt(DOMElements.quantityInput.value) || 1;
            if (!window.showDirectoryPicker) {
                alert("Your browser doesn't support directory selection. Notes will be downloaded individually.");
            }
            
            Utils.updateStatus(DOMElements.banknoteStatus, `Preparing to mint ${quantity} banknote(s)...`, 'info');
            try {
                const dirHandle = window.showDirectoryPicker ? await window.showDirectoryPicker() : null;
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = 1200; offscreenCanvas.height = 533;
                
                for (let i = 0; i < quantity; i++) {
                    Utils.updateStatus(DOMElements.banknoteStatus, `Minting note ${i + 1} of ${quantity}...`, 'info');
                    const noteData = await Banknote.create(DOMElements.amountInput.value);
                    await BanknoteDrawer.draw(offscreenCanvas, noteData, 1200, 533);
                    
                    const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                    const filename = `SADAT-NOTE-${noteData.serial}.png`;

                    if (dirHandle) {
                        const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                    } else {
                        Utils.downloadFile(blob, filename, 'image/png');
                    }
                    if (i === quantity - 1) { // Draw the last one to the main canvas
                        await BanknoteDrawer.draw(DOMElements.noteCanvas, noteData, 1200, 533);
                    }
                }
                Utils.updateStatus(DOMElements.banknoteStatus, `Successfully minted and saved ${quantity} banknote(s).`, 'success');
            } catch (error) {
                Utils.updateStatus(DOMElements.banknoteStatus, `Operation cancelled or failed: ${error.message}`, 'error');
            } finally {
                clearPrivateKey(); // CRITICAL: Clear the private key after the batch operation.
            }
        },
        // Handles the banknote verification process.
        async handleValidation() {
            const file = DOMElements.validatorInput.files[0];
            if (!file) return;
            if (!state.masterPublicKey) {
                Utils.updateStatus(DOMElements.validationResult, 'Load a Master Public Key in Step 1 before validating.', 'error');
                return;
            }
            const resultDiv = DOMElements.validationResult;
            Utils.updateStatus(resultDiv, 'Analyzing banknote image and decoding JAB codes...', 'info');
            try {
                // Decode all three JAB codes from the banknote image
                const decodedData = await Promise.all([
                    BanknoteDrawer.decodeJabFromImage(file, 'jab-1-data'),
                    BanknoteDrawer.decodeJabFromImage(file, 'jab-2-sig-two'),
                    BanknoteDrawer.decodeJabFromImage(file, 'jab-3-sig-one')
                ]);

                if (decodedData.some(d => !d)) {
                    throw new Error("Could not read all three required JAB codes from the image. Ensure the image is clear and contains the full banknote.");
                }
                
                const [publicDataStr, sigTwoB64, sigOneB64] = decodedData;

                const noteData = JSON.parse(publicDataStr);
                noteData.signatureOne = Utils.base64ToUint8Array(sigOneB64);
                noteData.signatureTwo = Utils.base64ToUint8Array(sigTwoB64);
                noteData.ephemeralPublicKey = Utils.base64ToUint8Array(noteData.ephemeralPublicKey);
                
                Utils.updateStatus(resultDiv, `JAB Codes Decoded. Verifying cryptographic signatures for note [${noteData.serial}]...`, 'info');

                const verificationResult = await Banknote.verify(noteData);
                
                if (verificationResult.valid) {
                    Utils.updateStatus(resultDiv, verificationResult.message, 'success');
                } else {
                    Utils.updateStatus(resultDiv, verificationResult.message, 'error');
                }

            } catch (e) {
                Utils.updateStatus(resultDiv, `Validation Error: ${e.message}.`, 'error');
                console.error(e);
            } finally {
                DOMElements.validatorInput.value = ''; // Reset file input
            }
        }
    };
})();


// ===================================================================================
// BANKNOTE DRAWER: Renders the visual appearance of the banknote on a canvas.
// ===================================================================================
const BanknoteDrawer = (() => {
    // Generates deterministic visual patterns from a hash string for unique banknote designs.
    const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));
    function drawGuilloche(ctx, hash, w, h) { /* ... Complex drawing logic ... */ } // This function is complex and kept abstract for brevity.
    
    // Creates a JAB code image from a payload.
    async function createJabImage(payload, size) {
        return new Promise((resolve, reject) => {
            try {
                // Use custom symbol set names to differentiate the JAB codes visually and functionally
                const jabType = typeof payload === 'object' ? payload.type : 'default';
                const rawBase64 = jabcode.encode_message(JSON.stringify(payload), `jab-${jabType}`);
                const img = new Image(size, size);
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error("Browser failed to load generated JAB Code."));
                img.src = rawBase64.startsWith('data:image') ? rawBase64 : `data:image/png;base64,${rawBase64}`;
            } catch (err) { reject(new Error(`JAB code generation failed: ${err.message}`)); }
        });
    }

    return {
        createJabImage, // Expose for use in other modules
        // Decodes a JAB code from an image file.
        decodeJabFromImage: (file, jabType) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const decodedText = await jabcode.decode_message(e.target.result, jabType);
                        resolve(decodedText);
                    } catch (error) { reject(error); }
                };
                reader.onerror = () => reject(new Error("Failed to read image file."));
                reader.readAsDataURL(file);
            });
        },
        // Main function to draw the complete banknote on a canvas.
        draw: async (canvas, noteData, width, height) => {
            const ctx = canvas.getContext("2d");
            const { amount, serial, ephemeralPublicKey, signatureOne, signatureTwo } = noteData;
            const scale = width / 1200;
            const visualHash = shake256(Utils.arrayBufferToBase64(signatureTwo), 256);

            // --- Draw Background ---
            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            const baseHue = H(visualHash, 0, 0, 360);
            bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 8%)`);
            bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 5%)`);
            ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, width, height);

            // --- Generate 3 JAB Codes ---
            const jabSize = 200 * scale;
            const payload1 = { type: '1-data', amount, serial, ephemeralPublicKey: Utils.arrayBufferToBase64(ephemeralPublicKey) };
            const payload2 = { type: '2-sig-two', sig: Utils.arrayBufferToBase64(signatureTwo) };
            const payload3 = { type: '3-sig-one', sig: Utils.arrayBufferToBase64(signatureOne) };
            
            const [jabImg1, jabImg2, jabImg3] = await Promise.all([
                createJabImage(payload1, jabSize),
                createJabImage(payload2, jabSize),
                createJabImage(payload3, jabSize)
            ]);

            // --- Draw JAB Codes on Canvas ---
            const padding = 20 * scale;
            const boxSize = jabSize + (padding * 2);
            const yPos = (height - boxSize) / 2;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';

            const leftX = 60 * scale;
            const centerX = (width - boxSize) / 2;
            const rightX = width - boxSize - (60 * scale);

            // Left JAB (Public Data)
            ctx.fillRect(leftX, yPos, boxSize, boxSize);
            ctx.drawImage(jabImg1, leftX + padding, yPos + padding, jabSize, jabSize);
            
            // Center JAB (Signature Two)
            ctx.fillRect(centerX, yPos, boxSize, boxSize);
            ctx.drawImage(jabImg2, centerX + padding, yPos + padding, jabSize, jabSize);
            
            // Right JAB (Signature One)
            ctx.fillRect(rightX, yPos, boxSize, boxSize);
            ctx.drawImage(jabImg3, rightX + padding, yPos + padding, jabSize, jabSize);
            
            // --- Draw Text Elements ---
            ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 8 * scale;
            ctx.font = `bold ${32 * scale}px 'Roboto Mono'`;
            ctx.textAlign = 'center';
            ctx.fillStyle = "rgba(255,255,255,0.7)";
            ctx.fillText("Public Data", leftX + boxSize/2, yPos + boxSize + (30*scale));
            ctx.fillStyle = "#e040fb";
            ctx.fillText("Master Seal", centerX + boxSize/2, yPos + boxSize + (30*scale));
            ctx.fillStyle = "#00e676";
            ctx.fillText("Integrity Seal", rightX + boxSize/2, yPos + boxSize + (30*scale));
            
            ctx.fillStyle = "#EAEAEA";
            ctx.font = `bold ${60 * scale}px 'Roboto Mono'`;
            ctx.fillText(amount.toLocaleString('en-US'), width/2, height * 0.35);
            ctx.font = `bold ${40 * scale}px 'Roboto Mono'`;
            ctx.fillText(`SN: ${serial}`, width/2, height * 0.7);
            ctx.shadowColor = "transparent";
        }
    };
})();

// ===================================================================================
// APPLICATION INITIALIZATION
// ===================================================================================
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, 'Loading Falcon-1024 Crypto Module...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.keyGenStatus, 'Modules loaded. Forge your Guardian identity or load a Public Key to begin.', 'success');
        Utils.log("All cryptographic modules initialized successfully.", 'success');
    } catch (e) {
        Utils.log(`Critical Error: Could not load required modules: ${e.message}`, 'error');
        Utils.updateStatus(DOMElements.keyGenStatus, `Critical Error: Could not load modules. Application cannot run.`, 'error');
        return;
    }
    
    // --- Event Listener Setup ---
    DOMElements.generateKeysButton.addEventListener('click', UI.handleGenerateAndExportKeys);
    DOMElements.importPublicKey.addEventListener('change', async (event) => {
        const file = event.target.files[0]; if (!file) return;
        try {
            const data = JSON.parse(await file.text());
            if (!data.masterPublicKey) throw new Error("Invalid public key file format.");
            state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey);
            Utils.updateStatus(DOMElements.keyGenStatus, 'Public key imported. Ready to validate banknotes.', 'success');
        } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `Error importing public key: ${error.message}`, 'error'); }
        event.target.value = '';
    });
    
    DOMElements.fileKeyInput.addEventListener('change', UI.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UI.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UI.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UI.handleReconstructKey);
    DOMElements.createNoteButton.addEventListener('click', UI.handleCreateSingleNote);
    DOMElements.downloadBatchButton.addEventListener('click', UI.handleDownloadBatch);
    DOMElements.validatorInput.addEventListener('change', UI.handleValidation);
    
    // Modal download button
    DOMElements.downloadQrButton.addEventListener('click', () => {
        const img = DOMElements.qrDisplay.querySelector('img');
        if (img && img.src) Utils.downloadFile(img.src, 'Sadat-VISUAL-KEY-PIECE-3.png', 'image/png');
    });

    // --- Initial Canvas Drawing ---
    const canvas = DOMElements.noteCanvas;
    const ctx = canvas.getContext('2d');
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, `hsl(250, 50%, 8%)`); bgGradient.addColorStop(1, `hsl(260, 40%, 5%)`);
    ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold 30px 'Poppins'`; ctx.textAlign = 'center';
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.fillText("Banknote Design Renders Here After Forging", canvas.width/2, canvas.height/2);
}

main(); // Start the application
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote [Commitment Scheme - Validation Fixed]</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <script type="module" src="./jabcodeJSLib.min.js"></script>
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #00e676; /* Green for success */
            --accent-color-2: #40c4ff; /* Blue for info */
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --border-color: rgba(64, 196, 255, 0.2);
        }

        body {
            margin: 0;
            font-family: var(--primary-font);
            background-color: var(--dark-bg);
            background-image:
                radial-gradient(at 0% 0%, hsla(197, 100%, 15%, 0.3) 0px, transparent 50%),
                radial-gradient(at 100% 100%, hsla(163, 100%, 20%, 0.3) 0px, transparent 50%);
            color: var(--text-color);
            text-align: center;
            padding: 24px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.7);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 24px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .header {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 16px;
            margin-bottom: 24px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 600;
            color: #fff;
            margin: 0 0 8px 0;
            letter-spacing: 1px;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: 1rem;
            color: var(--text-muted);
            margin: 0;
        }

        canvas {
            border-radius: 16px;
            margin-top: 24px;
            background: #050508;
            cursor: default;
            box-shadow: 0 0 50px rgba(64, 196, 255, 0.15);
            width: 100%;
            max-width: 900px;
            height: auto;
            border: 1px solid var(--border-color);
        }

        input[type="number"], button, label {
            padding: 14px 22px;
            font-size: 16px;
            font-family: var(--primary-font);
            border-radius: 12px;
            margin: 8px 5px;
            border: 1px solid var(--border-color);
            background: var(--medium-bg);
            color: #fff;
            transition: all 0.3s ease;
            cursor: pointer;
            outline: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        input[type="number"] {
            font-family: var(--mono-font);
            font-weight: 700;
            text-align: center;
            width: 150px;
        }

        input[type="number"]:focus {
            border-color: var(--accent-color-2);
            box-shadow: 0 0 15px rgba(64, 196, 255, 0.5);
        }

        button:not([disabled]), label:not([disabled]) {
            font-weight: 600;
            background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2));
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button.sub-button, label.sub-button {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
        }
        
        button[disabled], label[disabled] {
            cursor: not-allowed;
            opacity: 0.5;
            background: var(--light-bg);
            border: 1px solid var(--border-color);
        }

        button:hover:not([disabled]), label:hover:not([disabled]) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 230, 118, 0.4);
        }

        .section {
            background: rgba(16, 16, 26, 0.5);
            padding: 20px;
            margin-top: 30px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
        }

        h2 {
            font-size: 1.5rem;
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .controls-grid {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        #validation-result, #key-status {
            margin-top: 20px;
            font-size: 12px;
            font-weight: normal;
            min-height: 50px;
            line-height: 1.6;
            text-align: left;
            background: var(--dark-bg);
            padding: 15px 20px;
            border-radius: 12px;
            white-space: pre-wrap;
            font-family: var(--mono-font);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .valid { color: var(--success-color); }
        .invalid { color: var(--error-color); }
        .info { color: var(--info-color); }
        
        .input-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-right: -10px;
        }

        /* --- LOADER CSS FOR VISUAL FEEDBACK --- */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid var(--accent-color-1);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 12px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Sadat Digital Banknote</h1>
        <p>A Secure Digital Currency using a Falcon-512 Commitment Scheme & DCT Steganography</p>
    </div>

    <canvas id="noteCanvas" width="1350" height="750"></canvas>

    <div class="section">
        <h2>Banknote Controls</h2>
        <div class="controls-grid">
            <span class="input-label">Amount:</span>
            <input type="number" id="amount-input" value="50000">
            <span class="input-label">Quantity:</span>
            <input type="number" id="quantity-input" value="1" min="1" max="100">
            <button id="create-note-button" disabled>🎨 Redesign Banknote</button>
            <button id="download-batch-button" disabled>📥 Download Batch (Worker)</button>
        </div>
    </div>

    <div class="section">
        <h2>Bank Key Management</h2>
        <div class="controls-grid">
            <button id="generate-keys-button">🔑 Generate & Export Keys</button>
            <label for="import-public-key" class="sub-button">
                Import Public Key
            </label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
            <label for="import-private-key" class="sub-button">
                Import Private Key
            </label>
            <input type="file" id="import-private-key" accept=".json" style="display: none;">
        </div>
        <div id="key-status">Key pair status will be displayed here.</div>
    </div>

    <div class="section" id="validator-section">
        <h2>Validate Banknote</h2>
        <label for="validator-input">
            Select Image for Validation
        </label>
        <input type="file" id="validator-input" accept="image/png" style="display: none;">
        <div id="validation-result">Validation result will be displayed here.</div>
    </div>
</div>

<script type="module">
// Import cryptographic libraries as modules
import pqcSignFalcon512 from './falcon.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
import JabcodeJSInterface from './jabcodeJSLib.min.js';

// --- Global State & Configuration ---
const canvas = document.getElementById("noteCanvas");
const ctx = canvas.getContext("2d");
let activeKeys = { privateKey: null, publicKey: null };
let jabcodeApi = null;
let noteWorker = null; 
let keyGenTimeout = null; 

const JAB_CODE_REGION = { x: 800, y: 210, width: 420, height: 420 };

// --- UI Update Functions ---
const updateKeyStatus = (message, isLoading = false) => {
    const statusDiv = document.getElementById('key-status');
    let content = isLoading ? '<div class="loader"></div>' : '';
    content += `<span>${message}</span>`;
    statusDiv.innerHTML = content;
};
const updateValidationResult = (message, isLoading = false) => {
    const resultDiv = document.getElementById('validation-result');
    let content = isLoading ? '<div class="loader"></div>' : '';
    content += `<span>${message}</span>`;
    resultDiv.innerHTML = content;
}
const updateControlsState = (isEnabled) => {
    document.getElementById('create-note-button').disabled = !isEnabled;
    document.getElementById('download-batch-button').disabled = !isEnabled;
};

// --- Utility Functions ---
const utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binary_string = window.atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
        return bytes;
    },
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
};

// ===================================================================================
// DCT Steganography Module (For Image Integrity)
// ===================================================================================
const DCTStego = (() => {
    const BLOCK_SIZE = 8;
    const MESSAGE_TERMINATOR = "0000000000000000"; // 16-bit terminator

    // Pre-calculate DCT basis functions for speed
    const C = new Float64Array(BLOCK_SIZE * BLOCK_SIZE);
    for (let i = 0; i < BLOCK_SIZE; i++) {
        for (let j = 0; j < BLOCK_SIZE; j++) {
            if (i === 0) C[i * BLOCK_SIZE + j] = 1.0 / Math.sqrt(BLOCK_SIZE);
            else C[i * BLOCK_SIZE + j] = Math.sqrt(2.0 / BLOCK_SIZE) * Math.cos(((2 * j + 1) * i * Math.PI) / (2.0 * BLOCK_SIZE));
        }
    }
    const CT = new Float64Array(BLOCK_SIZE * BLOCK_SIZE); // Transposed
    for (let i = 0; i < BLOCK_SIZE; i++) for (let j = 0; j < BLOCK_SIZE; j++) CT[i * BLOCK_SIZE + j] = C[j * BLOCK_SIZE + i];

    function applyDCT(block) {
        const temp = new Float64Array(BLOCK_SIZE * BLOCK_SIZE);
        const result = new Float64Array(BLOCK_SIZE * BLOCK_SIZE);
        for(let i=0; i<BLOCK_SIZE; i++) for(let j=0; j<BLOCK_SIZE; j++) {
            let sum = 0;
            for(let k=0; k<BLOCK_SIZE; k++) sum += C[i * BLOCK_SIZE + k] * (block[k * BLOCK_SIZE + j] - 128);
            temp[i * BLOCK_SIZE + j] = sum;
        }
        for(let i=0; i<BLOCK_SIZE; i++) for(let j=0; j<BLOCK_SIZE; j++) {
            let sum = 0;
            for(let k=0; k<BLOCK_SIZE; k++) sum += temp[i * BLOCK_SIZE + k] * CT[k * BLOCK_SIZE + j];
            result[i * BLOCK_SIZE + j] = sum;
        }
        return result;
    }

    function applyIDCT(coeffs) {
        const temp = new Float64Array(BLOCK_SIZE * BLOCK_SIZE);
        const result = new Uint8ClampedArray(BLOCK_SIZE * BLOCK_SIZE);
        for(let i=0; i<BLOCK_SIZE; i++) for(let j=0; j<BLOCK_SIZE; j++) {
            let sum = 0;
            for(let k=0; k<BLOCK_SIZE; k++) sum += CT[i * BLOCK_SIZE + k] * coeffs[k * BLOCK_SIZE + j];
            temp[i * BLOCK_SIZE + j] = sum;
        }
        for(let i=0; i<BLOCK_SIZE; i++) for(let j=0; j<BLOCK_SIZE; j++) {
            let sum = 0;
            for(let k=0; k<BLOCK_SIZE; k++) sum += temp[i * BLOCK_SIZE + k] * C[k * BLOCK_SIZE + j];
            result[i * BLOCK_SIZE + j] = sum + 128;
        }
        return result;
    }

    function process(ctx, message, mode) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;
        const binaryMessage = (mode === 'encode') ? message.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('') + MESSAGE_TERMINATOR : '';
        let messageIndex = 0, decodedMessage = '', bitsPerBlock = 3;

        for (let y = 0; y < ctx.canvas.height; y += BLOCK_SIZE) {
            for (let x = 0; x < ctx.canvas.width; x += BLOCK_SIZE) {
                if (mode === 'decode' && decodedMessage.endsWith(MESSAGE_TERMINATOR)) break;
                const block = new Float64Array(BLOCK_SIZE * BLOCK_SIZE);
                for (let i = 0; i < BLOCK_SIZE; i++) for (let j = 0; j < BLOCK_SIZE; j++) block[i * BLOCK_SIZE + j] = data[((y + i) * ctx.canvas.width + (x + j)) * 4 + 2]; // Blue channel
                const dctCoeffs = applyDCT(block);
                if (mode === 'encode') {
                    for(let i=0; i<bitsPerBlock && messageIndex < binaryMessage.length; i++) {
                        const bit = binaryMessage[messageIndex++];
                        const coeffIndex = [1, 2, 9, 16, 10, 3, 4, 11][i];
                        const val = Math.round(dctCoeffs[coeffIndex]);
                        dctCoeffs[coeffIndex] = (bit === '1') ? (val % 2 === 0 ? val + 1 : val) : (val % 2 !== 0 ? val - 1 : val);
                    }
                    const newBlock = applyIDCT(dctCoeffs);
                    for (let i = 0; i < BLOCK_SIZE; i++) for (let j = 0; j < BLOCK_SIZE; j++) data[((y + i) * ctx.canvas.width + (x + j)) * 4 + 2] = newBlock[i * BLOCK_SIZE + j];
                } else {
                    for(let i=0; i<bitsPerBlock; i++) {
                        const coeffIndex = [1, 2, 9, 16, 10, 3, 4, 11][i];
                        decodedMessage += (Math.round(dctCoeffs[coeffIndex]) % 2 === 0) ? '0' : '1';
                    }
                }
            }
            if (mode === 'decode' && decodedMessage.endsWith(MESSAGE_TERMINATOR)) break;
        }

        if (mode === 'encode') {
            ctx.putImageData(imageData, 0, 0);
        } else {
            const termIndex = decodedMessage.indexOf(MESSAGE_TERMINATOR);
            if(termIndex === -1) return null;
            const relevantBits = decodedMessage.substring(0, termIndex);
            let result = '';
            for(let i=0; i<relevantBits.length; i+=8) result += String.fromCharCode(parseInt(relevantBits.substring(i, i+8), 2));
            return result;
        }
    }
    return {
        encode: (ctx, message) => process(ctx, message, 'encode'),
        decode: (ctx) => process(ctx, null, 'decode')
    };
})();

// ===================================================================================
// Banknote Creation & Rendering
// ===================================================================================
async function renderFullNote(targetCanvas, jabData, visualData, integrityHash) {
    const { amount, serial, visualHash } = visualData;
    const ctx = targetCanvas.getContext("2d");
    const w = targetCanvas.width, h = targetCanvas.height, scale = w / 1350;

    // --- Draw background and patterns ---
    const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
    const baseHue = parseInt(visualHash.substring(0, 2), 16) / 255 * 360;
    bgGradient.addColorStop(0, `hsl(${baseHue}, 60%, 8%)`);
    bgGradient.addColorStop(1, `hsl(${baseHue}, 50%, 5%)`);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, w, h);
    
    // --- Draw text ---
    ctx.shadowColor="rgba(0,0,0,0.7)"; ctx.shadowBlur=8*scale; ctx.shadowOffsetX=2*scale; ctx.shadowOffsetY=2*scale;
    ctx.fillStyle="#EAEAEA"; ctx.font=`bold ${80*scale}px 'Roboto Mono'`; ctx.textAlign='left';
    ctx.fillText(serial.substring(4), 150*scale, 160*scale);
    ctx.font=`bold ${150*scale}px 'Roboto Mono'`; ctx.textAlign="right";
    ctx.shadowBlur=12*scale; ctx.shadowOffsetX=4*scale; ctx.shadowOffsetY=4*scale;
    ctx.fillText(amount.toString(), w-(120*scale), 190*scale); ctx.shadowColor="transparent";
    
    // --- Draw JAB Code ---
    const jabImg = new Image();
    jabImg.src = jabcodeApi.encode_message(JSON.stringify(jabData));
    await new Promise((resolve, reject) => { jabImg.onload = resolve; jabImg.onerror = reject; });
    const jabSize = JAB_CODE_REGION.width * scale;
    ctx.drawImage(jabImg, JAB_CODE_REGION.x * scale, JAB_CODE_REGION.y * scale, jabSize, jabSize);
    
    ctx.font=`${30*scale}px 'Roboto Mono'`; ctx.fillStyle="rgba(255,255,255,0.4)"; ctx.textAlign="center";
    ctx.fillText("Verified by Sadat Bank Authority (Falcon-512)", w/2, h - (60 * scale));

    // --- Embed integrity hash ---
    DCTStego.encode(ctx, integrityHash);
}

// ===================================================================================
// Event Handlers & Main Logic
// ===================================================================================
async function handleGenerateNewKeys() {
    const password = prompt("Enter a strong password to encrypt your new private key file:");
    if (!password) {
        updateKeyStatus('<span class="invalid">❌ Key generation cancelled.</span>', false);
        return;
    }

    updateKeyStatus('Generating new Falcon-512 key pair... This may take a moment.', true);
    keyGenTimeout = setTimeout(() => {
        updateKeyStatus('<span class="invalid">❌ Error: Key generation timed out. The process likely crashed due to high memory usage. Please refresh the page and try again.</span>', false);
        if (noteWorker) noteWorker.terminate();
        noteWorker = setupWorker();
        noteWorker.onmessage = handleWorkerMessage;
    }, 30000); 

    noteWorker.postMessage({ action: 'generateKey', payload: { password } });
}

async function handleImportPublicKey(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const keyData = JSON.parse(e.target.result);
            if (!keyData.publicKey) throw new Error("Invalid public key file format.");
            activeKeys.publicKey = utils.base64ToUint8Array(keyData.publicKey);
            updateKeyStatus('<span class="valid">✅ Public key imported. Ready for validation.</span>');
        } catch (error) {
            updateKeyStatus(`<span class="invalid">❌ Error importing public key: ${error.message}</span>`);
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

async function handleImportPrivateKey(event) {
    const file = event.target.files[0];
    if (!file) return;
    const password = prompt("Enter the password to decrypt the private key file:");
    if (!password) {
        updateKeyStatus('<span class="invalid">❌ Import cancelled. Password required.</span>');
        return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const encryptedData = JSON.parse(e.target.result);
            updateKeyStatus('Decrypting private key...', true);
            noteWorker.postMessage({ action: 'importKey', payload: { encryptedData, password } });
        } catch (error) {
            updateKeyStatus(`<span class="invalid">❌ Error importing private key: ${error.message}</span>`);
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

async function handleCreateNewNote() {
    if (!activeKeys.privateKey) {
        updateKeyStatus('<span class="invalid">❌ Cannot create note. No private key is active.</span>');
        return;
    }
    const amount = document.getElementById("amount-input").value;
    updateKeyStatus('Generating new banknote...', true);
    noteWorker.postMessage({ action: 'createNote', payload: { amount, privateKey: activeKeys.privateKey } });
}

async function handleDownloadBatch() {
    if (!activeKeys.privateKey) {
        alert("Error: No private key active.");
        return;
    }
    if (!window.showDirectoryPicker) {
        alert("Batch download requires a browser that supports the File System Access API.");
        return;
    }
    const quantity = parseInt(document.getElementById('quantity-input').value) || 1;
    const amount = document.getElementById("amount-input").value;

    try {
        const dirHandle = await window.showDirectoryPicker();
        updateValidationResult(`Starting batch creation for ${quantity} notes...`, true);
        
        noteWorker.postMessage({
            action: 'createBatch',
            payload: { quantity, amount, privateKey: activeKeys.privateKey }
        });
        
        const originalOnMessage = noteWorker.onmessage;
        noteWorker.onmessage = async (e) => {
            const { action, payload } = e.data;
            if (action === 'batchNoteCreated') {
                const { blob, jabData, index } = payload;
                const fileHandle = await dirHandle.getFileHandle(`SADAT-NOTE-${jabData.publicData.serial}.png`, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                updateValidationResult(`Successfully saved banknote ${index + 1} of ${quantity}.`, true);
            } else if (action === 'batchComplete') {
                updateValidationResult(`<span class="valid">✅ Batch creation complete. ${payload.quantity} notes saved.</span>`, false);
                noteWorker.onmessage = originalOnMessage; // Restore original handler
                handleCreateNewNote();
            } else {
                handleWorkerMessage(e);
            }
        };
    } catch (error) { if (error.name !== 'AbortError') updateValidationResult(`<span class="invalid">❌ Error: ${error.message}</span>`, false); }
}

async function handleFileSelectForValidation(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (!activeKeys.publicKey) {
        alert("Error: No public key is active for validation. Please import one.");
        return;
    }
    updateValidationResult(`Preparing image for validation...`, true);

    const fileUrl = URL.createObjectURL(file);
    const img = new Image();
    img.onload = async () => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1350; tempCanvas.height = 750;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
        
        updateValidationResult(`1. Reading JAB Code...`, true);
        let jabData;
        try {
            jabData = JSON.parse(await jabcodeApi.decode_message(tempCanvas.toDataURL()));
            if(!jabData.publicData || !jabData.commitment || !jabData.signature) throw new Error("Missing required data fields.");
        } catch(e) {
            updateValidationResult(`<span class="invalid">❌ FATAL ERROR: JAB Code unreadable or data corrupt.</span>`); return;
        }
        let resultHTML = `<span class="valid">✅ 1. JAB Code data read successfully.</span>\n`;

        resultHTML += `<span class="info">2. Verifying image integrity via DCT hash...</span>\n`;
        updateValidationResult(resultHTML, true);
        
        // **FIX**: Create a canonical (ordered) object for hashing to ensure consistency.
        const canonicalJabForHash = {
            publicData: jabData.publicData,
            commitment: jabData.commitment,
            signature: jabData.signature
        };
        const expectedHash = shake256(JSON.stringify(canonicalJabForHash), 256);
        const decodedHash = DCTStego.decode(tempCtx);
        
        if (decodedHash !== expectedHash) {
             resultHTML += `<span class="invalid">❌ FATAL ERROR: DCT integrity hash mismatch. Image has been tampered with or corrupted.</span>\n(Expected: ${expectedHash.substring(0,16)}... | Got: ${decodedHash ? decodedHash.substring(0,16) : 'null'}...)`;
             updateValidationResult(resultHTML); return;
        }
        resultHTML += `<span class="valid">✅ 2. DCT integrity hash matches.</span>\n`;

        resultHTML += `<span class="info">3. Verifying Falcon-512 signature...</span>`;
        updateValidationResult(resultHTML, true);
        
        noteWorker.postMessage({
            action: 'verifySignature',
            payload: { jabData, publicKey: activeKeys.publicKey }
        });
    };
    img.src = fileUrl;
    event.target.value = '';
}

// ===================================================================================
// Worker Setup and Communication
// ===================================================================================
function setupWorker() {
    const workerScript = `
        importScripts('./falcon.js', 'https://cdn.skypack.dev/js-sha3');
        let falconApi = null;
        const utils = {
            arrayBufferToBase64:b=>btoa(String.fromCharCode(...new Uint8Array(b))),
            base64ToUint8Array:b=>{const s=self.atob(b),l=s.length,B=new Uint8Array(l);for(let i=0;i<l;i++)B[i]=s.charCodeAt(i);return B}
        };
        const BankCrypto = (() => {
            const A="AES-GCM",I=100000,H="SHA-256",L=256;
            return {
                encrypt: async (k,p)=>{const s=self.crypto.getRandomValues(new Uint8Array(16)),i=self.crypto.getRandomValues(new Uint8Array(12)),m=await self.crypto.subtle.importKey("raw",new TextEncoder().encode(p),{name:"PBKDF2"},!1,["deriveKey"]),d=await self.crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:I,hash:H},m,{name:A,length:L},!0,["encrypt"]),e=await self.crypto.subtle.encrypt({name:A,iv:i},d,new TextEncoder().encode(JSON.stringify({k:utils.arrayBufferToBase64(k)})));return{c:utils.arrayBufferToBase64(e),s:utils.arrayBufferToBase64(s),i:utils.arrayBufferToBase64(i)}},
                decrypt: async (e,p)=>{const s=utils.base64ToUint8Array(e.s),i=utils.base64ToUint8Array(e.i),c=utils.base64ToUint8Array(e.c),m=await self.crypto.subtle.importKey("raw",new TextEncoder().encode(p),{name:"PBKDF2"},!1,["deriveKey"]),d=await self.crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:I,hash:H},m,{name:A,length:L},!0,["decrypt"]),B=await self.crypto.subtle.decrypt({name:A,iv:i},d,c);return utils.base64ToUint8Array(JSON.parse(new TextDecoder().decode(B)).k)}
            }
        })();
        
        self.onmessage = async ({data:{action,payload}}) => {
            if (!falconApi) falconApi = await pqcSignFalcon512();
            try {
                let result;
                switch(action) {
                    case 'generateKey':
                        const keyPair = await falconApi.keypair();
                        self.postMessage({status:'keyGenerated', payload:{
                            privateKey: keyPair.privateKey, publicKey: keyPair.publicKey,
                            encryptedData: await BankCrypto.encrypt(keyPair.privateKey, payload.password)
                        }});
                        break;
                    case 'importKey':
                        const privateKey = await BankCrypto.decrypt(payload.encryptedData, payload.password);
                        const publicKey = await falconApi.pubkey(privateKey);
                        self.postMessage({status:'keyImported', payload:{privateKey, publicKey}});
                        break;
                    case 'createNote':
                    case 'createBatch':
                        const isBatch = action === 'createBatch';
                        const quantity = isBatch ? payload.quantity : 1;
                        for (let i = 0; i < quantity; i++) {
                            const now = Date.now();
                            const publicData = { amount: parseInt(payload.amount), serial: "SDC-" + (now + i).toString().slice(-8) };
                            const privateData = { timestamp: now, creator: "SadatBank" };
                            const commitment = self.js_sha3.shake256(JSON.stringify(privateData), 256);
                            const dataToSign = JSON.stringify({ ...publicData, commitment }, Object.keys(publicData).sort().concat('commitment'));
                            const signature = await falconApi.sign(self.js_sha3.shake256(dataToSign, 1024), payload.privateKey);
                            const jabData = { publicData, commitment, signature: utils.arrayBufferToBase64(signature) };
                            
                            // **FIX**: Use a canonical (ordered) object for creating the integrity hash.
                            const canonicalJabForHash = {
                                publicData: jabData.publicData,
                                commitment: jabData.commitment,
                                signature: jabData.signature
                            };
                            const integrityHash = self.js_sha3.shake256(JSON.stringify(canonicalJabForHash), 256);
                            
                            const visualHash = self.js_sha3.shake256(publicData.serial, 256);
                            if(isBatch) {
                                const canvas = new OffscreenCanvas(1350, 750);
                                self.postMessage({action:'renderBatchNote', payload:{jabData, visualData:{...publicData, visualHash}, integrityHash, canvas, index:i}}, [canvas]);
                            } else {
                                self.postMessage({status:'noteCreated', payload:{jabData, visualData:{...publicData, visualHash}, integrityHash}});
                            }
                        }
                        if(isBatch) self.postMessage({action:'batchComplete', payload:{quantity}});
                        break;
                    case 'verifySignature':
                        const {jabData, publicKey} = payload;
                        const dataToVerify = JSON.stringify({ ...jabData.publicData, commitment: jabData.commitment }, Object.keys(jabData.publicData).sort().concat('commitment'));
                        const hashToVerify = self.js_sha3.shake256(dataToVerify, 1024);
                        const isValid = await falconApi.verify(utils.base64ToUint8Array(jabData.signature), hashToVerify, publicKey);
                        self.postMessage({status:'verificationComplete', payload:{isValid, publicData: jabData.publicData}});
                        break;
                }
            } catch(e) { self.postMessage({status:'error', payload:{message:e.message, stack:e.stack}}); }
        };
    `;
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    return new Worker(URL.createObjectURL(workerBlob), { type: 'module' });
}

function handleWorkerMessage(e) {
    const { status, payload, action } = e.data;
    
    if (action === 'renderBatchNote') { // Handle off-thread canvas rendering
        const { jabData, visualData, integrityHash, canvas, index } = payload;
        renderFullNote({ ...canvas, getContext: () => canvas.getContext('2d') }, jabData, visualData, integrityHash)
            .then(() => canvas.convertToBlob({ type: 'image/png' }))
            .then(blob => noteWorker.postMessage({ action: 'batchNoteCreated', payload: { blob, jabData, index } }));
        return;
    }

    switch (status) {
        case 'keyGenerated':
            clearTimeout(keyGenTimeout); // IMPORTANT: Cancel the timeout on success
            activeKeys = { privateKey: payload.privateKey, publicKey: payload.publicKey };
            utils.downloadFile(JSON.stringify({publicKey: utils.arrayBufferToBase64(payload.publicKey)}, null, 2), 'Sadat-public-key.json', 'application/json');
            utils.downloadFile(JSON.stringify(payload.encryptedData, null, 2), 'Sadat-private-key.json', 'application/json');
            updateKeyStatus('<span class="valid">✅ Keys generated and saved. Ready to create banknotes.</span>', false);
            updateControlsState(true);
            handleCreateNewNote();
            break;
        case 'keyImported':
            activeKeys = { privateKey: payload.privateKey, publicKey: payload.publicKey };
            updateKeyStatus('<span class="valid">✅ Private key imported successfully. Ready.</span>', false);
            updateControlsState(true);
            break;
        case 'noteCreated':
            renderFullNote(canvas, payload.jabData, payload.visualData, payload.integrityHash)
                .then(() => updateKeyStatus('<span class="valid">✅ New banknote design is ready.</span>', false))
                .catch(err => updateKeyStatus(`<span class="invalid">❌ Failed to render note: ${err.message}</span>`, false));
            break;
        case 'verificationComplete':
            let resultHTML = document.getElementById('validation-result').innerHTML.split('\n').slice(0, 4).join('\n') + '\n';
            if(payload.isValid) {
                resultHTML += `<span class="valid">✅ 3. Falcon-512 Signature is valid.</span>\n\n<hr style="border-color: var(--border-color); margin-top: 15px;">`;
                resultHTML += `<span style="font-size:14px;font-weight:600;" class="valid">✅ VERDICT: Banknote is authentic.</span>\n`;
                resultHTML += `   Amount: ${payload.publicData.amount}\n   Serial: ${payload.publicData.serial}`;
            } else {
                resultHTML += `<span class="invalid">❌ 3. Falcon-512 Signature is INVALID. Forgery detected.</span>`;
            }
            updateValidationResult(resultHTML);
            break;
        case 'error':
            clearTimeout(keyGenTimeout); // IMPORTANT: Cancel the timeout on error
            updateKeyStatus(`<span class="invalid">❌ Worker Error: ${payload.message}</span>`, false);
            console.error("Worker Error:", payload);
            break;
    }
}

// ===================================================================================
// Application Initialization
// ===================================================================================
async function main() {
    updateControlsState(false);
    updateKeyStatus('Initializing systems...', true);
    try {
        jabcodeApi = new JabcodeJSInterface();
        noteWorker = setupWorker();
        noteWorker.onmessage = handleWorkerMessage;
        updateKeyStatus('✅ Systems ready. Please generate or import keys to begin.', false);
    } catch (e) {
        updateKeyStatus(`<span class="invalid">❌ Critical Error: ${e.message}.</span>`, false);
        return;
    }
    document.getElementById('generate-keys-button').addEventListener('click', handleGenerateNewKeys);
    document.getElementById('import-public-key').addEventListener('change', handleImportPublicKey);
    document.getElementById('import-private-key').addEventListener('change', handleImportPrivateKey);
    document.getElementById('create-note-button').addEventListener('click', handleCreateNewNote);
    document.getElementById('download-batch-button').addEventListener('click', handleDownloadBatch);
    document.getElementById('validator-input').addEventListener('change', handleFileSelectForValidation);
}

main();
</script>
</body>
</html>

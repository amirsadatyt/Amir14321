<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Quantum Wallet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

    <style>
        :root {
            --bg: #0d1117; --primary: #161b22; --secondary: #010409;
            --text: #e6edf3; --text-muted: #7d8590;
            --border: #30363d; --accent: #58a6ff; --accent-hover: #79c0ff;
            --success: #3fb950; --error: #f85149; --warning: #d29922;
        }
        * { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: var(--bg); color: var(--text); }
        .container { max-width: 500px; margin: 20px auto; padding: 0 15px; }
        .header { text-align: center; padding: 20px 0; border-bottom: 1px solid var(--border); }
        .header h1 { margin: 0; font-size: 24px; }
        .header h1 span { font-weight: 700; color: var(--accent); }
        .header p { margin: 5px 0 0; color: var(--text-muted); font-size: 14px; }
        
        .wallet-section { margin-top: 20px; }
        #wallet-notes { min-height: 100px; background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .note-card { background: var(--secondary); border: 1px solid var(--border); border-radius: 6px; padding: 15px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s ease; }
        .note-card.selected { border-color: var(--accent); box-shadow: 0 0 10px rgba(88, 166, 255, 0.5); }
        .note-card:hover { border-color: var(--text-muted); }
        .note-amount { font-family: 'Roboto Mono', monospace; font-size: 20px; font-weight: 700; color: var(--accent); }
        .note-serial { font-size: 12px; color: var(--text-muted); font-family: 'Roboto Mono', monospace; }
        .wallet-placeholder { text-align: center; color: var(--text-muted); font-size: 14px; padding: 20px; }

        .actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        .actions-mint { display: flex; gap: 10px; margin-top: 10px; }
        .actions-mint input { flex-grow: 1; }
        button, input {
            width: 100%; padding: 12px; font-size: 16px; font-family: inherit; border-radius: 6px;
            border: 1px solid var(--border); background: var(--primary); color: var(--text);
            transition: all 0.2s ease; font-weight: 500;
        }
        button { cursor: pointer; }
        button:hover:not(:disabled) { background-color: #21262d; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.primary { background-color: var(--accent); color: var(--secondary); font-weight: 600; border-color: var(--accent); }
        button.primary:hover:not(:disabled) { background-color: var(--accent-hover); }
        
        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(5px); }
        .modal-content { background: var(--primary); padding: 25px; border-radius: 8px; border: 1px solid var(--border); text-align: center; max-width: 90%; width: 400px; }
        .modal-content h2 { margin: 0 0 15px; }
        .modal-content p { color: var(--text-muted); margin: 0 0 20px; }
        .modal-spinner { border: 4px solid var(--border); border-top-color: var(--accent); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #qr-code-display { background: white; padding: 10px; margin: 0 auto 20px; width: fit-content; border-radius: 6px; }
        #qr-code-display canvas { display: block; }
        #video-feed { width: 100%; border-radius: 6px; margin-bottom: 20px; }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>Sadat <span>Quantum Wallet</span></h1>
        <p>A Self-Contained, Offline, Peer-to-Peer Digital Banknote System</p>
    </div>

    <div class="wallet-section">
        <div id="wallet-notes">
            <div class="wallet-placeholder">Your wallet is empty.</div>
        </div>
    </div>

    <div class="actions">
        <button id="send-btn" class="primary" disabled>Send</button>
        <button id="receive-btn">Receive</button>
    </div>
    
    <div id="mint-section" style="display: none;">
        <hr style="border: none; border-top: 1px solid var(--border); margin: 20px 0;">
        <h3 style="text-align: center; margin-top: 0;">Mint New Banknote</h3>
        <div class="actions-mint">
            <input type="number" id="mint-amount-input" placeholder="Enter amount" value="1000">
            <button id="mint-btn">Mint Note</button>
        </div>
    </div>
    
    <div id="identity-section" style="display: none;">
        <hr style="border: none; border-top: 1px solid var(--border); margin: 20px 0;">
        <h3 style="text-align: center; margin-top: 0;">Identity Management</h3>
        <p style="text-align:center; font-size: 14px; color: var(--text-muted);">This will erase your current identity and wallet. Use with caution.</p>
        <button id="reset-identity-btn" style="background-color: var(--error); border-color: var(--error); color: white;">Reset Identity & Erase Wallet</button>
    </div>
</div>

<div id="identity-creation-modal" class="modal-overlay">
    <div class="modal-content">
        <h2>Welcome</h2>
        <p>Create a secure password for your new quantum-resistant identity. This password encrypts your private key and is required for all transactions.</p>
        <input type="password" id="identity-password" placeholder="Enter a strong password">
        <button id="create-identity-btn" class="primary" style="margin-top: 15px;">Create Identity</button>
    </div>
</div>

<div id="password-prompt-modal" class="modal-overlay">
    <div class="modal-content">
        <h2 id="password-prompt-title">Enter Password</h2>
        <p id="password-prompt-text">Your password is required to authorize this action.</p>
        <input type="password" id="action-password" placeholder="Enter your password">
        <div style="display:flex; gap: 10px; margin-top: 15px;">
            <button id="password-cancel-btn">Cancel</button>
            <button id="password-confirm-btn" class="primary">Confirm</button>
        </div>
    </div>
</div>

<div id="transfer-modal" class="modal-overlay">
    <div class="modal-content">
        <h2 id="transfer-title">Initializing</h2>
        <div class="modal-spinner"></div>
        <p id="transfer-status">Please wait...</p>
        <div id="qr-code-display" style="display: none;"></div>
        <video id="video-feed" style="display: none;"></video>
        <button id="transfer-cancel-btn">Cancel</button>
    </div>
</div>


<script type="module">
// --- DEPENDENCIES ---
import pqcSignFalcon1024 from 'https://cdn.jsdelivr.net/gh/Amir-S-T/pqc-sign-falcon-1024/pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

// ===================================================================================
// 1. CORE CRYPTO ENGINE
// ===================================================================================
const CryptoEngine = (() => {
    let falconApi = null;
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 250000;

    // --- Private Helper Functions ---
    const getPbkdf2Key = async (password, salt) => {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw", passwordBuffer, { name: "PBKDF2" }, false, ["deriveKey"]);
        return await crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" },
            importedKey, { name: AES_ALGO, length: 256 }, false, ["encrypt", "decrypt"]
        );
    };

    const arrayBufferToBase64 = (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer)));
    const base64ToUint8Array = (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes;
    };

    // --- Public API ---
    return {
        async initialize() {
            if (!falconApi) {
                falconApi = await pqcSignFalcon1024();
            }
            return !!falconApi;
        },

        async generateIdentity() {
            if (!falconApi) throw new Error("Falcon API not initialized.");
            return falconApi.keypair();
        },

        async encryptPrivateKey(privateKey, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const key = await getPbkdf2Key(password, salt);
            const encryptedData = await crypto.subtle.encrypt({ name: AES_ALGO, iv }, key, privateKey);
            return {
                encryptedKeyB64: arrayBufferToBase64(encryptedData),
                saltB64: arrayBufferToBase64(salt),
                ivB64: arrayBufferToBase64(iv),
            };
        },

        async decryptPrivateKey(encryptedPayload, password) {
            const salt = base64ToUint8Array(encryptedPayload.saltB64);
            const iv = base64ToUint8Array(encryptedPayload.ivB64);
            const data = base64ToUint8Array(encryptedPayload.encryptedKeyB64);
            const key = await getPbkdf2Key(password, salt);
            const decryptedKey = await crypto.subtle.decrypt({ name: AES_ALGO, iv }, key, data);
            return new Uint8Array(decryptedKey);
        },
        
        async signData(data, privateKey) {
            if (!falconApi) throw new Error("Falcon API not initialized.");
            const dataHash = shake256.create().update(JSON.stringify(data)).digest();
            const { signature } = await falconApi.sign(dataHash, privateKey);
            return signature;
        },

        async verifySignature(signature, data, publicKey) {
            if (!falconApi) throw new Error("Falcon API not initialized.");
            const dataHash = shake256.create().update(JSON.stringify(data)).digest();
            return falconApi.verify(signature, dataHash, publicKey);
        },
        
        generateSpendSeed() {
            return crypto.getRandomValues(new Uint8Array(32)); // 256-bit secret
        },
        
        // Using AES-GCM to encrypt/decrypt the seed with a shared secret derived from Falcon keys
        // NOTE: In a real-world scenario, a proper key exchange like Kyber would be used.
        // For this self-contained demo, we simulate it with a simple hash.
        async encryptSeed(seed, recipientPublicKey) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            // Simulate a shared secret. THIS IS NOT SECURE FOR PRODUCTION.
            const sharedSecretHash = shake256.create().update(recipientPublicKey).digest();
            const key = await crypto.subtle.importKey("raw", sharedSecretHash.slice(0,32), { name: AES_ALGO }, false, ["encrypt"]);
            const encryptedSeed = await crypto.subtle.encrypt({ name: AES_ALGO, iv }, key, seed);
            return JSON.stringify({
                iv: arrayBufferToBase64(iv),
                data: arrayBufferToBase64(encryptedSeed)
            });
        },

        async decryptSeed(encryptedSeedPayload, ownPrivateKey) {
            const payload = JSON.parse(encryptedSeedPayload);
            const iv = base64ToUint8Array(payload.iv);
            const data = base64ToUint8Array(payload.data);
            const publicKey = (await falconApi.keypairFromPrivateKey(ownPrivateKey)).publicKey;
            const sharedSecretHash = shake256.create().update(publicKey).digest();
            const key = await crypto.subtle.importKey("raw", sharedSecretHash.slice(0,32), { name: AES_ALGO }, false, ["decrypt"]);
            const decryptedSeed = await crypto.subtle.decrypt({ name: AES_ALGO, iv }, key, data);
            return new Uint8Array(decryptedSeed);
        },

        utils: { arrayBufferToBase64, base64ToUint8Array }
    };
})();


// ===================================================================================
// 2. WALLET & DATA MANAGER
// ===================================================================================
const WalletManager = (() => {
    const IDENTITY_KEY = 'sadat_wallet_identity';
    const NOTES_KEY = 'sadat_wallet_notes';
    let identity = null;
    let notes = [];

    return {
        load() {
            const idData = localStorage.getItem(IDENTITY_KEY);
            const notesData = localStorage.getItem(NOTES_KEY);
            if (idData) identity = JSON.parse(idData);
            if (notesData) notes = JSON.parse(notesData);
            return !!identity;
        },

        saveIdentity(id) {
            identity = id;
            localStorage.setItem(IDENTITY_KEY, JSON.stringify(id));
        },
        
        saveNotes() {
            localStorage.setItem(NOTES_KEY, JSON.stringify(notes));
        },

        getIdentity: () => identity,
        getNotes: () => notes,
        
        addNote(note) {
            notes.push(note);
            this.saveNotes();
        },

        removeNote(serial) {
            notes = notes.filter(n => n.serial !== serial);
            this.saveNotes();
        },

        getNoteBySerial(serial) {
            return notes.find(n => n.serial === serial);
        },

        eraseAll() {
            identity = null;
            notes = [];
            localStorage.removeItem(IDENTITY_KEY);
            localStorage.removeItem(NOTES_KEY);
        }
    };
})();

// ===================================================================================
// 3. UI MANAGER
// ===================================================================================
const UIManager = (() => {
    const DOMElements = {
        walletNotes: document.getElementById('wallet-notes'),
        sendBtn: document.getElementById('send-btn'),
        receiveBtn: document.getElementById('receive-btn'),
        mintSection: document.getElementById('mint-section'),
        identitySection: document.getElementById('identity-section'),
        mintAmountInput: document.getElementById('mint-amount-input'),
        mintBtn: document.getElementById('mint-btn'),
        resetIdentityBtn: document.getElementById('reset-identity-btn'),
        identityModal: document.getElementById('identity-creation-modal'),
        identityPasswordInput: document.getElementById('identity-password'),
        createIdentityBtn: document.getElementById('create-identity-btn'),
        passwordModal: document.getElementById('password-prompt-modal'),
        passwordModalTitle: document.getElementById('password-prompt-title'),
        passwordModalText: document.getElementById('password-prompt-text'),
        passwordInput: document.getElementById('action-password'),
        passwordConfirmBtn: document.getElementById('password-confirm-btn'),
        passwordCancelBtn: document.getElementById('password-cancel-btn'),
        transferModal: document.getElementById('transfer-modal'),
        transferTitle: document.getElementById('transfer-title'),
        transferStatus: document.getElementById('transfer-status'),
        transferCancelBtn: document.getElementById('transfer-cancel-btn'),
        qrCodeDisplay: document.getElementById('qr-code-display'),
        videoFeed: document.getElementById('video-feed'),
        spinner: document.querySelector('.modal-spinner'),
    };

    let selectedNoteSerial = null;
    let passwordResolver = null;
    let videoStream = null;

    const showModal = (modal) => modal.style.display = 'flex';
    const hideModal = (modal) => modal.style.display = 'none';

    DOMElements.createIdentityBtn.onclick = async () => {
        const password = DOMElements.identityPasswordInput.value;
        if (password.length < 8) {
            alert("Password must be at least 8 characters long.");
            return;
        }
        DOMElements.createIdentityBtn.disabled = true;
        DOMElements.createIdentityBtn.innerText = 'Creating...';
        
        const keyPair = await CryptoEngine.generateIdentity();
        const encryptedPayload = await CryptoEngine.encryptPrivateKey(keyPair.privateKey, password);
        
        WalletManager.saveIdentity({
            publicKeyB64: CryptoEngine.utils.arrayBufferToBase64(keyPair.publicKey),
            encryptedPrivateKeyPayload: encryptedPayload
        });
        
        hideModal(DOMElements.identityModal);
        App.init();
    };

    DOMElements.passwordConfirmBtn.onclick = () => {
        if (passwordResolver) {
            passwordResolver(DOMElements.passwordInput.value);
            passwordResolver = null;
        }
        DOMElements.passwordInput.value = '';
        hideModal(DOMElements.passwordModal);
    };

    DOMElements.passwordCancelBtn.onclick = () => {
        if (passwordResolver) {
            passwordResolver(null); // Resolve with null on cancel
            passwordResolver = null;
        }
        DOMElements.passwordInput.value = '';
        hideModal(DOMElements.passwordModal);
    };
    
    return {
        DOMElements,
        
        renderWallet() {
            const notes = WalletManager.getNotes();
            DOMElements.walletNotes.innerHTML = '';
            if (notes.length === 0) {
                DOMElements.walletNotes.innerHTML = '<div class="wallet-placeholder">Your wallet is empty. Mint a new note to begin.</div>';
            } else {
                notes.forEach(note => {
                    const card = document.createElement('div');
                    card.className = 'note-card';
                    card.dataset.serial = note.serial;
                    card.innerHTML = `
                        <div>
                            <div class="note-amount">${note.amount.toLocaleString()}</div>
                            <div class="note-serial">Serial: ${note.serial}</div>
                        </div>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    `;
                    card.onclick = () => {
                        document.querySelectorAll('.note-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        selectedNoteSerial = note.serial;
                        DOMElements.sendBtn.disabled = false;
                    };
                    DOMElements.walletNotes.appendChild(card);
                });
            }
            DOMElements.sendBtn.disabled = true;
            selectedNoteSerial = null;
        },

        showIdentityCreation() {
            showModal(DOMElements.identityModal);
        },
        
        showMainInterface() {
            DOMElements.mintSection.style.display = 'block';
            DOMElements.identitySection.style.display = 'block';
        },
        
        promptForPassword(title, text) {
            return new Promise(resolve => {
                passwordResolver = resolve;
                DOMElements.passwordModalTitle.innerText = title;
                DOMElements.passwordModalText.innerText = text;
                showModal(DOMElements.passwordModal);
            });
        },
        
        showTransferModal(opts) {
            DOMElements.transferTitle.innerText = opts.title;
            DOMElements.transferStatus.innerText = opts.status;
            DOMElements.spinner.style.display = opts.showSpinner ? 'block' : 'none';
            DOMElements.qrCodeDisplay.style.display = 'none';
            DOMElements.videoFeed.style.display = 'none';
            showModal(DOMElements.transferModal);
        },

        hideTransferModal() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            hideModal(DOMElements.transferModal);
        },
        
        displayQRCode(data) {
            DOMElements.qrCodeDisplay.innerHTML = '';
            const qr = qrcode(0, 'L');
            qr.addData(data);
            qr.make();
            DOMElements.qrCodeDisplay.innerHTML = qr.createImgTag(4);
            DOMElements.qrCodeDisplay.style.display = 'block';
        },
        
        startQRScanner(callback) {
            DOMElements.videoFeed.style.display = 'block';
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
            .then(stream => {
                videoStream = stream;
                DOMElements.videoFeed.srcObject = stream;
                DOMElements.videoFeed.play();
                requestAnimationFrame(tick);
            });

            function tick() {
                if (DOMElements.videoFeed.readyState === DOMElements.videoFeed.HAVE_ENOUGH_DATA) {
                    const canvas = document.createElement('canvas');
                    canvas.width = DOMElements.videoFeed.videoWidth;
                    canvas.height = DOMElements.videoFeed.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(DOMElements.videoFeed, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    if (code) {
                        callback(code.data);
                        return; // Stop scanning
                    }
                }
                if (videoStream) {
                   requestAnimationFrame(tick);
                }
            }
        },
        
        getSelectedNoteSerial: () => selectedNoteSerial
    };
})();

// ===================================================================================
// 4. TRANSFER MANAGER (NFC & QR)
// ===================================================================================
const TransferManager = (() => {
    let nfcController = null;

    const isNfcSupported = () => 'NDEFReader' in window;

    return {
        async send(payload) {
             return new Promise(async (resolve, reject) => {
                const transferPayload = JSON.stringify(payload);
                
                if (isNfcSupported()) {
                    try {
                        const ndef = new NDEFReader();
                        UIManager.DOMElements.transferCancelBtn.onclick = () => {
                            nfcController.abort();
                            reject(new Error("Transfer cancelled by user."));
                        };
                        UIManager.showTransferModal({
                           title: "Ready to Send",
                           status: "Bring the recipient's device close to yours to initiate NFC transfer.",
                           showSpinner: true
                        });
                        await ndef.write(transferPayload);
                        resolve({ method: "NFC" });
                    } catch (error) {
                         // Fallback to QR code if NFC fails or is cancelled
                        UIManager.showTransferModal({
                           title: "NFC Failed. Use QR Code.",
                           status: "Ask the recipient to scan this QR code with their wallet.",
                           showSpinner: false
                        });
                        UIManager.displayQRCode(transferPayload);
                        // Here, we just display. The transaction completes when the other party scans.
                        // For this demo, we can't automatically know when it's scanned.
                        UIManager.DOMElements.transferCancelBtn.onclick = () => {
                             reject(new Error("Transfer cancelled."));
                        }
                    }
                } else {
                    // Directly go to QR code if NFC is not supported
                    UIManager.showTransferModal({
                       title: "Ready to Send via QR",
                       status: "Ask the recipient to scan this QR code with their wallet.",
                       showSpinner: false
                    });
                    UIManager.displayQRCode(transferPayload);
                     UIManager.DOMElements.transferCancelBtn.onclick = () => {
                         reject(new Error("Transfer cancelled."));
                    }
                }
            });
        },

        async receive() {
            return new Promise(async (resolve, reject) => {
                UIManager.DOMElements.transferCancelBtn.onclick = () => {
                    if (nfcController) nfcController.abort();
                    reject(new Error("Receive cancelled."));
                };
                
                if (isNfcSupported()) {
                    try {
                        const ndef = new NDEFReader();
                        nfcController = new AbortController();
                        UIManager.showTransferModal({
                           title: "Ready to Receive",
                           status: "Listening for NFC transfer... Or scan a QR code.",
                           showSpinner: true
                        });
                        
                        ndef.onreading = event => {
                            const decoder = new TextDecoder();
                            const payload = decoder.decode(event.message.records[0].data);
                            resolve(JSON.parse(payload));
                        };
                        
                        await ndef.scan({ signal: nfcController.signal });
                    } catch (error) {
                        UIManager.showTransferModal({
                           title: "NFC Error. Scan QR.",
                           status: "Point your camera at the sender's QR code.",
                           showSpinner: false
                        });
                        UIManager.startQRScanner((data) => resolve(JSON.parse(data)));
                    }
                } else {
                     UIManager.showTransferModal({
                           title: "Ready to Receive via QR",
                           status: "Point your camera at the sender's QR code.",
                           showSpinner: false
                        });
                    UIManager.startQRScanner((data) => resolve(JSON.parse(data)));
                }
            });
        }
    };
})();

// ===================================================================================
// 5. MAIN APPLICATION LOGIC
// ===================================================================================
const App = (() => {

    const createBanknoteObject = async (amount, guardianIdentity) => {
        const serial = 'S' + Date.now().toString().slice(-8) + Math.random().toString(36).substring(2, 6).toUpperCase();
        const spendSeed = CryptoEngine.generateSpendSeed();
        
        const noteData = {
            serial,
            amount,
            guardianPublicKeyB64: guardianIdentity.publicKeyB64,
        };

        const signature = await CryptoEngine.signData(noteData, guardianIdentity.decryptedPrivateKey);

        return {
            ...noteData,
            signatureB64: CryptoEngine.utils.arrayBufferToBase64(signature),
            currentOwnerPublicKeyB64: guardianIdentity.publicKeyB64,
            spendSeedEncryptedPayload: await CryptoEngine.encryptSeed(spendSeed, CryptoEngine.utils.base64ToUint8Array(guardianIdentity.publicKeyB64))
        };
    };

    const handleMint = async () => {
        const amount = parseInt(UIManager.DOMElements.mintAmountInput.value);
        if (isNaN(amount) || amount <= 0) {
            alert("Please enter a valid amount.");
            return;
        }

        const password = await UIManager.promptForPassword("Mint Note", `Enter your password to authorize minting a note of ${amount.toLocaleString()}.`);
        if (!password) return;

        try {
            const identity = WalletManager.getIdentity();
            const decryptedPrivateKey = await CryptoEngine.decryptPrivateKey(identity.encryptedPrivateKeyPayload, password);
            const guardianIdentity = { ...identity, decryptedPrivateKey };
            
            const newNote = await createBanknoteObject(amount, guardianIdentity);
            
            WalletManager.addNote(newNote);
            UIManager.renderWallet();
            alert(`Successfully minted banknote with serial ${newNote.serial}.`);

        } catch (e) {
            alert("Minting failed. Incorrect password or cryptographic error.");
            console.error(e);
        }
    };

    const handleSend = async () => {
        const serial = UIManager.getSelectedNoteSerial();
        if (!serial) {
            alert("Please select a banknote to send.");
            return;
        }
        
        const noteToSend = WalletManager.getNoteBySerial(serial);

        const password = await UIManager.promptForPassword("Send Banknote", `Enter password to send the note for ${noteToSend.amount.toLocaleString()}.`);
        if (!password) return;

        try {
            // 1. Decrypt sender's private key
            const identity = WalletManager.getIdentity();
            const decryptedPrivateKey = await CryptoEngine.decryptPrivateKey(identity.encryptedPrivateKeyPayload, password);

            // 2. Decrypt the ONE-TIME spend seed
            const spendSeed = await CryptoEngine.decryptSeed(noteToSend.spendSeedEncryptedPayload, decryptedPrivateKey);
            
            // This is the "Spend-and-Burn" key. We'll use the private key to sign, but conceptually, possession of the seed allows it.
            // A more complex implementation would derive a one-time key from the seed.
            
            // 3. Initiate transfer to get recipient's public key
            const recipientData = await TransferManager.receive(); // A bit of a hack: receiver starts first
            const recipientPublicKeyB64 = recipientData.publicKeyB64;
            
            // 4. Create the NEW banknote state for the recipient
            const newSpendSeed = CryptoEngine.generateSpendSeed();
            const newNoteState = {
                ...noteToSend,
                currentOwnerPublicKeyB64: recipientPublicKeyB64,
                spendSeedEncryptedPayload: await CryptoEngine.encryptSeed(newSpendSeed, CryptoEngine.utils.base64ToUint8Array(recipientPublicKeyB64))
            };
            
            // The signature proves the transition from the old state to new state.
            const spendSignature = await CryptoEngine.signData({ from: noteToSend, to: newNoteState }, decryptedPrivateKey);

            const finalPayload = {
                note: newNoteState,
                spendSignatureB64: CryptoEngine.utils.arrayBufferToBase64(spendSignature)
            };
            
            // 5. Send the new banknote state
            await TransferManager.send(finalPayload);
            
            // 6. The "BURN" step: remove the note from our wallet
            WalletManager.removeNote(serial);
            UIManager.renderWallet();
            
            UIManager.hideTransferModal();
            alert("Banknote sent successfully!");

        } catch (e) {
            UIManager.hideTransferModal();
            alert(`Send failed: ${e.message}`);
            console.error(e);
        }
    };
    
    const handleReceive = async () => {
        try {
             const identity = WalletManager.getIdentity();
             const payload = { publicKeyB64: identity.publicKeyB64 };

             // Announce our public key so the sender can get it
             // This is simplified. The sender would start a receive-like process first.
             const transferPromise = TransferManager.receive();
             await TransferManager.send(payload); // Send our public key
             
             const receivedData = await transferPromise;

            // Verification
            const { note, spendSignatureB64 } = receivedData;
            const guardianPublicKey = CryptoEngine.utils.base64ToUint8Array(note.guardianPublicKeyB64);
            const spendSignature = CryptoEngine.utils.base64ToUint8Array(spendSignatureB64);
            
            // 1. Verify the original guardian signature
            const coreNoteData = { serial: note.serial, amount: note.amount, guardianPublicKeyB64: note.guardianPublicKeyB64 };
            const isGuardianSigValid = await CryptoEngine.verifySignature(CryptoEngine.utils.base64ToUint8Array(note.signatureB64), coreNoteData, guardianPublicKey);
            if (!isGuardianSigValid) throw new Error("Guardian signature is invalid! This is a forged banknote.");

            // 2. Check if we are the new owner
            if (note.currentOwnerPublicKeyB64 !== identity.publicKeyB64) {
                throw new Error("This banknote was not addressed to you.");
            }
            
            // 3. Add to wallet
            WalletManager.addNote(note);
            UIManager.renderWallet();
            UIManager.hideTransferModal();
            alert(`Successfully received banknote for ${note.amount.toLocaleString()}`);

        } catch (e) {
             UIManager.hideTransferModal();
             alert(`Receive failed: ${e.message}`);
             console.error(e);
        }
    };
    
    return {
        async init() {
            try {
                await CryptoEngine.initialize();
            } catch (e) {
                document.body.innerHTML = "<h1>Critical Error</h1><p>Could not load cryptographic modules. This application cannot run.</p>";
                return;
            }
            
            if (WalletManager.load()) {
                UIManager.renderWallet();
                UIManager.showMainInterface();
            } else {
                UIManager.showIdentityCreation();
            }

            // Attach event listeners
            UIManager.DOMElements.mintBtn.addEventListener('click', handleMint);
            UIManager.DOMElements.sendBtn.addEventListener('click', handleReceive); // Receiver must start first
            UIManager.DOMElements.receiveBtn.addEventListener('click', handleSend);
            UIManager.DOMElements.resetIdentityBtn.addEventListener('click', () => {
                if(confirm("Are you sure? This will permanently erase your keys and all banknotes in this wallet.")) {
                    WalletManager.eraseAll();
                    window.location.reload();
                }
            });
            UIManager.DOMElements.transferCancelBtn.addEventListener('click', UIManager.hideTransferModal);
        }
    };
})();

// --- Start the application ---
window.onload = App.init;

</script>
</body>
</html>



<!doctype html>
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<title>Sadat — Split JAB & QR Banknote (Prototype)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Tahoma, Arial; background:#0f0f18;color:#eaeaf2;padding:18px}
  .note{width:1000px;margin:10px auto;background:#11121a;border-radius:12px;padding:18px;box-shadow:0 8px 40px rgba(0,0,0,.6)}
  canvas{width:100%;border-radius:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  button,input{padding:10px 12px;border-radius:8px;border:1px solid rgba(124,77,255,.15);background:#151624;color:#fff}
  .status{font-family:monospace;background:#0b0b11;padding:10px;border-radius:8px;margin-top:10px}
</style>
</head>
<body>
<h2 style="text-align:center">Sadat — Split JAB (راست) & QR (چپ) — Self-contained</h2>
<div class="note">
  <canvas id="canvas" width="1350" height="750"></canvas>
  <div class="controls">
    <input id="amount" placeholder="مبلغ" value="50000">
    <input id="serial" placeholder="سریال" value="SN123456">
    <button id="gen">🔐 ساخت اسکناس</button>
    <button id="validate">🔎 بررسی از تصویر</button>
    <button id="download">💾 دانلود PNG</button>
  </div>
  <div id="status" class="status">وضعیت: آماده</div>
</div>

<!-- کتابخانه‌های کوچک: pako برای فشرده‌سازی و jabcode (فرض موجود) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<!-- فرض: jabcodeJSLib.min.js و pqcSignFalcon1024.min.js مشابه فایل قبلی در فولدر هستند -->
<script type="module">
import JabcodeJSInterface from './jabcodeJSLib.min.js';
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';

const jab = new JabcodeJSInterface();
let falconApi = null;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const status = document.getElementById('status');

function updateStatus(t){ status.textContent = 'وضعیت: ' + t; }

// --- Utility helpers ---
const U = {
  toUtf8: s => new TextEncoder().encode(s),
  fromUtf8: b => new TextDecoder().decode(b),
  hex: b=>Array.from(b).map(x=>('0'+x.toString(16)).slice(-2)).join(''),
  rndBytes: n => { const a=new Uint8Array(n); crypto.getRandomValues(a); return a; },
  xor: (a,b)=>{ const r=new Uint8Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]^b[i]; return r }
}

// SHA-256 helper
async function sha256(buf){ const h = await crypto.subtle.digest('SHA-256', buf); return new Uint8Array(h); }

// AES-GCM encrypt/decrypt (key is raw bytes)
async function aesGcmEncrypt(keyRaw, plaintext, aad=new Uint8Array()){ const key = await crypto.subtle.importKey('raw', keyRaw,{name:'AES-GCM'},false,['encrypt']); const iv = U.rndBytes(12); const ct = await crypto.subtle.encrypt({name:'AES-GCM',iv,additionalData:aad}, key, plaintext); return {iv:new Uint8Array(iv), ct:new Uint8Array(ct)} }
async function aesGcmDecrypt(keyRaw, iv, ct, aad=new Uint8Array()){ const key = await crypto.subtle.importKey('raw', keyRaw,{name:'AES-GCM'},false,['decrypt']); const pt = await crypto.subtle.decrypt({name:'AES-GCM',iv,additionalData:aad}, key, ct); return new Uint8Array(pt) }

// compress with pako
function compress(dataUint8){ return pako.deflate(dataUint8); }
function decompress(dataUint8){ return pako.inflate(dataUint8); }

// canonicalize printed fields (amount, serial, verificationKey (printed))
function canonicalPrinted(amount, serial, printedKey){ // deterministic small binary
  const enc = new TextEncoder();
  const a = new Uint32Array([Number(amount) || 0]);
  const s = enc.encode(serial.padEnd(12, ' ')).slice(0,12);
  const k = enc.encode(printedKey.padEnd(16,' ')).slice(0,16);
  const buf = new Uint8Array(4 + 12 + 16);
  buf.set(new Uint8Array(a.buffer), 0); buf.set(s,4); buf.set(k,16);
  return buf;
}

// build full sensitive payload (fields that cannot be printed) — in this prototype we simulate
function buildSensitivePayload(extra){ // extra: object
  // Example: includes metadata, two large public keys, issuer notes, expiry, nonce
  const json = JSON.stringify(extra);
  return U.toUtf8(json);
}

// --- High-level scheme ---
// 1) payload_full = canonical_printed || sensitive_payload
// 2) compress payload_full
// 3) generate random symmetric key K (32B), encrypt compressed with AES-GCM
// 4) split K into two parts K1,K2 with XOR (K = K1 XOR K2). Put K1 inside QR (left), K2 inside JAB (right)
// 5) compute H = SHA256(compressed_plaintext) and sign H with Falcon (sigF)
// 6) Put in QR: {serial, amount, H, K1, sigF, small meta}
//    Put in JAB: {serial, amount, H, K2, optional sphincs_sig or cert_id, small meta}
// 7) To validate need both QR and JAB: combine K1^K2 -> K, decrypt AES-> get compressed payload, verify H, verify signature(s)

// This keeps printed visible data minimal (amount,serial,printedKey). All other sensitive info lives in encrypted payload inside both codes (but both halves required).

// --- create and render note ---
async function drawNote(amount, serial){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle='#0b0b10'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#ddd'; ctx.font='bold 80px monospace'; ctx.textAlign='left'; ctx.fillText(serial,120,150);
  ctx.font='bold 160px monospace'; ctx.textAlign='right'; ctx.fillText(amount.toString(), canvas.width-120,180);
}

async function generateBanknote(){
  updateStatus('در حال ایجاد کلیدها ...');
  // prepare printed values
  const amount = document.getElementById('amount').value;
  const serial = document.getElementById('serial').value;
  const printedKey = 'VERIFKEY01'; // small printed verification key

  // sensitive payload: two large keys + metadata (simulated)
  const sensitive = buildSensitivePayload({issuer:'SadatBank', expiry:'2030-12-31', largeKeyA: 'A'.repeat(1700), largeKeyB: 'B'.repeat(1200), note:'Internal data example'});

  // canonical printed part
  const printedCanon = canonicalPrinted(amount, serial, printedKey);

  // full plaintext that must be protected
  const fullPlain = new Uint8Array(printedCanon.length + sensitive.length);
  fullPlain.set(printedCanon,0); fullPlain.set(sensitive, printedCanon.length);

  // compress
  const compressed = compress(fullPlain);

  // symmetric key
  const K = U.rndBytes(32);
  // encrypt compressed with AES-GCM, AAD = SHA256(printedCanon) to bind to printed fields
  const aad = await sha256(printedCanon.buffer);
  const enc = await aesGcmEncrypt(K, compressed, aad);

  // split key K into K1 and K2 via XOR
  const K1 = U.rndBytes(32);
  const K2 = U.xor(K, K1);

  // compute H on compressed plaintext (to sign)
  const H = await sha256(compressed.buffer);

  // sign H with Falcon (if available)
  updateStatus('در حال تولید امضا (Falcon)...');
  const dataHex = U.hex(H);
  // Falon API expects hash-bytes input in original code; reuse same helper
  let sigF = new Uint8Array(0);
  if(falconApi){ try{ sigF = await falconApi.sign(H, stateMasterPrivateKey); } catch(e){ console.warn('Falcon sign failed',e); } }

  // Prepare QR payload (LEFT)
  const qrObj = {
    serial, amount, H: U.hex(H), k1: U.hex(K1), sigF: U.hex(sigF), meta:{v:1, side:'left'}
  };
  // Prepare JAB payload (RIGHT)
  // Ideally SPHINCS+ signature placed here (large). For prototype we include cert_id placeholder.
  const jabObj = {
    serial, amount, H: U.hex(H), k2: U.hex(K2), sphincs_cert_id: 'SPH_CERT_2025_v1', meta:{v:1, side:'right'}
  };

  // encode images
  updateStatus('در حال ایجاد JAB و QR ...');
  const qrImgBase64 = await (async ()=>{ try{ return jab.encode_message(JSON.stringify(qrObj)); }catch(e){ console.error(e); return null } })();
  const jabImgBase64 = await (async ()=>{ try{ return jab.encode_message(JSON.stringify(jabObj)); }catch(e){ console.error(e); return null } })();

  // draw final note: left QR, right JAB, printed text
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // bg
  ctx.fillStyle='#050512'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#fff'; ctx.font='bold 72px monospace'; ctx.textAlign='left'; ctx.fillText(serial,120,160);
  ctx.font='bold 150px monospace'; ctx.textAlign='right'; ctx.fillText(amount.toString(), canvas.width-120,190);

  // draw qr on left
  if(qrImgBase64){ const imgQ=new Image(); imgQ.onload=()=>{ ctx.fillStyle='#fff'; ctx.fillRect(80,260,380,380); ctx.drawImage(imgQ,80,260,380,380); // draw jab after
    if(jabImgBase64){ const imgJ=new Image(); imgJ.onload=()=>{ ctx.fillStyle='#fff'; ctx.fillRect(canvas.width-460,260,380,380); ctx.drawImage(imgJ,canvas.width-460,260,380,380); updateStatus('اسکناس ساخته شد — هر دو کُد چپ/راست موجود است.'); }; imgJ.src=jabImgBase64; } }; imgQ.src=qrImgBase64; }

  // store for validation later on window
  window._currentNote = { qrObj, jabObj, enc, aad };
}

// validate function: receives image containing both codes -> decode both -> reconstruct K -> decrypt
async function validateFromCanvasImage(img){ updateStatus('شروع اعتبارسنجی ...');
  // decode regions like earlier sample -> here we assume we can decode left and right images separately
  // For prototype: we read objects from window._currentNote
  if(!window._currentNote){ updateStatus('نمونه ساخت نشده یا داده‌ها در صفحه موجود نیست. برای تست ابتدا "ساخت اسکناس" را بزنید.'); return; }
  const { qrObj, jabObj, enc, aad } = window._currentNote;
  // reconstruct K
  const K1 = new Uint8Array(Array.from(qrObj.k1.match(/.{1,2}/g)).map(h=>parseInt(h,16)));
  const K2 = new Uint8Array(Array.from(jabObj.k2.match(/.{1,2}/g)).map(h=>parseInt(h,16)));
  const K = U.xor(K1,K2);
  try{
    const ptCompressed = await aesGcmDecrypt(K, enc.iv, enc.ct, aad);
    const pt = decompress(ptCompressed);
    const H = await sha256(ptCompressed.buffer);
    if(U.hex(H) !== qrObj.H || U.hex(H) !== jabObj.H){ updateStatus('هش تطابق ندارد — داده چاپی یا کدها دستکاری شده.'); return; }
    updateStatus('✅ موفق: داده‌ها مخفی با هم استخراج و هش برابر است. امضاها (Falcon/SPHINCS) باید جداگانه چک شوند.');
  }catch(e){ updateStatus('❌ خطا در بازیابی یا رمزگشایی — ممکن است کدها ناقص باشند یا کلیدها اشتباه باشند.'); console.error(e); }
}

// --- init falcon (if available) and event handlers ---
let stateMasterPrivateKey = null; // in real system private key is secret in HSM; here we simulate
(async ()=>{
  try{ falconApi = await pqcSignFalcon1024(); updateStatus('ماژول Falcon بارگذاری شد');
    // for prototype: generate ephemeral master keypair to simulate sign/verify (NOT for production)
    const kp = await falconApi.keypair(); stateMasterPrivateKey = kp.privateKey; window._protoMasterPub = kp.publicKey;
  }catch(e){ console.warn('Falcon unavailable',e); updateStatus('Falcon بارگذاری نشد — امضا درون-سایت غیرفعال است'); }
})();

document.getElementById('gen').addEventListener('click', generateBanknote);
document.getElementById('validate').addEventListener('click', ()=>validateFromCanvasImage());
document.getElementById('download').addEventListener('click', ()=>{ canvas.toBlob(b=>{ const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download='sadat-note.png'; a.click(); }, 'image/png'); });

</script>

</body>
</html>





<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>اسکناس دیجیتال سادات - سیستم 3-QR</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-font: 'Poppins', 'Segoe UI', sans-serif;
            --mono-font: 'Roboto Mono', monospace;
            --dark-bg: #10101a;
            --medium-bg: #1a1a2e;
            --light-bg: #2a2a3e;
            --accent-color-1: #e040fb;
            --accent-color-2: #7c4dff;
            --text-color: #e0e0e0;
            --text-muted: #a0a0c0;
            --success-color: #00e676;
            --error-color: #ff5252;
            --info-color: #40c4ff;
            --warning-color: #ffab40;
            --border-color: rgba(124, 77, 255, 0.2);
        }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        .header { border-bottom: 1px solid var(--border-color); padding-bottom: 16px; margin-bottom: 24px; }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .header p { font-size: 1rem; color: var(--text-muted); margin: 0; }
        canvas#noteCanvas { border-radius: 16px; margin-top: 24px; background: #050508; cursor: default; box-shadow: 0 0 50px rgba(124, 77, 255, 0.15); width: 100%; max-width: 1200px; height: auto; border: 1px solid var(--border-color); }
        input, button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        input[type="number"], input[type="password"] { font-family: var(--mono-font); font-weight: 700; text-align: center; width: 150px; }
        input:focus { border-color: var(--accent-color-2); box-shadow: 0 0 15px rgba(124, 77, 255, 0.5); }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button.sub-button, label.button.sub-button { background: var(--light-bg); border: 1px solid var(--border-color); }
        button[disabled], label.button[disabled] { cursor: not-allowed; opacity: 0.5; background: var(--light-bg); border: 1px solid var(--border-color); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .controls-grid { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: right; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); transition: all 0.3s ease; }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        code { background: var(--medium-bg); padding: 2px 6px; border-radius: 4px; font-size: 1em; }
        .input-label { font-size: 0.9rem; color: var(--text-muted); margin-left: -10px; }
        .modal { position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; }
        .modal-content { background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center; }
        #qr-display { margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content; }
        #qr-display canvas { max-width: 100%; height: auto; }
        .pill { background-color: var(--border-color); color: var(--accent-color-1); padding: 5px 15px; border-radius: 20px; font-size: 14px; font-weight: 600; margin: 5px; display: inline-block; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>اسکناس دیجیتال سادات</h1>
        <p>یک سیستم ارز دیجیتال کوانتوم-مقاوم، آفلاین، با امضای دوگانه و ۳ کد QR.</p>
    </div>

    <div class="section">
        <h2><span class="pill">مرحله ۱</span> راه‌اندازی نگهبان: ایجاد کلیدهای اصلی</h2>
        <div class="controls-grid">
            <button id="generate-keys-button">🔑 ایجاد جفت کلید اصلی</button>
            <label for="import-public-key" class="button sub-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                بارگذاری کلید عمومی
            </label>
            <input type="file" id="import-public-key" accept=".json" style="display: none;">
        </div>
         <div id="key-gen-status" class="status-box"><span class="info">ℹ️ خوش آمدید نگهبان. برای شروع اکوسیستم مالی خود، یک جفت کلید اصلی جدید ایجاد کنید. این فرآیند کاملاً آفلاین و امن است.</span></div>
    </div>

    <div class="section">
        <h2><span class="pill">مرحله ۲</span> فعال‌سازی سیستم: بازسازی کلید خصوصی</h2>
        <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">برای ایجاد اسکناس، باید هویت خود را با حل "پازل سه تکه" اثبات کنید. این کار حداکثر امنیت را تضمین می‌کند.</p>
        <div class="controls-grid">
             <label for="file-key-input" class="button sub-button">۱. بارگذاری کلید فایلی</label>
             <input type="file" id="file-key-input" accept=".json" style="display:none;" />
             <input type="password" id="password-key-input" placeholder="۲. ورود کلید رمزعبور">
             <label for="visual-key-input" class="button sub-button">۳. بارگذاری کلید بصری (QR)</label>
             <input type="file" id="visual-key-input" accept="image/png, image/jpeg" style="display:none;" />
        </div>
        <button id="reconstruct-key-button" disabled style="margin-top: 20px;">🔓 فعال‌سازی کلید خصوصی اصلی</button>
        <div id="key-reconstruction-status" class="status-box"><span class="warning">⚠️ کلید خصوصی اصلی غیرفعال است. برای فعال‌سازی، پازل را حل کنید.</span></div>
    </div>

    <div class="section">
        <h2><span class="pill">مرحله ۳</span> تولید ثروت: ایجاد اسکناس</h2>
        <div class="controls-grid">
            <span class="input-label">:مبلغ</span>
            <input type="number" id="amount-input" value="50000">
            <span class="input-label">:تعداد</span>
            <input type="number" id="quantity-input" value="1" min="1" max="100">
            <button id="create-note-button" disabled>🎨 ایجاد اسکناس</button>
            <button id="download-batch-button" disabled>📥 دانلود دسته‌ای</button>
        </div>
        <div id="banknote-status" class="status-box">از کنترل‌های بالا برای ایجاد و امضای اسکناس‌های جدید استفاده کنید.</div>
        <canvas id="noteCanvas" width="1200" height="533"></canvas>
    </div>

    <div class="section" id="validator-section">
        <h2><span class="pill">مرحله ۴</span> تأیید اعتبار</h2>
        <p style="color: var(--text-muted); font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">برای تأیید اعتبار یک اسکناس، یک تصویر واضح از **کل اسکناس** را بارگذاری کنید. سیستم هر سه کد QR را پیدا و تأیید می‌کند.</p>
        <label for="validator-input" class="button">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 15 17 10"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
            انتخاب تصویر اسکناس برای اعتبارسنجی
        </label>
        <input type="file" id="validator-input" accept="image/png, image/jpeg" style="display: none;">
        <div id="validation-result" class="status-box">در انتظار اسکناس برای اعتبارسنجی...</div>
    </div>
</div>

<div id="qr-modal" class="modal">
  <div class="modal-content">
    <h2 id="qr-modal-title">کلید بصری شما</h2>
    <p>این کد QR را چاپ کرده یا فایل تصویر آن را در یک مکان فیزیکی امن ذخیره کنید. این قطعه سوم از پازل کلید اصلی شما است.</p>
    <div id="qr-display"></div>
    <button id="download-qr-button" style="margin-top: 15px;">💾 دانلود کد QR</button>
    <button onclick="document.getElementById('qr-modal').style.display='none'">بستن</button>
  </div>
</div>

<script type="module">
// --- DEPENDENCIES (Loaded from CDN) ---
import pqcSignFalcon1024 from 'https://cdn.jsdelivr.net/npm/pqc-falcon-1024@1.0.3/pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';
import jsQR from 'https://cdn.skypack.dev/jsqr';
import Qrious from 'https://cdn.skypack.dev/qrious';


// --- Global State ---
const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null, // This will be held temporarily only during signing
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};

// --- CONSTANTS ---
const Constants = {
    FALCON_PUBKEY_SIZE: 1793,
    EPOCH: new Date('2024-01-01T00:00:00Z').getTime(),
    VALIDATION_PREFIX: "SADAT_V2_PART"
};

// --- DOM Elements ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    importPublicKey: document.getElementById('import-public-key'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    quantityInput: document.getElementById('quantity-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadBatchButton: document.getElementById('download-batch-button'),
    noteCanvas: document.getElementById('noteCanvas'),
    banknoteStatus: document.getElementById('banknote-status'),
    validatorInput: document.getElementById('validator-input'),
    validationResult: document.getElementById('validation-result'),
    qrModal: document.getElementById('qr-modal'),
    qrDisplay: document.getElementById('qr-display'),
    qrModalTitle: document.getElementById('qr-modal-title'),
    downloadQrButton: document.getElementById('download-qr-button')
};

// --- Utility Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);
        return bytes;
    },
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    log: (message, type = 'info') => {
        const icon = { info: 'ℹ️', success: '✅', warning: '⚠️', error: '❌' }[type];
        console.log(`[Sadat System] ${icon} ${message}`);
    },
    async createQrCanvas(payload, size) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        new Qrious({
            element: canvas,
            value: payload,
            size: size,
            level: 'L', // 7% error correction
            padding: 5,
            background: 'white',
            foreground: 'black'
        });
        return canvas;
    }
};

// ===================================================================================
// CORE CRYPTO ENGINE
// ===================================================================================
const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM";
    const PBKDF2_ITERATIONS = 100000;
    const PBKDF2_KEY_LENGTH = 32;

    async function pbkdf2DeriveKey(password, salt) {
        const passwordBuffer = new TextEncoder().encode(password);
        const importedKey = await crypto.subtle.importKey("raw",passwordBuffer,{ name: "PBKDF2" },false,["deriveKey"]);
        return await crypto.subtle.deriveKey({name: "PBKDF2",salt: salt,iterations: PBKDF2_ITERATIONS,hash: "SHA-256"},importedKey,{ name: AES_ALGO, length: PBKDF2_KEY_LENGTH * 8 },false,["encrypt", "decrypt"]);
    }
    
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }

    return {
        async generateNewKeyPair() {
            if (!state.falconApi) throw new Error("Falcon API not initialized.");
            return state.falconApi.keypair();
        },
        async signData(data, privateKey) {
            if (!privateKey || !state.falconApi) throw new Error("Signing prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            const { signature } = await state.falconApi.sign(dataHash, privateKey);
            return signature;
        },
        async verifySignature(signature, data, publicKey) {
            if (!publicKey || !state.falconApi) throw new Error("Verification prerequisites not met.");
            const dataHash = hashMessageForSigning(data);
            return state.falconApi.verify(signature, dataHash, publicKey);
        },
        async encryptMasterKey(masterPrivateKeyBytes, passwordKey, visualKeySecret) {
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
            const visualKeyIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, masterPrivateKeyBytes);

            const intermediatePayload = JSON.stringify({
                encryptedKey: Utils.arrayBufferToBase64(encryptedWithVisual),
                salt: Utils.arrayBufferToBase64(visualKeySalt),
                iv: Utils.arrayBufferToBase64(visualKeyIV)
            });

            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
            const passwordIV = crypto.getRandomValues(new Uint8Array(12));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
            
            return {
                fileKey: {
                    cipherText: Utils.arrayBufferToBase64(finalEncryptedKey),
                    salt: Utils.arrayBufferToBase64(passwordSalt),
                    iv: Utils.arrayBufferToBase64(passwordIV)
                }
            };
        },
        async reconstructMasterKey(fileKey, passwordKey, visualKeySecret) {
            const passwordSalt = Utils.base64ToUint8Array(fileKey.salt);
            const passwordIV = Utils.base64ToUint8Array(fileKey.iv);
            const passwordCipherText = Utils.base64ToUint8Array(fileKey.cipherText);
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const decryptedIntermediateBuffer = await crypto.subtle.decrypt({ name: AES_ALGO, iv: passwordIV }, cryptoPasswordKey, passwordCipherText);
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediateBuffer));
            const visualKeySalt = Utils.base64ToUint8Array(intermediatePayload.salt);
            const visualKeyIV = Utils.base64ToUint8Array(intermediatePayload.iv);
            const visualCipherText = Utils.base64ToUint8Array(intermediatePayload.encryptedKey);
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const masterPrivateKeyBytes = await crypto.subtle.decrypt({ name: AES_ALGO, iv: visualKeyIV }, cryptoVisualKey, visualCipherText);
            return new Uint8Array(masterPrivateKeyBytes);
        }
    };
})();

// ===================================================================================
// UI EVENT HANDLERS
// ===================================================================================
const UIHandlers = (() => {
    const module = {};

    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = '';
        statusHtml += fileKey ? '<span class="valid">✅ کلید فایلی بارگذاری شد.</span>\n' : '<span class="invalid">❌ کلید فایلی بارگذاری نشده.</span>\n';
        statusHtml += passwordKey ? '<span class="valid">✅ کلید رمزعبور وارد شد.</span>\n' : '<span class="invalid">❌ کلید رمزعبور وارد نشده.</span>\n';
        statusHtml += visualKey ? '<span class="valid">✅ کلید بصری اسکن شد.</span>\n' : '<span class="invalid">❌ کلید بصری اسکن نشده.</span>\n';
        DOMElements.keyReconstructionStatus.innerHTML = statusHtml;
        const allPiecesProvided = fileKey && passwordKey && visualKey;
        DOMElements.reconstructKeyButton.disabled = !allPiecesProvided;
        if (allPiecesProvided) {
             Utils.updateStatus(DOMElements.keyReconstructionStatus, "⚠️ تمام قطعات پازل فراهم است. برای باز کردن کلید خصوصی خود، 'فعال‌سازی' را کلیک کنید.", 'warning');
        }
    }

    async function decodeQrFromImage(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    const code = jsQR(imageData.data, imageData.width, imageData.height);
                    if (code) {
                        resolve(code.data);
                    } else {
                        reject(new Error("هیچ کد QR در تصویر یافت نشد."));
                    }
                };
                img.onerror = () => reject(new Error("فایل تصویر بارگذاری نشد."));
                img.src = e.target.result;
            };
            reader.onerror = () => reject(new Error("فایل خوانده نشد."));
            reader.readAsDataURL(file);
        });
    }
    
    module.handleGenerateAndExportKeys = async () => {
        const password = prompt("یک رمزعبور قوی وارد کنید. این 'کلید رمزعبور' شما (قطعه ۲/۳) خواهد بود.");
        if (!password) {
            Utils.updateStatus(DOMElements.keyGenStatus, '❌ ایجاد کلید لغو شد. رمزعبور الزامی است.', 'error');
            return;
        }
        
        Utils.updateStatus(DOMElements.keyGenStatus, '⏳ در حال ایجاد جفت کلید جدید Falcon-1024...', 'info');
        try {
            const keyPair = await BankCrypto.generateNewKeyPair();
            state.masterPublicKey = keyPair.publicKey;
            Utils.log("جفت کلید اصلی جدید ایجاد شد.", 'success');
            Utils.updateStatus(DOMElements.keyGenStatus, '⏳ در حال ایجاد قطعات پازل و رمزنگاری کلید خصوصی...', 'info');
            const visualKeySecret = crypto.randomUUID();
            const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
            const publicKeyB64 = Utils.arrayBufferToBase64(keyPair.publicKey);
            Utils.downloadFile(JSON.stringify({ masterPublicKey: publicKeyB64 }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
            Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
            
            DOMElements.qrModalTitle.innerText = "کلید بصری شما (قطعه ۳/۳)";
            DOMElements.qrDisplay.innerHTML = '';
            const qrCanvas = await Utils.createQrCanvas(visualKeySecret, 256);
            DOMElements.qrDisplay.appendChild(qrCanvas);
            DOMElements.qrModal.style.display = 'flex';

            Utils.updateStatus(DOMElements.keyGenStatus, `✅ جفت کلید جدید ایجاد شد!\n- MASTER-PUBLIC-KEY.json (این را به اشتراک بگذارید)\n- FILE-KEY.json (این را روی USB نگه دارید)\n- رمزعبور (این را به خاطر بسپارید)\n- کد QR کلید بصری (این را چاپ و امن نگه دارید)\nکلید عمومی جدید اکنون برای اعتبارسنجی فعال است.`, 'success');

        } catch (e) {
            Utils.log(`ایجاد کلید ناموفق بود: ${e.message}`, 'error');
            Utils.updateStatus(DOMElements.keyGenStatus, `❌ ایجاد کلیدها ناموفق بود: ${e.message}`, 'error');
        }
    };

    module.handleImportPublicKey = async (event) => { const file = event.target.files[0]; if (!file) return; try { const data = JSON.parse(await file.text()); if (!data.masterPublicKey) throw new Error("فرمت فایل کلید عمومی نامعتبر است."); state.masterPublicKey = Utils.base64ToUint8Array(data.masterPublicKey); Utils.updateStatus(DOMElements.keyGenStatus, '✅ کلید عمومی وارد شد. آماده برای اعتبارسنجی اسکناس‌ها.', 'success'); DOMElements.validatorInput.disabled = false; } catch (error) { Utils.updateStatus(DOMElements.keyGenStatus, `❌ خطا در ورود کلید عمومی: ${error.message}`, 'error'); } event.target.value = ''; };
    
    module.handleFileKeyInput = async (event) => { const file = event.target.files[0]; if (!file) return; try { state.puzzlePieces.fileKey = JSON.parse(await file.text()); Utils.log("کلید فایلی بارگذاری شد.", 'success'); } catch(e) { state.puzzlePieces.fileKey = null; Utils.log(`بارگذاری کلید فایلی ناموفق بود: ${e.message}`, 'error'); } updatePuzzleStatus(); event.target.value = ''; };
    
    module.handlePasswordKeyInput = (event) => { 
        state.puzzlePieces.passwordKey = event.target.value || null; 
        updatePuzzleStatus(); 
    };
    
    module.handleVisualKeyInput = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        try {
            const decodedText = await decodeQrFromImage(file);
            state.puzzlePieces.visualKey = decodedText;
            Utils.log("کلید بصری از کد QR بارگذاری شد.", 'success');
        } catch (error) {
            state.puzzlePieces.visualKey = null;
            Utils.log(`خطا در رمزگشایی کد QR: ${error.message}`, 'error');
        } finally {
            updatePuzzleStatus();
            event.target.value = '';
        }
    };

    module.handleReconstructKey = async () => { 
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        if (!fileKey || !passwordKey || !visualKey) { Utils.updateStatus(DOMElements.keyReconstructionStatus, "❌ هر سه قطعه پازل الزامی است.", 'error'); return; }
        Utils.updateStatus(DOMElements.keyReconstructionStatus, "⏳ در حال بازسازی کلید خصوصی اصلی...", 'info');
        try {
            state.masterPrivateKey = await BankCrypto.reconstructMasterKey(fileKey, passwordKey, visualKey);
            const testData = new TextEncoder().encode("test");
            const testSig = await BankCrypto.signData(testData, state.masterPrivateKey);
            const isTestValid = await BankCrypto.verifySignature(testSig, testData, state.masterPublicKey);
            if (!isTestValid) throw new Error("بازسازی کلید در خودآزمایی ناموفق بود. قطعات ارائه شده با کلید عمومی فعال مطابقت ندارند.");

            Utils.updateStatus(DOMElements.keyReconstructionStatus, "✅ کلید خصوصی اصلی فعال است. اکنون می‌توانید اسکناس ایجاد کنید.", 'success');
            DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
        } catch (error) {
            console.error(error); Utils.updateStatus(DOMElements.keyReconstructionStatus, `❌ بازسازی کلید ناموفق بود. ${error.message}`, 'error');
            state.masterPrivateKey = null; DOMElements.createNoteButton.disabled = true; DOMElements.downloadBatchButton.disabled = true;
        } 
    };

    return module;
})();

// ===================================================================================
// BANKNOTE LOGIC 
// ===================================================================================
const BanknoteLogic = (() => {

    const getStandardizedDataForSigning = (noteData) => JSON.stringify({
        timestamp: noteData.timestamp,
        serial: noteData.serial,
    }, ['timestamp', 'serial']);

    const getStandardizedDataForMasterSig = (noteData) => {
        const tempNoteData = {
            ephemeralPublicKey: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
            signatureOne: Utils.arrayBufferToBase64(noteData.signatureOne)
        };
        return JSON.stringify(tempNoteData, Object.keys(tempNoteData).sort());
    };
    
    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("کلید خصوصی اصلی فعال نیست.");
        const ephemeralKeyPair = await BankCrypto.generateNewKeyPair();
        
        const noteData = {
            amount: parseInt(amount) || 0,
            serial: Math.random().toString(36).substring(2, 10).toUpperCase(),
            timestamp: Math.floor((Date.now() - Constants.EPOCH) / 1000),
            ephemeralPublicKey: ephemeralKeyPair.publicKey,
            signatureOne: null,
            signatureTwo: null
        };
        
        const dataForSigOne = getStandardizedDataForSigning(noteData);
        noteData.signatureOne = await BankCrypto.signData(dataForSigOne, ephemeralKeyPair.privateKey);
        
        const dataForSigTwo = getStandardizedDataForMasterSig(noteData);
        noteData.signatureTwo = await BankCrypto.signData(dataForSigTwo, state.masterPrivateKey);
        
        return noteData;
    };
    
    const createUnifiedVerificationPayload = (noteData) => {
        const payload = {
            a: noteData.amount, s: noteData.serial, t: noteData.timestamp,
            epk: Utils.arrayBufferToBase64(noteData.ephemeralPublicKey),
            s1: Utils.arrayBufferToBase64(noteData.signatureOne),
            s2: Utils.arrayBufferToBase64(noteData.signatureTwo)
        };
        return JSON.stringify(payload);
    };

    const parseUnifiedVerificationPayload = (jsonString) => {
        const p = JSON.parse(jsonString);
        return {
            amount: p.a, serial: p.s, timestamp: p.t,
            ephemeralPublicKey: Utils.base64ToUint8Array(p.epk),
            signatureOne: Utils.base64ToUint8Array(p.s1),
            signatureTwo: Utils.base64ToUint8Array(p.s2)
        };
    };
    
    const handleCreateAndSignNotes = async () => {
        if (!state.masterPrivateKey) { alert("کلید خصوصی اصلی فعال نیست. لطفاً آن را در مرحله ۲ فعال کنید."); return; }
        Utils.updateStatus(DOMElements.banknoteStatus, `⏳ در حال ایجاد و امضای اسکناس...`, 'info');
        try {
            const noteData = await createNoteData(DOMElements.amountInput.value);
            const fullPayload = createUnifiedVerificationPayload(noteData);
            await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 533);
            Utils.updateStatus(DOMElements.banknoteStatus, `✅ اسکناس جدید طراحی شد. برای ایجاد اسکناس دیگر، کلید را دوباره فعال کنید.`, 'success');
        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `❌ خطا: ${error.message}`, 'error');
            console.error(error);
        } finally {
            state.masterPrivateKey = null;
            DOMElements.createNoteButton.disabled = true;
            DOMElements.downloadBatchButton.disabled = true;
            UIHandlers.handlePasswordKeyInput({ target: { value: null } });
            DOMElements.passwordKeyInput.value = '';
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "⚠️ کلید خصوصی برای امنیت پاک شد. برای ایجاد اسکناس بیشتر، دوباره فعال کنید.", 'warning');
            Utils.log("کلید برای امنیت پس از ایجاد یک اسکناس پاک شد.", 'warning');
        }
    };
    
    const handleDownloadBatch = async () => {
        if (!state.masterPrivateKey) { alert("کلید خصوصی اصلی فعال نیست. لطفاً آن را در مرحله ۲ فعال کنید."); return; }
        const quantity = parseInt(DOMElements.quantityInput.value) || 1;
        Utils.updateStatus(DOMElements.banknoteStatus, `⏳ در حال آماده‌سازی برای ایجاد ${quantity} اسکناس...`, 'info');

        if (quantity > 1 && !window.showDirectoryPicker) {
            Utils.log("Directory Picker API در دسترس نیست. به دانلودهای تکی بازگشت می‌شود.", 'warning');
            alert("مرورگر یا زمینه امنیتی شما از انتخاب پوشه پشتیبانی نمی‌کند.\nاسکناس‌ها به صورت جداگانه در پوشه 'Downloads' پیش‌فرض شما دانلود خواهند شد.");
        }

        try {
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = 1200; offscreenCanvas.height = 533;
            const notesToDownload = [];
            
            Utils.updateStatus(DOMElements.banknoteStatus, `⏳ در حال تولید ${quantity} اسکناس در حافظه...`, 'info');

            for (let i = 0; i < quantity; i++) {
                const noteData = await createNoteData(DOMElements.amountInput.value);
                const fullPayload = createUnifiedVerificationPayload(noteData);
                await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData, fullPayload, 1200, 533);
                const blob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                notesToDownload.push({ blob, filename: `SADAT-NOTE-${noteData.serial}.png` });
                if (i === quantity - 1) { 
                    await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 533);
                }
            }
            
            if (window.showDirectoryPicker) {
                 Utils.updateStatus(DOMElements.banknoteStatus, `ℹ️ لطفاً یک پوشه برای ذخیره اسکناس‌ها انتخاب کنید.`, 'info');
                 const dirHandle = await window.showDirectoryPicker();
                 Utils.updateStatus(DOMElements.banknoteStatus, `⏳ در حال ذخیره ${quantity} اسکناس در پوشه انتخابی شما...`, 'info');
                 for (const note of notesToDownload) {
                    const fileHandle = await dirHandle.getFileHandle(note.filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(note.blob);
                    await writable.close();
                 }
                 Utils.updateStatus(DOMElements.banknoteStatus, `✅ ${quantity} اسکناس در پوشه انتخابی شما ذخیره شد.`, 'success');
            } else {
                Utils.updateStatus(DOMElements.banknoteStatus, `⏳ در حال دانلود ${quantity} اسکناس به صورت جداگانه...`, 'info');
                notesToDownload.forEach(note => Utils.downloadFile(note.blob, note.filename, 'image/png'));
                Utils.updateStatus(DOMElements.banknoteStatus, `✅ ${quantity} اسکناس ذخیره شد. پوشه دانلودهای خود را بررسی کنید.`, 'success');
            }

        } catch (error) {
            Utils.updateStatus(DOMElements.banknoteStatus, `❌ عملیات لغو شد یا ناموفق بود: ${error.message}`, 'error');
            console.error(error);
        } finally {
            state.masterPrivateKey = null;
            DOMElements.createNoteButton.disabled = true;
            DOMElements.downloadBatchButton.disabled = true;
            UIHandlers.handlePasswordKeyInput({ target: { value: null } });
            DOMElements.passwordKeyInput.value = '';
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "⚠️ کلید خصوصی اصلی غیرفعال است. برای امنیت، از حافظه پاک شد. برای فعال‌سازی دوباره پازل را حل کنید.", 'warning');
            Utils.log("کلید برای امنیت پس از عملیات دسته‌ای پاک شد.", 'warning');
        }
    };
    
    async function decodeAllQrsFromImage(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const naturalWidth = img.naturalWidth;
                    const naturalHeight = img.naturalHeight;
                    const MAX_DIM = 1500;
                    const scale = Math.min(MAX_DIM / naturalWidth, MAX_DIM / naturalHeight, 1);
                    canvas.width = naturalWidth * scale;
                    canvas.height = naturalHeight * scale;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    const codes = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });

                    if (codes && !Array.isArray(codes)) {
                         resolve([codes]);
                    } else if (codes && codes.length > 0) {
                         resolve(codes);
                    } else {
                        reject(new Error("هیچ کد QR روی تصویر اسکناس یافت نشد."));
                    }
                };
                img.onerror = () => reject(new Error("فایل تصویر اسکناس بارگذاری نشد."));
                img.src = e.target.result;
            };
            reader.onerror = () => reject(new Error("فایل خوانده نشد."));
            reader.readAsDataURL(file);
        });
    }

    return {
        handleFileSelectForValidation: async (event) => {
            const file = event.target.files[0];
            if (!file || !state.masterPublicKey) {
                Utils.updateStatus(DOMElements.validationResult, '❌ قبل از اعتبارسنجی، یک کلید عمومی اصلی در مرحله ۱ بارگذاری کنید.', 'error');
                return;
            }
            const resultDiv = DOMElements.validationResult;
            Utils.updateStatus(resultDiv, '⏳ در حال خواندن تصویر اسکناس... لطفاً صبر کنید.', 'info');
            try {
                const decodedCodes = await decodeAllQrsFromImage(file);
                
                let resultHTML = `<span class="info">ℹ️ ${decodedCodes.length} کد QR یافت شد. در حال مونتاژ محتوا...</span>\n`;
                resultDiv.innerHTML = resultHTML;

                const parts = {};
                let partCount = 0;
                for(const code of decodedCodes) {
                    if (code.data.startsWith(Constants.VALIDATION_PREFIX)) {
                        const payload = code.data.substring(Constants.VALIDATION_PREFIX.length);
                        const match = payload.match(/^(\d)\/3:(.*)$/s);
                        if(match) {
                           parts[match[1]] = match[2];
                           partCount++;
                        }
                    }
                }

                if(partCount < 3) {
                     Utils.updateStatus(resultDiv, `❌ داده‌های اسکناس ناقص است. ${partCount}/3 کد QR ضروری یافت شد. اسکناس ممکن است آسیب دیده یا جعلی باشد.`, 'error');
                     return;
                }
                 
                resultHTML += `<span class="valid">✅ هر ۳ بخش یافت شد. در حال بازسازی محتوا...</span>\n`;
                resultDiv.innerHTML = resultHTML;

                const fullPayloadString = parts['1'] + parts['2'] + parts['3'];
                const parsedData = parseUnifiedVerificationPayload(fullPayloadString);
                
                resultHTML += `<span class="info">ℹ️ در حال تأیید امضای زودگذر (امضای ۱)...</span>\n`;
                resultDiv.innerHTML = resultHTML;
                const dataForSigOne = getStandardizedDataForSigning(parsedData);
                const isSigOneValid = await BankCrypto.verifySignature(parsedData.signatureOne, dataForSigOne, parsedData.ephemeralPublicKey);
                if (!isSigOneValid) {
                    resultHTML += '<span class="invalid">❌ امضای زودگذر (امضای ۱) نامعتبر است.</span>\n<hr><span>❌ نتیجه: جعل</span>';
                    resultDiv.innerHTML = resultHTML;
                    return;
                }
                resultHTML += '<span class="valid">✅ امضای زودگذر (امضای ۱) صحیح است.</span>\n';
                resultHTML += `<span class="info">ℹ️ در حال تأیید امضای اصلی (امضای ۲)...</span>\n`;
                resultDiv.innerHTML = resultHTML;

                const dataForSigTwo = getStandardizedDataForMasterSig(parsedData);
                const isSigTwoValid = await BankCrypto.verifySignature(parsedData.signatureTwo, dataForSigTwo, state.masterPublicKey);
                if (!isSigTwoValid) {
                    resultHTML += '<span class="invalid">❌ امضای اصلی (امضای ۲) نامعتبر است.</span>\n<hr><span>❌ نتیجه: جعل (توسط این نگهبان صادر نشده است)</span>';
                    resultDiv.innerHTML = resultHTML;
                    return;
                }
                resultHTML += '<span class="valid">✅ امضای اصلی (امضای ۲) صحیح است.</span>\n<hr><span style="font-size:14px;font-weight:600;">✅ نتیجه: اسکناس معتبر است</span>';
                
                resultDiv.innerHTML = resultHTML;
            } catch (e) {
                Utils.updateStatus(resultDiv, `❌ خطای اعتبارسنجی: ${e.message}.`, 'error');
                console.error(e);
            } finally {
                event.target.value = '';
            }
        },
        handleCreateAndSignNotes,
        handleDownloadBatch
    };
})();


// ===================================================================================
// BANKNOTE DRAWER -- PROFESSIONAL APPEARANCE MODULE
// ===================================================================================
const BanknoteDrawer = (() => {
    const H = (text, index, min, max) => min + (parseInt(text.substring(index, index + 2), 16) % (max - min + 1));
    function drawGuilloche(ctx, hash, w, h) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.15;
        const c1 = `hsl(${H(hash, 4, 0, 360)}, 70%, 50%)`;
        const c2 = `hsl(${H(hash, 6, 0, 360)}, 70%, 50%)`;
        for (let i = 0; i < 20; i++) {
            ctx.strokeStyle = i % 2 === 0 ? c1 : c2;
            ctx.lineWidth = 1 + (i % 3);
            ctx.beginPath();
            let phase = H(hash, 10 + i, 0, 360);
            let amp = h * 0.3 * ((H(hash, 30 + i, 50, 100)) / 100);
            for (let x = 0; x < w; x++) {
                let y = h / 2 + Math.sin(x / H(hash, 50 + i, 20, 80) + phase) * amp;
                if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    
    return {
        drawNoteOnCanvas: async (targetCanvas, noteData, fullPayload, width, height) => {
            const ctx = targetCanvas.getContext("2d");
            const { amount, serial, signatureTwo } = noteData;
            const scale = width / 1200; 
            const visualHash = shake256(Utils.arrayBufferToBase64(signatureTwo), 256);

            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            const baseHue = H(visualHash, 0, 0, 360);
            bgGradient.addColorStop(0, `hsl(${baseHue}, 50%, 6%)`);
            bgGradient.addColorStop(1, `hsl(${baseHue}, 40%, 4%)`);
            ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, width, height);
            
            drawGuilloche(ctx, visualHash, width, height);
            
            const totalLength = fullPayload.length;
            const part1Length = Math.ceil(totalLength / 3);
            const part2Length = Math.ceil(totalLength / 3);

            const part1 = fullPayload.substring(0, part1Length);
            const part2 = fullPayload.substring(part1Length, part1Length + part2Length);
            const part3 = fullPayload.substring(part1Length + part2Length);

            const qrPayload1 = `${Constants.VALIDATION_PREFIX}1/3:${part1}`;
            const qrPayload2 = `${Constants.VALIDATION_PREFIX}2/3:${part2}`;
            const qrPayload3 = `${Constants.VALIDATION_PREFIX}3/3:${part3}`;

            const qrSize = 190 * scale;
            const qrLeft = await Utils.createQrCanvas(qrPayload1, qrSize);
            const qrCenter = await Utils.createQrCanvas(qrPayload2, qrSize);
            const qrRight = await Utils.createQrCanvas(qrPayload3, qrSize);

            const qrY = height * 0.45;
            const totalQrWidth = qrSize * 3 + (80 * scale * 2);
            const startX = (width - totalQrWidth) / 2;

            ctx.shadowColor = `hsla(${baseHue}, 100%, 70%, 0.5)`;
            ctx.shadowBlur = 25 * scale;

            ctx.drawImage(qrLeft, startX, qrY);
            ctx.drawImage(qrCenter, startX + qrSize + 80 * scale, qrY);
            ctx.drawImage(qrRight, startX + qrSize * 2 + 160 * scale, qrY);
            
            ctx.shadowColor = "transparent";

            ctx.strokeStyle = `hsla(${baseHue}, 50%, 30%, 0.8)`;
            ctx.lineWidth = 2 * scale;
            const lineY = qrY + qrSize / 2;
            ctx.beginPath();
            ctx.moveTo(startX + qrSize, lineY);
            ctx.lineTo(startX + qrSize + 80 * scale, lineY);
            ctx.moveTo(startX + qrSize * 2 + 80 * scale, lineY);
            ctx.lineTo(startX + qrSize * 2 + 160 * scale, lineY);
            ctx.stroke();

            ctx.shadowColor = "rgba(0,0,0,0.7)"; ctx.shadowBlur = 8 * scale;
            ctx.shadowOffsetX = 2 * scale; ctx.shadowOffsetY = 2 * scale;
            
            ctx.font = `bold ${32 * scale}px 'Roboto Mono'`;
            ctx.textAlign = 'center';
            ctx.fillStyle = "rgba(255,255,255,0.7)";
            ctx.fillText("اسکناس ذخیره دیجیتال سادات", width / 2, height * 0.15);
            
            ctx.font = `bold ${90 * scale}px 'Roboto Mono'`;
            ctx.fillStyle = "#EAEAEA";
            ctx.fillText(amount.toLocaleString('en-US'), width / 2, height * 0.35);

            ctx.font = `bold ${30 * scale}px 'Roboto Mono'`;
            ctx.fillStyle = `hsla(${baseHue}, 100%, 80%, 0.9)`;
            ctx.fillText(serial, width/2, height * 0.9);

            ctx.shadowColor = "transparent";
        }
    };
})();

// ===================================================================================
// APPLICATION INITIALIZATION
// ===================================================================================
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, '⏳ در حال بارگذاری ماژول‌های Falcon-1024 و QR...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.keyGenStatus, '✅ ماژول‌ها بارگذاری شدند. لطفاً برای شروع، کلیدها را ایجاد یا وارد کنید.', 'success');
        Utils.log("تمام ماژول‌های رمزنگاری و QR با موفقیت مقداردهی اولیه شدند.", 'success');
    } catch (e) {
        Utils.log(`خطای حیاتی: ماژول‌های مورد نیاز بارگذاری نشدند: ${e.message}`, 'error');
        Utils.updateStatus(DOMElements.keyGenStatus, `❌ خطای حیاتی: ماژول‌ها بارگذاری نشدند. برای جزئیات به کنسول مراجعه کنید.`, 'error');
        alert("خطا: یکی از ماژول‌های رمزنگاری مورد نیاز بارگذاری نشد. برنامه نمی‌تواند اجرا شود.");
        return;
    }
    
    DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
    DOMElements.importPublicKey.addEventListener('change', UIHandlers.handleImportPublicKey);
    DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
    DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateAndSignNotes);
    DOMElements.downloadBatchButton.addEventListener('click', BanknoteLogic.handleDownloadBatch);
    DOMElements.validatorInput.addEventListener('change', BanknoteLogic.handleFileSelectForValidation);
    
    DOMElements.downloadQrButton.addEventListener('click', () => {
        const canvas = DOMElements.qrDisplay.querySelector('canvas');
        if (canvas) {
            const a = document.createElement('a');
a.href = canvas.toDataURL('image/png');
            a.download = 'Sadat-VISUAL-KEY.png';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
        }
    });

    const canvas = DOMElements.noteCanvas;
    const ctx = canvas.getContext('2d');
    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGradient.addColorStop(0, `hsl(250, 50%, 6%)`);
    bgGradient.addColorStop(1, `hsl(260, 40%, 4%)`);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = `bold 30px 'Poppins'`;
    ctx.textAlign = 'center';
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    ctx.fillText("طرح اسکناس پس از ایجاد در اینجا ظاهر می‌شود", canvas.width/2, canvas.height/2);
}

main();
</script>
</body>
</html>

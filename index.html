<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <title>Sadat Digital Banknote - GUARDIAN ISSUER</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <style>
        :root { --primary-font: 'Poppins', 'Segoe UI', sans-serif; --mono-font: 'Roboto Mono', monospace; --dark-bg: #10101a; --medium-bg: #1a1a2e; --light-bg: #2a2a3e; --accent-color-1: #e040fb; --accent-color-2: #7c4dff; --text-color: #e0e0e0; --text-muted: #a0a0c0; --success-color: #00e676; --error-color: #ff5252; --info-color: #40c4ff; --warning-color: #ffab40; --border-color: rgba(124, 77, 255, 0.2); }
        body { margin: 0; font-family: var(--primary-font); background-color: var(--dark-bg); background-image: radial-gradient(at 0% 0%, hsla(253, 100%, 15%, 0.3) 0px, transparent 50%), radial-gradient(at 100% 100%, hsla(263, 100%, 20%, 0.3) 0px, transparent 50%); color: var(--text-color); text-align: center; padding: 24px; }
        .container { max-width: 1200px; margin: 0 auto; background: rgba(26, 26, 46, 0.7); backdrop-filter: blur(12px); padding: 24px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); }
        h1 { font-size: 2.5rem; font-weight: 600; color: #fff; margin: 0 0 8px 0; letter-spacing: 1px; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        button, label { padding: 14px 22px; font-size: 16px; font-family: var(--primary-font); border-radius: 12px; margin: 8px 5px; border: 1px solid var(--border-color); background: var(--medium-bg); color: #fff; transition: all 0.3s ease; cursor: pointer; outline: none; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        button:not([disabled]), label.button:not([disabled]) { font-weight: 600; background: linear-gradient(90deg, var(--accent-color-1), var(--accent-color-2)); border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button:hover:not([disabled]), label.button:hover:not([disabled]) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124, 77, 255, 0.4); }
        button[disabled] { cursor: not-allowed; opacity: 0.5; }
        .section { background: rgba(16, 16, 26, 0.5); padding: 20px; margin-top: 30px; border-radius: 16px; border: 1px solid var(--border-color); }
        h2 { font-size: 1.5rem; color: var(--text-color); margin-top: 0; margin-bottom: 20px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .status-box { margin-top: 20px; font-size: 13px; font-weight: normal; min-height: 50px; line-height: 1.6; text-align: left; background: var(--dark-bg); padding: 15px 20px; border-radius: 12px; white-space: pre-wrap; font-family: var(--mono-font); border: 1px solid var(--border-color); }
        .valid { color: var(--success-color); } .invalid { color: var(--error-color); } .info { color: var(--info-color); } .warning { color: var(--warning-color); }
        .hidden { display: none; }
    </style>
</head>
<body>
<div class="container">
    <div class="header"><h1>Sadat Digital Banknote</h1><p>Quantum-Resistant Offline Currency - <strong>GUARDIAN ISSUER</strong></p></div>
    
    <div class="section"><h2><span style="color:var(--accent-color-1)">Step 1:</span> Guardian Setup</h2><button id="generate-keys-button">üîë Generate New Master Key Pair</button><div id="key-gen-status" class="status-box"><span class="info">‚ÑπÔ∏è Welcome, Guardian. Generate a new Master Key Pair to begin.</span></div></div>
    
    <div class="section"><h2><span style="color:var(--accent-color-1)">Step 2:</span> Activate System</h2><p style="font-size: 0.9em; max-width: 700px; margin: -10px auto 20px auto;">To create banknotes, reconstruct your private key by providing the three secret pieces.</p><label for="file-key-input" class="button">1. Upload File Key</label><input type="file" id="file-key-input" class="hidden" accept=".json" /><input type="password" id="password-key-input" placeholder="2. Enter Password Key" style="padding:14px; text-align:center;width:180px;"><label for="visual-key-input" class="button">3. Upload Visual Key (QR)</label><input type="file" id="visual-key-input" class="hidden" accept="image/png, image/jpeg" /><button id="reconstruct-key-button" disabled style="margin-top: 20px;">üîì Activate Master Private Key</button><div id="key-reconstruction-status" class="status-box"><span class="warning">‚ö†Ô∏è Master Private Key is INACTIVE. Solve the puzzle to activate.</span></div></div>
    
    <div class="section"><h2><span style="color:var(--accent-color-1)">Step 3:</span> Create Wealth</h2><input type="number" id="amount-input" value="50000" style="padding:14px; text-align:center;width:120px;"> <button id="create-note-button" disabled>üé® Create Single Banknote</button><hr style="border-color:var(--border-color); margin: 20px auto; width: 50%;"><input type="number" id="quantity-input" value="10" min="1" max="100" style="padding:14px; text-align:center;width:80px;"> <button id="download-batch-button" disabled>üì¶ Create & Download Batch (.zip)</button><div id="banknote-status" class="status-box">Activate your key to enable banknote creation.</div><canvas id="noteCanvas" width="1200" height="1000" style="width:100%; max-width:600px; height:auto; margin-top:20px;"></canvas></div>
</div>

<div id="jab-modal" class="modal" style="position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center;"><div class="modal-content" style="background-color: var(--medium-bg); padding: 30px; border: 1px solid var(--border-color); width: 80%; max-width: 500px; border-radius: 16px; text-align: center;"><h2 id="jab-modal-title">Your Visual Key</h2><p>Print or save this QR Code. It is the third piece of your Master Key puzzle.</p><div id="jab-display" style="margin: 20px auto; background: white; padding: 15px; border-radius: 8px; width: fit-content;"></div><button id="download-jab-button" style="margin-top: 15px;">üíæ Download QR Code</button><button onclick="document.getElementById('jab-modal').style.display='none'">Close</button></div></div>

<script type="module">
// --- DEPENDENCIES ---
import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

// --- Global State ---
const state = {
    falconApi: null,
    masterPublicKey: null,
    masterPrivateKey: null,
    puzzlePieces: { fileKey: null, passwordKey: null, visualKey: null }
};

// --- CONSTANTS ---
const Constants = {
    VALIDATION_PREFIX: "SADAT_V4_PART",
    NUM_QR_CODES: 9,
};

// --- DOM Elements ---
const DOMElements = {
    generateKeysButton: document.getElementById('generate-keys-button'),
    keyGenStatus: document.getElementById('key-gen-status'),
    fileKeyInput: document.getElementById('file-key-input'),
    passwordKeyInput: document.getElementById('password-key-input'),
    visualKeyInput: document.getElementById('visual-key-input'),
    reconstructKeyButton: document.getElementById('reconstruct-key-button'),
    keyReconstructionStatus: document.getElementById('key-reconstruction-status'),
    amountInput: document.getElementById('amount-input'),
    quantityInput: document.getElementById('quantity-input'),
    createNoteButton: document.getElementById('create-note-button'),
    downloadBatchButton: document.getElementById('download-batch-button'),
    banknoteStatus: document.getElementById('banknote-status'),
    noteCanvas: document.getElementById('noteCanvas'),
    jabModal: document.getElementById('jab-modal'),
    jabDisplay: document.getElementById('jab-display'),
    jabModalTitle: document.getElementById('jab-modal-title'),
    downloadJabButton: document.getElementById('download-jab-button')
};

// --- Utility Functions ---
const Utils = {
    arrayBufferToBase64: (buffer) => btoa(String.fromCharCode(...new Uint8Array(buffer))),
    base64ToUint8Array: (base64) => Uint8Array.from(atob(base64), c => c.charCodeAt(0)),
    hexToUint8Array: (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))),
    downloadFile: (data, filename, type) => {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    },
    updateStatus: (element, message, type = 'info') => {
        element.innerHTML = `<span class="${type}">${message}</span>`;
    },
    async createQrCodeImage(payload, asPngDataUrl = false) {
        const qr = qrcode(0, 'M');
        qr.addData(payload);
        qr.make();
        const gifDataUrl = qr.createDataURL(10, 5);
        const img = new Image();
        img.src = gifDataUrl;
        await new Promise(r => img.onload=r);
        const canvas = document.createElement('canvas');
        canvas.width = img.width; canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        return asPngDataUrl ? canvas.toDataURL('image/png') : img;
    },
    async decodeQrCodeFromImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width; canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const code = jsQR(ctx.getImageData(0, 0, canvas.width, canvas.height).data, canvas.width, canvas.height);
                if (code) resolve(code.data); else reject(new Error("QR Code not found."));
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }
};

// --- CORE CRYPTO ENGINE ---
const BankCrypto = (() => {
    const AES_ALGO = "AES-GCM"; const PBKDF2_ITERATIONS = 100000;
    async function pbkdf2DeriveKey(password, salt) {
        const importedKey = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
        return await crypto.subtle.deriveKey({ name: "PBKDF2", salt, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" }, importedKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
    }
    function hashMessageForSigning(message) { return Utils.hexToUint8Array(shake256(message, 1536)); }
    return {
        generateNewKeyPair: () => state.falconApi.keypair(),
        signData: async (data, privateKey) => {
            const dataHash = hashMessageForSigning(data);
            return (await state.falconApi.sign(dataHash, privateKey)).signature;
        },
        verifySignature: (signature, data, publicKey) => state.falconApi.verify(signature, hashMessageForSigning(data), publicKey),
        encryptMasterKey: async (masterPrivateKeyBytes, passwordKey, visualKeySecret) => {
            const visualKeySalt = crypto.getRandomValues(new Uint8Array(16));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, visualKeySalt);
            const encryptedWithVisual = await crypto.subtle.encrypt({ name: AES_ALGO, iv: crypto.getRandomValues(new Uint8Array(12)) }, cryptoVisualKey, masterPrivateKeyBytes);
            const intermediatePayload = JSON.stringify({ e: Utils.arrayBufferToBase64(encryptedWithVisual), s: Utils.arrayBufferToBase64(visualKeySalt), i: Utils.arrayBufferToBase64(encryptedWithVisual.iv) });
            const passwordSalt = crypto.getRandomValues(new Uint8Array(16));
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, passwordSalt);
            const finalEncryptedKey = await crypto.subtle.encrypt({ name: AES_ALGO, iv: crypto.getRandomValues(new Uint8Array(12)) }, cryptoPasswordKey, new TextEncoder().encode(intermediatePayload));
            return { fileKey: { c: Utils.arrayBufferToBase64(finalEncryptedKey), s: Utils.arrayBufferToBase64(passwordSalt), i: Utils.arrayBufferToBase64(finalEncryptedKey.iv) } };
        },
        reconstructMasterKey: async (fileKey, passwordKey, visualKeySecret) => {
            const cryptoPasswordKey = await pbkdf2DeriveKey(passwordKey, Utils.base64ToUint8Array(fileKey.s));
            const decryptedIntermediate = await crypto.subtle.decrypt({ name: AES_ALGO, iv: Utils.base64ToUint8Array(fileKey.i) }, cryptoPasswordKey, Utils.base64ToUint8Array(fileKey.c));
            const intermediatePayload = JSON.parse(new TextDecoder().decode(decryptedIntermediate));
            const cryptoVisualKey = await pbkdf2DeriveKey(visualKeySecret, Utils.base64ToUint8Array(intermediatePayload.s));
            return new Uint8Array(await crypto.subtle.decrypt({ name: AES_ALGO, iv: Utils.base64ToUint8Array(intermediatePayload.i) }, cryptoVisualKey, Utils.base64ToUint8Array(intermediatePayload.e)));
        }
    };
})();

// --- BANKNOTE LOGIC ---
const BanknoteLogic = (() => {
    // Note data structure for signing and payload creation
    const getNoteDataForSig1 = (d) => JSON.stringify({ t: d.timestamp, s: d.serial });
    const getNoteDataForSig2 = (d) => JSON.stringify({ spk: d.spendPublicKey_b64, s1: d.signatureOne_b64 });
    const createUnifiedPayload = (noteData) => {
        const payload = { a: noteData.amount, s: noteData.serial, t: noteData.timestamp, spk: noteData.spendPublicKey_b64, s1: noteData.signatureOne_b64, s2: noteData.signatureTwo_b64 };
        return Utils.arrayBufferToBase64(pako.deflate(JSON.stringify(payload)));
    };

    const createNoteData = async (amount) => {
        if (!state.masterPrivateKey) throw new Error("Master Private Key is not active.");
        const initialSpendKeyPair = await BankCrypto.generateNewKeyPair();
        const noteData = { amount: parseInt(amount) || 0, serial: Math.random().toString(36).substring(2, 10).toUpperCase(), timestamp: Math.floor((Date.now() - new Date('2024-01-01T00:00:00Z').getTime()) / 1000) };
        const sig1Data = getNoteDataForSig1(noteData);
        const sig1 = await BankCrypto.signData(sig1Data, initialSpendKeyPair.privateKey);
        
        noteData.spendPublicKey_b64 = Utils.arrayBufferToBase64(initialSpendKeyPair.publicKey);
        noteData.signatureOne_b64 = Utils.arrayBufferToBase64(sig1);
        
        const sig2Data = getNoteDataForSig2(noteData);
        const sig2 = await BankCrypto.signData(sig2Data, state.masterPrivateKey);
        noteData.signatureTwo_b64 = Utils.arrayBufferToBase64(sig2);

        const initialSpendKey = { serial: noteData.serial, privateKey_b64: Utils.arrayBufferToBase64(initialSpendKeyPair.privateKey) };
        return { noteData, initialSpendKey };
    };

    const clearActiveKey = () => {
        state.masterPrivateKey = null;
        DOMElements.createNoteButton.disabled = true;
        DOMElements.downloadBatchButton.disabled = true;
        DOMElements.passwordKeyInput.value = '';
        state.puzzlePieces.passwordKey = null;
        Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚ö†Ô∏è For security, the Master Private Key has been cleared from memory. Solve the puzzle again to create more banknotes.", 'warning');
    };
    
    return {
        handleCreateSingleNote: async () => {
            if (!state.masterPrivateKey) return;
            Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Creating banknote and initial spend key...`, 'info');
            try {
                const { noteData, initialSpendKey } = await createNoteData(DOMElements.amountInput.value);
                const fullPayload = createUnifiedPayload(noteData);
                await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 1000);
                
                Utils.downloadFile(JSON.stringify(initialSpendKey, null, 2), `SADAT-KEY-${noteData.serial}.json`, 'application/json');
                const noteBlob = await new Promise(resolve => DOMElements.noteCanvas.toBlob(resolve, 'image/png'));
                Utils.downloadFile(noteBlob, `SADAT-NOTE-${noteData.serial}.png`, 'image/png');
                
                Utils.updateStatus(DOMElements.banknoteStatus, `‚úÖ Success! Banknote image and its corresponding key file have been downloaded.`, 'success');
            } catch (error) {
                Utils.updateStatus(DOMElements.banknoteStatus, `‚ùå Error: ${error.message}`, 'error');
            } finally {
                clearActiveKey();
            }
        },
        handleDownloadBatch: async () => {
            if (!state.masterPrivateKey) return;
            const quantity = parseInt(DOMElements.quantityInput.value) || 1;
            Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Preparing to create a batch of ${quantity} banknotes...`, 'info');
            try {
                const zip = new JSZip();
                const offscreenCanvas = document.createElement('canvas');
                for (let i = 0; i < quantity; i++) {
                    Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Generating note ${i + 1} of ${quantity}...`, 'info');
                    const { noteData, initialSpendKey } = await createNoteData(DOMElements.amountInput.value);
                    const fullPayload = createUnifiedPayload(noteData);
                    await BanknoteDrawer.drawNoteOnCanvas(offscreenCanvas, noteData, fullPayload, 1200, 1000);
                    
                    const noteBlob = await new Promise(resolve => offscreenCanvas.toBlob(resolve, 'image/png'));
                    zip.file(`SADAT-NOTE-${noteData.serial}.png`, noteBlob);
                    zip.file(`SADAT-KEY-${noteData.serial}.json`, JSON.stringify(initialSpendKey, null, 2));

                    // Display the last note in the batch on the screen
                    if (i === quantity - 1) {
                         await BanknoteDrawer.drawNoteOnCanvas(DOMElements.noteCanvas, noteData, fullPayload, 1200, 1000);
                    }
                }
                Utils.updateStatus(DOMElements.banknoteStatus, `‚è≥ Compressing ${quantity} notes into a ZIP file...`, 'info');
                const zipBlob = await zip.generateAsync({ type: "blob" });
                Utils.downloadFile(zipBlob, `SADAT-BATCH-${Date.now()}.zip`, 'application/zip');
                Utils.updateStatus(DOMElements.banknoteStatus, `‚úÖ Success! Your batch of ${quantity} notes and keys has been downloaded as a ZIP file.`, 'success');
            } catch (error) {
                Utils.updateStatus(DOMElements.banknoteStatus, `‚ùå Operation failed: ${error.message}`, 'error');
            } finally {
                clearActiveKey();
            }
        }
    };
})();

// --- UI HANDLERS ---
const UIHandlers = (() => {
    function updatePuzzleStatus() {
        const { fileKey, passwordKey, visualKey } = state.puzzlePieces;
        let statusHtml = `File Key: ${fileKey ? '‚úÖ' : '‚ùå'} | Password Key: ${passwordKey ? '‚úÖ' : '‚ùå'} | Visual Key: ${visualKey ? '‚úÖ' : '‚ùå'}`;
        Utils.updateStatus(DOMElements.keyReconstructionStatus, statusHtml, fileKey && passwordKey && visualKey ? 'valid' : 'warning');
        DOMElements.reconstructKeyButton.disabled = !(fileKey && passwordKey && visualKey);
    }
    return {
        handleGenerateAndExportKeys: async () => {
            const password = prompt("Enter a strong password. This will be your 'Password Key' (Piece 2/3).");
            if (!password) return;
            Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Generating new Falcon-1024 key pair...', 'info');
            const keyPair = await BankCrypto.generateNewKeyPair();
            state.masterPublicKey = keyPair.publicKey;
            const visualKeySecret = crypto.randomUUID();
            const { fileKey } = await BankCrypto.encryptMasterKey(keyPair.privateKey, password, visualKeySecret);
            Utils.downloadFile(JSON.stringify({ masterPublicKey_b64: Utils.arrayBufferToBase64(keyPair.publicKey) }, null, 2), 'Sadat-MASTER-PUBLIC-KEY.json', 'application/json');
            Utils.downloadFile(JSON.stringify(fileKey, null, 2), 'Sadat-FILE-KEY.json', 'application/json');
            const qrPngDataUrl = await Utils.createQrCodeImage(visualKeySecret, true);
            DOMElements.jabDisplay.innerHTML = `<img src="${qrPngDataUrl}" alt="Visual Key QR Code">`;
            DOMElements.downloadJabButton.onclick = () => Utils.downloadFile(qrPngDataUrl, 'Sadat-VISUAL-KEY.png', 'image/png');
            DOMElements.jabModal.style.display = 'flex';
            Utils.updateStatus(DOMElements.keyGenStatus, `‚úÖ New key pair generated and exported! Secure your 3 key pieces.`, 'success');
        },
        handleFileKeyInput: async (e) => { try { state.puzzlePieces.fileKey = JSON.parse(await e.target.files[0].text()); } catch { state.puzzlePieces.fileKey = null; } updatePuzzleStatus(); },
        handlePasswordKeyInput: (e) => { state.puzzlePieces.passwordKey = e.target.value || null; updatePuzzleStatus(); },
        handleVisualKeyInput: async (e) => { try { state.puzzlePieces.visualKey = await Utils.decodeQrCodeFromImage(e.target.files[0]); } catch { state.puzzlePieces.visualKey = null; } updatePuzzleStatus(); },
        handleReconstructKey: async () => {
            Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚è≥ Reconstructing and verifying key...", 'info');
            try {
                const privateKey = await BankCrypto.reconstructMasterKey(state.puzzlePieces.fileKey, state.puzzlePieces.passwordKey, state.puzzlePieces.visualKey);
                const isValid = await BankCrypto.verifySignature(await BankCrypto.signData("test", privateKey), "test", state.masterPublicKey);
                if (!isValid) throw new Error("Key reconstruction failed self-test. The provided pieces do not match.");
                state.masterPrivateKey = privateKey;
                Utils.updateStatus(DOMElements.keyReconstructionStatus, "‚úÖ Master Private Key ACTIVE. You can now create banknotes.", 'success');
                DOMElements.createNoteButton.disabled = false; DOMElements.downloadBatchButton.disabled = false;
            } catch (error) {
                Utils.updateStatus(DOMElements.keyReconstructionStatus, `‚ùå Failed to reconstruct key: ${error.message}`, 'error');
            }
        },
    };
})();

// --- BANKNOTE DRAWER (Visual Layout) ---
const BanknoteDrawer = {
    drawNoteOnCanvas: async (canvas, noteData, fullPayload, width, height) => {
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f0f2f5'; ctx.fillRect(0, 0, width, height);
        
        const partLength = Math.ceil(fullPayload.length / Constants.NUM_QR_CODES);
        const qrPayloads = Array.from({length: Constants.NUM_QR_CODES}, (_, i) => {
            const partData = fullPayload.substring(i * partLength, (i + 1) * partLength);
            return `${Constants.VALIDATION_PREFIX}${i + 1}/${Constants.NUM_QR_CODES}:${partData}`;
        });
        const qrImages = await Promise.all(qrPayloads.map(p => Utils.createQrCodeImage(p)));

        const qrSize = 250, spacing = 20;
        const totalGridWidth = (qrSize * 3) + (spacing * 2);
        const startX = (width - totalGridWidth) / 2;
        const startY = 150;

        qrImages.forEach((img, index) => {
            const row = Math.floor(index / 3), col = index % 3;
            ctx.drawImage(img, startX + col * (qrSize + spacing), startY + row * (qrSize + spacing), qrSize, qrSize);
        });

        ctx.fillStyle = `#10101a`; ctx.textAlign = 'center';
        ctx.font = `bold 72px 'Roboto Mono'`; ctx.fillText(noteData.amount.toLocaleString('en-US'), width / 2, 100);
        ctx.font = `bold 36px 'Roboto Mono'`; ctx.fillText(noteData.serial, width / 2, height - 70);
    }
};

// --- APPLICATION INITIALIZATION ---
async function main() {
    Utils.updateStatus(DOMElements.keyGenStatus, '‚è≥ Loading Falcon-1024 Cryptography...', 'info');
    try {
        state.falconApi = await pqcSignFalcon1024();
        Utils.updateStatus(DOMElements.keyGenStatus, '‚úÖ Modules loaded. Please generate master keys to begin.', 'success');
    } catch (e) {
        Utils.updateStatus(DOMElements.keyGenStatus, `‚ùå Critical Error: Could not load modules.`, 'error');
        return;
    }
    
    DOMElements.generateKeysButton.addEventListener('click', UIHandlers.handleGenerateAndExportKeys);
    DOMElements.fileKeyInput.addEventListener('change', UIHandlers.handleFileKeyInput);
    DOMElements.passwordKeyInput.addEventListener('input', UIHandlers.handlePasswordKeyInput);
    DOMElements.visualKeyInput.addEventListener('change', UIHandlers.handleVisualKeyInput);
    DOMElements.reconstructKeyButton.addEventListener('click', UIHandlers.handleReconstructKey);
    DOMElements.createNoteButton.addEventListener('click', BanknoteLogic.handleCreateSingleNote);
    DOMElements.downloadBatchButton.addEventListener('click', BanknoteLogic.handleDownloadBatch);
}

main();
</script>
</body>
</html>

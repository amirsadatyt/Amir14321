<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Aura Wallet (Pinata Ledger) - Professional Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        :root {
            --primary-color: #333333;
            --secondary-color: #000000;
            --danger-color: #d9534f;
            --light-gray: #f5f5f5;
            --dark-gray: #555555;
            --success-color: #1e8e3e;
            --text-light: #ffffff;
            --text-dark: #212529;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }
        body { font-family: 'Roboto', sans-serif; background-color: var(--light-gray); display: flex; justify-content: center;
        align-items: center; height: 100vh; margin: 0; color: var(--text-dark); }
        .view { display: none;
        }
        .view.active { display: block;
        }
        .card { background-color: var(--card-bg); padding: 30px; border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 380px; text-align: center; border-top: 5px solid var(--secondary-color);
        }
        input, textarea { width: calc(100% - 22px); padding: 10px; margin-bottom: 15px;
        border: 1px solid var(--border-color); border-radius: 6px; font-size: 16px; text-align: center; font-family: 'Roboto', sans-serif; background-color: #fff; color: #000;
        }
        textarea { resize: vertical; height: 80px;
        }
        button { width: 100%; padding: 12px; background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); color: var(--text-light);
        border: none; border-radius: 6px; font-size: 16px; cursor: pointer; transition: all 0.2s;
        }
        button:hover { opacity: 0.9; transform: translateY(-2px);
        }
        button:disabled { background: #999; cursor: not-allowed; transform: translateY(0);
        }
        .back-button { background: var(--dark-gray); margin-top: 10px;
        }
        .logout-button { background: var(--danger-color); margin-top: 10px;
        }
        .link-button { background: none; border: none; color: var(--primary-color); text-decoration: underline; cursor: pointer;
        padding: 5px; width: auto; }
        .status-box { font-weight: bold; min-height: 20px; margin-top: 10px;
        word-wrap: break-word; }
        .error { color: var(--danger-color);
        }
        .success { color: var(--success-color);
        }
        .info { color: #007bff;
        }
        .seed-phrase-box { padding: 15px; border: 1px dashed var(--danger-color); border-radius: 8px;
        margin: 20px 0; background-color: #fff8f8; color: #333; font-size: 18px; letter-spacing: 1px;
        }
        #my-qr-code img, #qr-display-box img, #static-qr-code img { margin: 15px auto; display: block;
        border: 5px solid #eee; border-radius: 5px; }
        label.qr-upload-label { cursor: pointer; display: block;
        margin: 15px; padding: 10px; border: 2px dashed #ccc; border-radius: 8px;
        }
        label.qr-upload-label:hover { background-color: #f9f9f9;
        }
        input[type="file"] { display: none;
        }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color);
        width: 20px; height: 20px; -webkit-animation: spin 1s linear infinite; animation: spin 1s linear infinite; margin: 10px auto;
        }
        .loader.hidden { display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg);
        } }
        /* Transaction History Styles */
        .transaction-history { margin-top: 25px;
        text-align: left; }
        .transaction-history h3 { text-align: center; margin-bottom: 15px; color: var(--secondary-color);
        }
        .transaction-list { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto;
        }
        .transaction-item { display: flex; justify-content: space-between; align-items: center; padding: 10px;
        border-bottom: 1px solid var(--border-color); }
        .transaction-item:last-child { border-bottom: none;
        }
        .transaction-details { display: flex; flex-direction: column;
        }
        .transaction-type { font-weight: bold; font-size: 16px;
        }
        .transaction-type.sent { color: var(--danger-color);
        }
        .transaction-type.received { color: var(--success-color);
        }
        .transaction-date { font-size: 12px; color: #888;
        }
        .transaction-amount { font-weight: bold; font-size: 16px;
        }
        .transaction-amount.sent { color: var(--danger-color);
        }
        .transaction-amount.received { color: var(--success-color);
        }
        .no-transactions { text-align: center; color: #999; padding: 20px;
        }
         /* Timer Style */
        #payment-timer { font-size: 18px;
        font-weight: bold; color: var(--danger-color); margin-top: 15px; }
        .address-display-box { background: #f0f2f5; padding: 10px;
        border-radius: 6px; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;
        }
        .address-text { font-family: monospace; font-size: 14px; margin-right: 10px;
        }
        .copy-button { padding: 5px 10px; font-size: 12px; width: auto; background: var(--dark-gray);
        min-width: 60px; }
        #confirm-amount-display { line-height: 1.5;
        }
        
        /* Styles for Transaction Detail Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-content {
            width: 400px;
            max-width: 90%; text-align: left; padding: 25px;
        }
        .modal-content h2 { text-align: center;
        margin-bottom: 20px; }
        .modal-content p { margin-bottom: 12px; font-size: 14px;
        }
        .modal-content p strong { color: var(--primary-color);
        }
    </style>
</head>
<body>

    <div id="onboarding-view" class="view active"><div class="card"><h1>Aura Wallet</h1><p>A new generation of asset security and control</p><button id="go-to-create-wallet">Create a New Wallet</button><button id="go-to-restore-wallet" class="back-button">Restore Wallet</button></div></div>
    
    <div id="create-wallet-view" class="view"><div class="card"><h2>Create Password</h2><p>Choose a strong password to encrypt your wallet. This password cannot be recovered.</p><input type="password" id="create-password-input" placeholder="Password"><input type="password" id="confirm-password-input" placeholder="Confirm Password"><div class="loader hidden" id="create-loader"></div><button id="create-wallet-button">Create Wallet</button><div id="create-status" class="status-box"></div><button class="back-button" id="back-from-create">Back</button></div></div>

    <div id="seed-phrase-view" class="view"><div class="card"><h2>Your Recovery Phrase</h2><p class="error">Write down these 12 words in a safe, offline place. This is the only way to recover your wallet.</p><div id="seed-phrase-display" class="seed-phrase-box"></div><button id="seed-phrase-confirm-button">I Understand, Take Me to My Wallet</button></div></div>

    <div id="restore-wallet-view" class="view"><div class="card"><h2>Restore Wallet</h2><p>Enter your 12-word recovery phrase.</p><textarea id="restore-seed-input" placeholder="Enter words separated by spaces..."></textarea><p>Choose a new password for this device.</p><input type="password" id="restore-password-input" placeholder="New Password"><div class="loader hidden" id="restore-loader"></div><button id="restore-wallet-button">Restore</button><div id="restore-status" class="status-box"></div><button class="back-button" id="back-from-restore">Back</button></div></div>
    
    <div id="login-view" class="view"><div class="card"><h1>Unlock Wallet</h1><p>Enter your password to decrypt your wallet.</p><input type="password" id="login-password-input" placeholder="Password"><div class="loader hidden" id="login-loader"></div><button id="login-button">Unlock</button><div id="login-status" class="status-box"></div><p style="margin-top:20px;">Want to use a different wallet? <button class="link-button" id="reset-app-button">Erase everything and start over</button></p></div></div>
    
    <div id="wallet-view" class="view"><div class="card">
        <h2>Your Wallet</h2>
        <div class="address-display-box">
             <span id="address-display" class="address-text"></span>
             <button id="copy-address-button" class="copy-button">Copy</button>
        </div>
        <p>Balance:</p>
        <h1 id="balance-display">$0.00</h1>
        <div id="sync-status" class="status-box" style="font-size: 14px;"></div>
        <p id="network-status" style="font-size: 12px; color: var(--success-color);">Ledger: Pinata IPFS</p>
        <button id="show-charge-view-button">Charge with Banknote</button>
        <button id="show-send-view-button" style="margin-top:10px;">Send (Aura)</button>
        <button id="show-receive-view-button" style="margin-top:10px;">Receive (Aura)</button>
        <div class="transaction-history">
            <h3>Recent Transactions</h3>
            <ul id="transaction-list-ul" class="transaction-list"></ul>
        </div>
      
          <button id="logout-button" class="logout-button">Logout (Lock Wallet)</button>
    </div></div>
    
    <div id="charge-view" class="view"><div class="card"><h2>Charge Wallet</h2><div><h3>Step 1: Bank Public Key</h3><p>The bank's public key is pre-loaded for verification.</p><div id="key-status" class="status-box"></div></div><div><h3>Step 2: Scan Digital Banknote</h3><label for="banknote-image-input" class="qr-upload-label" id="banknote-upload-label">Upload Banknote Image</label><input type="file" id="banknote-image-input" accept="image/*" disabled><div id="validation-status" class="status-box"></div></div><div id="charge-confirmation" style="display:none; margin-top: 20px;"><p>Validation successful! Amount: <b id="validated-amount"></b></p><button id="confirm-charge-button">Add to Balance</button></div><button class="back-button" id="back-from-charge">Back</button></div></div>
    
    <div id="receive-view" class="view"><div class="card">
        <h2>Receive Funds</h2>
        <p>Share your address to receive funds.</p>
        <div id="static-qr-code"></div>
        <p style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;" id="full-receive-address"></p>
        <hr style="margin: 20px 0;">
        <p>Or request a specific amount:</p>
        <input type="number" id="request-amount-input" placeholder="Amount to receive">
        <button id="create-request-qr-button">Generate Payment Request QR</button>
        <div id="receive-status" class="status-box"></div>
        <button class="back-button" id="back-from-receive">Back</button>
    </div></div>
    
    <div id="send-view" class="view"><div class="card">
        <h2>Send Funds</h2>
        
        <p>Enter recipient address and amount.</p>
        <div>
            <input type="text" id="send-address-input" placeholder="Recipient's Aura Address" style="margin-bottom: 10px;">
            <input type="number" id="send-amount-input" placeholder="Amount to send" style="margin-bottom: 10px;">
            <button id="send-manual-button">Continue</button>
        </div>

        <p style="text-align:center; margin: 20px 0; font-weight: bold;">- OR -</p>

        <p>Scan a recipient's payment request QR code.</p>
        <div id="video-container" style="position: relative; width: 100%; max-width: 300px; margin: 15px auto; border-radius: 8px; overflow: hidden; border: 2px solid #333; background: #000;">
            <video id="qr-video" playsinline style="width: 100%; height: auto; display: block;"></video>
            <div id="loading-message" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); color: white; display: flex; align-items: center; justify-content: center;">Requesting camera access...</div>
        </div>
        <canvas id="qr-canvas" style="display: none;"></canvas> 
        <div id="send-status" class="status-box"></div>
        <button class="back-button" id="back-from-send">Back</button>
    </div></div>
    
    <div id="send-confirm-view" class="view"><div class="card">
        <h2>Confirm Payment</h2>
        <p>You are about to send:</p>
        <h2 id="confirm-amount-display" style="color: var(--primary-color);"></h2>
        <p>To:</p>
  
              <p id="confirm-recipient-address-display" style="font-size: 12px; word-wrap: break-word; background: #f0f2f5; padding: 8px; border-radius: 4px;"></p>
        <button id="confirm-payment-button">Confirm and Pay</button>
        <div id="send-confirm-status" class="status-box"></div>
        <button class="back-button" id="back-from-send-confirm">Cancel</button>
    </div></div>
    
    <div id="qr-display-view" class="view"><div class="card">
        <h2 id="qr-display-title"></h2>
        <p id="qr-display-instruction"></p>
        <div id="qr-display-box"></div>
        <div id="waiting-on-payment" style="display: none;">
            <div id="payment-timer"></div>
  
                  <div class="loader"></div>
            <p id="final-status-message" class="status-box" style="font-size:18px;"></p>
        </div>
        <button class="back-button" id="back-from-qr-display">Back to Wallet</button>
    </div></div>

    <div id="transaction-detail-modal" class="modal-overlay" style="display:none;">
        <div class="modal-content card">
            <h2>Transaction Details</h2>
            <div id="modal-details-content">
       
                         <p><strong>Status:</strong> <span id="detail-status"></span></p>
                <p><strong>Type:</strong> <span id="detail-type"></span></p>
                <p><strong>Date & Time:</strong> <span id="detail-datetime"></span></p>
                <p><strong>Amount:</strong> <span id="detail-amount"></span></p>
                <p><strong>Fee:</strong> <span id="detail-fee"></span></p>
               
         <p style="word-wrap: break-word;"><strong>From:</strong> <span id="detail-from"></span></p>
                <p style="word-wrap: break-word;"><strong>To:</strong> <span id="detail-to"></span></p>
                <p style="word-wrap: break-word;"><strong>Transaction Hash:</strong> <span id="detail-hash"></span></p>
            </div>
            <button id="download-tx-button">Download as JPG</button>
            <button id="close-modal-button" class="back-button">Close</button>
        </div>
    </div>
 
    
    <script src="pako.min.js"></script>
    <script src="qrcode.js"></script>
    <script src="jsQR.js"></script>
    <script src="crypto-js.min.js"></script>
    <script src="html2canvas.min.js"></script>
    
    <script type="module">
        import { ethers } from "./ethers.min.js";
        import pqcSignFalcon1024 from './pqc-sign-falcon-1024.min.js';
        import { shake256 } from 'https://cdn.skypack.dev/js-sha3';

        // ===================================================================================
        // AURA WALLET - PROFESSIONAL EDITION
        // ===================================================================================

        /**
         * -----------------------------------------------------------------------------------
         * CONFIGURATION
         * Stores all constants and application settings.
         * -----------------------------------------------------------------------------------
         */
        const Config = {
            // --- CRITICAL SECURITY WARNING ---
            // The following JWT is exposed on the client-side. In a production environment,
            // this is a SEVERE vulnerability. This key should be stored on a secure backend
            // server, and all API calls to Pinata should be proxied through that server.
            // For this single-file demonstration, it remains here for functionality.
            PINATA_JWT: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJiZTkzZDRkMC0yYjgzLTQwZDMtYjg5Mi1iMGJiZGVkMTdiZDYiLCJlbWFpbCI6ImExbTNpNXIuYWZnQGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG-saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiI0Y2UzOTU0ZjIxZGRhYTdlMmM1NiIsInNjb3BlZEtleVNlY3JldCI6ImU3YTA3NmZjZTJjN2Q0NzM0OWY0MTFjYmE5ODE5YmZiNzVjYTY2MzZmYTVhMDdiNDk2MTJmYWU3MjlhZmQxNmIiLCJleHAiOjE3ODcxMzI1NTh9.dV4M4P4LaqxiZ91ye3F4n5oP98sIqGQVA2waPrGDFJc',
            
            PINATA_API_URL: 'https://api.pinata.cloud',
            PINATA_GATEWAY_URL: 'https://gateway.pinata.cloud/ipfs/',

            APP_CONSTANTS: {
                MAX_LOGIN_ATTEMPTS: 5,
                LOGIN_LOCKOUT_PERIOD: 30000, // 30 seconds
                POLLING_INTERVAL: 5000, // 5 seconds
                PAYMENT_REQUEST_EXPIRY: 9 * 60 * 1000, // 9 minutes
                TREASURY_ADDRESS: '0xF848aC6b7E16CF32A972ECE1529c73313375c6d5',
                FEE_PERCENTAGE: 0.009,
                PRECISION: 8,
                LOCAL_STORAGE_KEY: 'aura_user_store'
            },
            
            BANKNOTE_CONSTANTS: {
                VALIDATION_PREFIX: "SADAT_V2_PART",
                MAX_IMAGE_DIMENSION: 2000,
                NUM_QR_CODES: 9,
                MASTER_PUBLIC_KEY_B64': "CpykDvKkGbiU2HC4ClbsqghN2ABEoTg8ZdT7XHwHEmGRQqUXtqr/NsqmrTD49tLgXhYNfUqHsN9Bmv2PmhJHr7J4p0enLousZWjxkBbrQ6ZdN6nCn1FIj1rIXfg4OWiI9VJErl0gSIOmhGY8mOOpUk4fQSqQ5opIDfqscYAQrhEiUgCgWTW81YRj3UOyJa6bsEJIRIy2+PII4pav3YEBJy1iHOinpiXI96INtMccbbA41VLHzs+oWL37c29exD4o5VJ/Lb0VvCSVo1bvsgZ/UmKhcU7gSgr7FWhA5Ajz0aW8OhXkZ/zAK73xEASt609ACB/bTsbHZh6xIjPtjyae1DPRxgtDWrfj/Qlph9RyOttV9GNop5oPzRZ+nL2luUeYdu3CGcdGa1ZumGO/KYyMlKV0+lEovBiz9q5WYgxRTtufZVejRYkxVIQNk8pepDfUQzssSeRDimNbqbrhsk6AkGhO82ekvVe6QYkgr1+UuZPpqUOeHwHxc8UG/E3a9OvWCp44EtkBt1D8L9JPgQ2TNpqcIxuP5aGYclY3Vc7xFl1jyvaGXZ1yisiUWSoLqSsTMQHIeGbgQcmg9LCyQDJLZ/BJKXMWAeORRYTmq+pAqkHd94VL3yE08U2wYo1XqPHGGhxT8GY1gCVdRltttfOigaBrqY0jgoxEraheS1Sxgpae7ZX2LW7tpx3v+QPn0absxANYK4ZuZaCRLIfHveAbhzgWxozATyf7B+YbVR8IPih7DIrXtIkmTVTazyrZU4S9URZJ05titcD9qmkW9IghR6HgYDFXeVtTTB3cpmINKoeAIUuUtmps0d99dvG23sAsvKzqVoSOx5LZgoWzmlI3vcAFQYa/Og3lB40pCxvFotsJyPcSOvpiJ8a9KXmqECmpe7LoMcAfF5m3vO0UkFSNpszMoV3LElBEV8fk1wVQCKv1ceKbX2yRC99IQApCnMV41nkoiNuRoCryoGnsQMLjB7FsfeG0ouEqxc8oEgzsM1KKIrLtaDvqXXSYh1C6VlWQ/xqmR1oUdWaH3JuOCnjgQgOkUouEXCDjkMlpFrGgBI5RfCNMLKtCylPJEc1OWOVw57UtrJ0wlOdh4teREE6A4MrKrxDhApvJzwUco1CtIuEOkct4U0lptO5P4ftbkaZIYWSdGwoqdhDSeZgNZ0jaRu6uqqD2Ayt8KpWCoYtKqwZssBhWGweign/uwGTqZaYgOfP3gd8nA7ngqutggleMRHVUBw8PyiqUSckRQZ1YZ/+TWrX+e6vvR8CR1QrXlOwsvPlbAqYFUn8QEpryXtxcUGG1j2dbtngIo6NuBa2ozvb8mWETtdEpQAvRe1FoA16L+1ssfYnC5OlvEhWpuxpjYVScaKyn8zpNMfunIicQ1F61EJHYf81tgSAZVQYZHjVICKs1pDcRu+xcWSZ+qDAKoCuKbwIQwVdrZZMjiKNjGUpmG4dakx6daJlipKpPMjhT105ElJ4VitYnwq0sGfa5LLQcGo8H3uPWpUoB5hyUvb4Ihkaroh98hGQl0MXeTV1RQE5vJ54aUXJTLX1Y5mwKXaYXmfAcq2hoDlF8f/DU1rqjWC4q9hYmhaQ2QXht4SG92bt6kcICOK+32sPVY+pOeSSbAUv4dfIgbOASFpGbUMSQkMI5ckUlAmYdmFRsyoqxHGclocLXptgysrJY+IGWCSMp7mIMyCMohuO8ZHJColHeRHASg4d01ks58lmlu47Mn+YPF4kLnnfuoza4aRVv/UZlcm9GPkYJNhth1zvtJ0WQoI0IaUs7LF64HnVnMNUTNHfI1JWMb3Jbcu41+EDUrvXvGZ+pFE0wB/VOriJLroYk5R/XXF4vkaZf2RAk1TAEk/pMUWzWIVE2I3rmcOmVHTJ5K4SEln1b9WorpUKSHNwgIkJiN3mqNpiNgC5P5pUTyQ2+VdTx1UJLpm6Vx+fLL8El+S+ITQQ3JkmxsWQEHGYU0oaNRomlAkIWJ261rBlxdq6j44/8qXBOwJMPQGSIGYpZV+S9VbwDHYcpI3vPg6GBhVTWIRCoEdX1VmhInTYkJroBmIcQjXRAhbmv7c1IbNB/IuVu4ZmCIpFIHFKWDsstyTUGchHfLXGYxUzFPSHGvhGowR8E9JVJ59uCLJbnRm+ucoik6fmZoFYlLBSV8EBAj32o0owQ04F+KHuJwB5UosT5YWoSSGrhOJKZfCk1YxhLmTig0MsYXI6BGRIrWPosZKi0lFnmicNhSjBL1YZ5lMVvccfWTBQtuGqsBVlZfCKU0gD4u/qDl9iIGIwkhDuXLbdMWuulKiueaASWI9tdDzlVQlBXx40C6KCiqpB/V/oLwiWOvbJkAzQyIZOZbcA7IxmzHCohs67tUhYaw6slobaK4RspGt1EF5ll1b5qAnWg="
            }
        };

        /**
         * -----------------------------------------------------------------------------------
         * APPLICATION STATE
         * Manages the dynamic state of the application.
         * -----------------------------------------------------------------------------------
         */
        const State = {
            wallet: null,
            userStore: null,
            falconApi: null,
            masterPublicKey: null,
            failedLoginAttempts: 0,
            isLockedOut: false,
            activePaymentRequest: null,
            activeManualSend: null,
            activePollingTimer: null,
            cameraStream: null,
            isScannerActive: false,
            currentBalance: 0
        };

        /**
         * -----------------------------------------------------------------------------------
         * CRYPTO & CORE LOGIC
         * Handles cryptographic operations, including banknote validation.
         * -----------------------------------------------------------------------------------
         */
        const Crypto = {
            async init() {
                try {
                    State.falconApi = await pqcSignFalcon1024();
                    const masterKeyBytes = Crypto.utils.base64ToUint8Array(Config.BANKNOTE_CONSTANTS.MASTER_PUBLIC_KEY_B64);
                    State.masterPublicKey = masterKeyBytes;
                    return true;
                } catch (e) {
                    console.error("Critical error initializing cryptography module:", e);
                    alert(`Critical error initializing cryptography module: ${e.message}`);
                    return false;
                }
            },

            utils: {
                arrayBufferToBase64: (b) => btoa(String.fromCharCode(...new Uint8Array(b))),
                base64ToUint8Array: (s) => { const bs = atob(s); const b = new Uint8Array(bs.length); for (let i = 0; i < bs.length; i++) b[i] = bs.charCodeAt(i); return b; },
                hexToUint8Array: (h) => new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b, 16))),
            },

            hashMessageForSigning: (m) => Crypto.utils.hexToUint8Array(shake256(m, 1536)),

            async verifySignature(sig, data, pk) {
                if (!State.falconApi) throw new Error("Falcon API not initialized.");
                const hashedData = Crypto.hashMessageForSigning(data);
                return State.falconApi.verify(sig, hashedData, pk);
            },

            banknote: {
                getStandardizedDataForSigning: (d) => JSON.stringify({ timestamp: d.timestamp, serial: d.serial }, ['timestamp', 'serial']),
                getStandardizedDataForMasterSig: (d) => {
                    const t = { ephemeralPublicKey: Crypto.utils.arrayBufferToBase64(d.ephemeralPublicKey), signatureOne: Crypto.utils.arrayBufferToBase64(d.signatureOne) };
                    return JSON.stringify(t, Object.keys(t).sort());
                },
                parsePayload: (b64) => {
                    const compressed = Crypto.utils.base64ToUint8Array(b64);
                    const jsonString = pako.inflate(compressed, { to: 'string' });
                    const payload = JSON.parse(jsonString);
                    return {
                        amount: payload.a,
                        serial: payload.s,
                        timestamp: payload.t,
                        ephemeralPublicKey: Crypto.utils.base64ToUint8Array(payload.epk),
                        signatureOne: Crypto.utils.base64ToUint8Array(payload.s1),
                        signatureTwo: Crypto.utils.base64ToUint8Array(payload.s2)
                    };
                },
                getLayout: (width) => {
                    const scale = width / 790;
                    return { qrSize: Math.round(250 * scale), xSpacing: Math.round(20 * scale), ySpacing: Math.round(20 * scale) };
                },
                decodeQrGrid: async (imageData, statusCallback) => {
                    const layout = Crypto.banknote.getLayout(imageData.width);
                    const parts = {};
                    let count = 0;
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = imageData.width;
                    canvas.height = imageData.height;
                    ctx.putImageData(imageData, 0, 0);

                    for (let i = 0; i < Config.BANKNOTE_CONSTANTS.NUM_QR_CODES; i++) {
                        statusCallback(`Scanning section ${i + 1}/${Config.BANKNOTE_CONSTANTS.NUM_QR_CODES}...`);
                        await new Promise(r => setTimeout(r, 5)); // Brief pause for UI update

                        const row = Math.floor(i / 3), col = i % 3;
                        const regionX = col * (layout.qrSize + layout.xSpacing);
                        const regionY = row * (layout.qrSize + layout.ySpacing);
                        const data = ctx.getImageData(regionX, regionY, layout.qrSize, layout.qrSize);
                        const code = jsQR(data.data, data.width, data.height);

                        if (code && code.data.startsWith(Config.BANKNOTE_CONSTANTS.VALIDATION_PREFIX)) {
                            const match = code.data.substring(Config.BANKNOTE_CONSTANTS.VALIDATION_PREFIX.length).match(/^(\d+)\/(\d+):(.*)$/s);
                            if (match) {
                                const partNum = parseInt(match[1], 10);
                                if (!parts[partNum]) {
                                    parts[partNum] = match[3];
                                    count++;
                                }
                            }
                        }
                    }

                    if (count < Config.BANKNOTE_CONSTANTS.NUM_QR_CODES) {
                        throw new Error(`Scan failed. Found ${count}/${Config.BANKNOTE_CONSTANTS.NUM_QR_CODES} valid sections.`);
                    }
                    let payload = '';
                    for (let i = 1; i <= Config.BANKNOTE_CONSTANTS.NUM_QR_CODES; i++) {
                        payload += parts[i];
                    }
                    return payload;
                }
            }
        };

        /**
         * -----------------------------------------------------------------------------------
         * LEDGER (PINATA) MODULE
         * Handles all communication with the decentralized ledger (Pinata IPFS).
         * -----------------------------------------------------------------------------------
         */
        const Ledger = {
            async _apiCall(endpoint, options) {
                const response = await fetch(`${Config.PINATA_API_URL}/${endpoint}`, options);
                if (!response.ok) {
                    throw new Error(`Pinata API Error: ${response.status} ${await response.text()}`);
                }
                return response.json();
            },

            async recordSpentIdentifier(identifier, type) {
                const dataToPin = {
                    pinataContent: { identifier, type, status: "spent", timestamp: new Date().toISOString() },
                    pinataMetadata: { name: `${type}-${identifier}.json`, keyvalues: { identifier } }
                };
                try {
                    await Ledger._apiCall('pinning/pinJSONToIPFS', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${Config.PINATA_JWT}` },
                        body: JSON.stringify(dataToPin)
                    });
                    return true;
                } catch (error) {
                    console.error('Failed to record identifier to Pinata:', error);
                    alert(`Critical Error: Could not write to the public ledger. Transaction cannot be safely completed. Reason: ${error.message}`);
                    return false;
                }
            },

            async hasBeenSpent(identifier) {
                try {
                    const result = await Ledger._apiCall(`data/pinList?metadata[keyvalues]={"identifier":{"value":"${identifier}","op":"eq"}}&status=pinned`, {
                        method: 'GET',
                        headers: { Authorization: `Bearer ${Config.PINATA_JWT}` }
                    });
                    return result.count > 0;
                } catch (error) {
                    console.error('Failed to check identifier status on Pinata:', error);
                    alert(`Critical Error: Could not read from the public ledger. Cannot verify transaction safety. Reason: ${error.message}`);
                    return true; // Fail safe
                }
            },

            async pinConfirmation(confirmation) {
                const metadata = {
                    name: `confirmation-${confirmation.linkedTxHash}.json`,
                    keyvalues: { type: 'confirmation', txHash: confirmation.linkedTxHash }
                };
                if (confirmation.receiverAddress) metadata.keyvalues.receiverAddress = confirmation.receiverAddress;
                if (confirmation.senderAddress) metadata.keyvalues.senderAddress = confirmation.senderAddress;

                const dataToPin = { pinataContent: confirmation, pinataMetadata: metadata };
                await Ledger._apiCall('pinning/pinJSONToIPFS', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${Config.PINATA_JWT}` },
                    body: JSON.stringify(dataToPin)
                });
            },

            async findConfirmation(txHash) {
                const result = await Ledger._apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"txHash":{"value":"${txHash}","op":"eq"}}&status=pinned`, {
                    method: 'GET',
                    headers: { Authorization: `Bearer ${Config.PINATA_JWT}` }
                });
                if (result.count > 0) {
                    const hash = result.rows[0].ipfs_pin_hash;
                    const contentResponse = await fetch(`${Config.PINATA_GATEWAY_URL}${hash}`);
                    return contentResponse.json();
                }
                return null;
            },

            async findTransactionsForAddress(address) {
                // Fetch both incoming and outgoing transactions in parallel
                const [incoming, outgoing] = await Promise.all([
                    Ledger._apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"receiverAddress":{"value":"${address}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${Config.PINATA_JWT}` } }),
                    Ledger._apiCall(`data/pinList?metadata[keyvalues]={"type":{"value":"confirmation","op":"eq"},"senderAddress":{"value":"${address}","op":"eq"}}&status=pinned`, { method: 'GET', headers: { Authorization: `Bearer ${Config.PINATA_JWT}` } })
                ]);

                const fetchContent = (rows) => Promise.all(rows.map(row => fetch(`${Config.PINATA_GATEWAY_URL}${row.ipfs_pin_hash}`).then(res => res.json())));

                const incomingTxs = incoming.count > 0 ? await fetchContent(incoming.rows) : [];
                const outgoingTxs = outgoing.count > 0 ? await fetchContent(outgoing.rows) : [];

                return { incomingTxs, outgoingTxs };
            }
        };

        /**
         * -----------------------------------------------------------------------------------
         * WALLET MODULE
         * Manages wallet state, transactions, balance, and cryptographic identity.
         * -----------------------------------------------------------------------------------
         */
        const Wallet = {
            _saveUserStore() {
                localStorage.setItem(Config.APP_CONSTANTS.LOCAL_STORAGE_KEY, JSON.stringify(State.userStore));
            },

            _loadUserStore() {
                const storeJson = localStorage.getItem(Config.APP_CONSTANTS.LOCAL_STORAGE_KEY);
                return storeJson ? JSON.parse(storeJson) : null;
            },

            exists() {
                return !!this._loadUserStore();
            },

            create(password) {
                const wallet = ethers.Wallet.createRandom();
                const encryptedJson = wallet.encryptSync(password);
                State.userStore = {
                    address: wallet.address,
                    encryptedJson: encryptedJson,
                    chain: [],
                    lastSyncTimestamp: 0
                };
                State.wallet = wallet;
                this._saveUserStore();
                return { mnemonic: wallet.mnemonic.phrase };
            },

            async restore(mnemonic, password) {
                try {
                    const wallet = ethers.Wallet.fromPhrase(mnemonic);
                    const encryptedJson = wallet.encryptSync(password);
                    State.userStore = {
                        address: wallet.address,
                        encryptedJson: encryptedJson,
                        chain: [],
                        lastSyncTimestamp: 0
                    };
                    State.wallet = wallet;
                    this._saveUserStore();
                    return true;
                } catch (e) {
                    console.error("Restore failed:", e);
                    return false;
                }
            },

            async login(password) {
                if (State.isLockedOut) return false;
                const userStore = this._loadUserStore();
                if (!userStore) return false;

                try {
                    const wallet = await ethers.Wallet.fromEncryptedJson(userStore.encryptedJson, password);
                    State.userStore = userStore;
                    State.wallet = wallet;
                    State.failedLoginAttempts = 0;
                    return true;
                } catch (e) {
                    console.error("Login failed:", e);
                    State.failedLoginAttempts++;
                    if (State.failedLoginAttempts >= Config.APP_CONSTANTS.MAX_LOGIN_ATTEMPTS) {
                        State.isLockedOut = true;
                        setTimeout(() => {
                            State.isLockedOut = false;
                            State.failedLoginAttempts = 0;
                        }, Config.APP_CONSTANTS.LOGIN_LOCKOUT_PERIOD);
                    }
                    return false;
                }
            },

            logout() {
                State.wallet = null;
                // Keep userStore in State but clear sensitive wallet object
            },
            
            erase() {
                localStorage.removeItem(Config.APP_CONSTANTS.LOCAL_STORAGE_KEY);
                location.reload();
            },

            addToChain(txData, save = true) {
                const prevHash = State.userStore.chain.length > 0 ? State.userStore.chain[State.userStore.chain.length - 1].hash : ethers.id("GENESIS_BLOCK");
                const newTx = { ...txData, prevHash, timestamp: txData.timestamp || Date.now() };

                const amountInt = ethers.parseUnits((newTx.amount || 0).toFixed(Config.APP_CONSTANTS.PRECISION), Config.APP_CONSTANTS.PRECISION);
                const feeInt = ethers.parseUnits((newTx.fee || 0).toFixed(Config.APP_CONSTANTS.PRECISION), Config.APP_CONSTANTS.PRECISION);
                
                newTx.hash = ethers.solidityPackedKeccak256(
                    ['string', 'uint256', 'uint256', 'string', 'string', 'string'],
                    [newTx.type, amountInt, feeInt, newTx.from || '', newTx.to || '', prevHash]
                );
                
                State.userStore.chain.push(newTx);
                if (save) this._saveUserStore();
                return newTx;
            },

            calculateBalance() {
                let balance = 0;
                if (!State.userStore || !State.userStore.chain) return 0.0;
                for (const tx of State.userStore.chain) {
                    if (tx.status !== 'completed') continue;
                    if (tx.to === State.wallet.address) {
                        balance += (tx.amount || 0);
                    }
                    if (tx.from === State.wallet.address) {
                        balance -= (tx.amount || 0);
                        balance -= (tx.fee || 0);
                    }
                }
                State.currentBalance = balance;
                return balance;
            },
            
            async syncWithLedger() {
                if (!State.wallet) return 0;
                const { incomingTxs, outgoingTxs } = await Ledger.findTransactionsForAddress(State.wallet.address);
                const allTxs = [...incomingTxs, ...outgoingTxs];

                let newTxCount = 0;
                allTxs.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0)); // Ensure chronological processing

                for (const confirmation of allTxs) {
                    const txExists = State.userStore.chain.some(tx => tx.linkedTxHash === confirmation.linkedTxHash || tx.hash === confirmation.linkedTxHash);
                    if (txExists) continue;

                    let isValid = false;
                    if (confirmation.senderAddress === 'BANKNOTE_ISSUER') {
                        isValid = true; // Banknote charges are trusted
                    } else {
                         if (!confirmation.signedMessage) {
                            console.error("Discovered TX invalid: Missing 'signedMessage'"); continue;
                         }
                        const signerAddress = ethers.verifyMessage(confirmation.signedMessage, confirmation.signature);
                        if (signerAddress === confirmation.senderAddress) {
                            isValid = true;
                        } else {
                            console.error("Discovered TX failed signature validation"); continue;
                        }
                    }

                    if (isValid) {
                        const isSender = confirmation.senderAddress === State.wallet.address;
                        this.addToChain({
                            type: isSender ? 'send' : (confirmation.senderAddress === 'BANKNOTE_ISSUER' ? 'charge' : 'receive'),
                            amount: confirmation.amount,
                            fee: isSender ? confirmation.amount * Config.APP_CONSTANTS.FEE_PERCENTAGE : 0,
                            from: confirmation.senderAddress,
                            to: confirmation.receiverAddress,
                            status: 'completed',
                            linkedTxHash: confirmation.linkedTxHash,
                            timestamp: new Date(confirmation.timestamp || Date.now()).getTime()
                        }, false); // Add to chain without saving immediately
                        newTxCount++;
                    }
                }

                if (newTxCount > 0) {
                    // Sort the entire chain by timestamp before saving to ensure hash integrity
                    State.userStore.chain.sort((a, b) => a.timestamp - b.timestamp);
                    this._saveUserStore();
                }
                return newTxCount;
            },

            getStandardizedConfirmationMessage: (confirmation) => {
                const amount = Number(confirmation.amount).toFixed(Config.APP_CONSTANTS.PRECISION);
                return [confirmation.type, confirmation.senderAddress, confirmation.receiverAddress, amount, confirmation.linkedTxHash].join('|');
            },

            createPaymentRequest(amount) {
                const receiveTx = this.addToChain({ type: 'receive', amount: amount, from: '', to: State.wallet.address, status: 'pending_request' });
                return {
                    type: 'AURA_PAYMENT_REQUEST',
                    receiverAddress: State.wallet.address,
                    amount: amount,
                    linkedTxHash: receiveTx.hash,
                    expiresAt: Date.now() + Config.APP_CONSTANTS.PAYMENT_REQUEST_EXPIRY
                };
            },

            async processPayment(request) {
                const fee = request.amount * Config.APP_CONSTANTS.FEE_PERCENTAGE;
                const totalDebit = request.amount + fee;

                if (Date.now() > request.expiresAt) throw new Error("Payment request has expired.");
                if (State.currentBalance < totalDebit) throw new Error(`Insufficient funds. You need $${totalDebit.toFixed(2)}.`);
                if (await Ledger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been processed.");

                const sendTx = this.addToChain({
                    type: 'send',
                    amount: request.amount,
                    fee: fee,
                    from: State.wallet.address,
                    to: request.receiverAddress,
                    status: 'completed',
                    linkedTxHash: request.linkedTxHash
                });

                const spentSuccess = await Ledger.recordSpentIdentifier(request.linkedTxHash, 'transaction');
                if (!spentSuccess) {
                    State.userStore.chain.pop(); // Revert local transaction
                    this._saveUserStore();
                    throw new Error("CRITICAL: Payment sent but failed to update public ledger.");
                }

                // Main payment confirmation
                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: State.wallet.address, receiverAddress: request.receiverAddress, amount: request.amount, linkedTxHash: request.linkedTxHash, timestamp: Date.now() };
                const messageToSign = this.getStandardizedConfirmationMessage(confirmation);
                confirmation.signature = await State.wallet.signMessage(messageToSign);
                confirmation.signedMessage = messageToSign;
                await Ledger.pinConfirmation(confirmation);

                // Fee payment confirmation
                const feeConfirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: State.wallet.address, receiverAddress: Config.APP_CONSTANTS.TREASURY_ADDRESS, amount: fee, linkedTxHash: sendTx.hash + "-fee", timestamp: Date.now() };
                const feeMessageToSign = this.getStandardizedConfirmationMessage(feeConfirmation);
                feeConfirmation.signature = await State.wallet.signMessage(feeMessageToSign);
                feeConfirmation.signedMessage = feeMessageToSign;
                await Ledger.pinConfirmation(feeConfirmation);

                return true;
            },
            
            async directSend(recipientAddress, amount) {
                const fee = amount * Config.APP_CONSTANTS.FEE_PERCENTAGE;
                const totalDebit = amount + fee;
                if (State.currentBalance < totalDebit) throw new Error(`Insufficient funds to cover amount + fee.`);

                const sendTx = this.addToChain({ type: 'send', amount: amount, fee: fee, from: State.wallet.address, to: recipientAddress, status: 'completed' });

                // Main payment confirmation
                const confirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: State.wallet.address, receiverAddress: recipientAddress, amount: amount, linkedTxHash: sendTx.hash, timestamp: Date.now() };
                const messageToSign = this.getStandardizedConfirmationMessage(confirmation);
                confirmation.signature = await State.wallet.signMessage(messageToSign);
                confirmation.signedMessage = messageToSign;
                await Ledger.pinConfirmation(confirmation);

                // Fee payment confirmation
                const feeConfirmation = { type: 'AURA_PAYMENT_CONFIRMATION', senderAddress: State.wallet.address, receiverAddress: Config.APP_CONSTANTS.TREASURY_ADDRESS, amount: fee, linkedTxHash: sendTx.hash + "-fee", timestamp: Date.now() };
                const feeMessageToSign = this.getStandardizedConfirmationMessage(feeConfirmation);
                feeConfirmation.signature = await State.wallet.signMessage(feeMessageToSign);
                feeConfirmation.signedMessage = feeMessageToSign;
                await Ledger.pinConfirmation(feeConfirmation);

                return true;
            },

            async finalizePayment(confirmation) {
                const receiveTxIndex = State.userStore.chain.findIndex(tx => tx.hash === confirmation.linkedTxHash && tx.status === 'pending_request');
                if (receiveTxIndex === -1) {
                    console.error("Finalize Error: Could not find pending transaction.");
                    return false;
                }
                const locallyRecreatedMessage = this.getStandardizedConfirmationMessage(confirmation);
                if (locallyRecreatedMessage !== confirmation.signedMessage) {
                    console.error("Tamper Detection: Confirmation data mismatch.");
                    return false;
                }
                const signerAddress = ethers.verifyMessage(confirmation.signedMessage, confirmation.signature);
                if (signerAddress !== confirmation.senderAddress) {
                    console.error("Signature verification failed!");
                    return false;
                }
                State.userStore.chain[receiveTxIndex].status = 'completed';
                State.userStore.chain[receiveTxIndex].from = confirmation.senderAddress;
                this._saveUserStore();
                return true;
            },
            
            async processBanknoteCharge(amount, serial) {
                const spentSuccess = await Ledger.recordSpentIdentifier(serial, 'banknote');
                if (!spentSuccess) {
                    throw new Error("Failed to record banknote as spent on the public ledger.");
                }

                const chargeConfirmation = {
                    type: 'AURA_PAYMENT_CONFIRMATION',
                    senderAddress: 'BANKNOTE_ISSUER',
                    receiverAddress: State.wallet.address,
                    amount: amount,
                    linkedTxHash: 'charge-' + serial,
                    timestamp: Date.now()
                };
                await Ledger.pinConfirmation(chargeConfirmation);
                
                this.addToChain({ 
                    type: 'charge', 
                    amount: amount, 
                    from: 'BANKNOTE_ISSUER', 
                    to: State.wallet.address, 
                    serial: serial, 
                    status: 'completed', 
                    linkedTxHash: 'charge-' + serial 
                });
                
                return true;
            }
        };
        
        /**
         * -----------------------------------------------------------------------------------
         * UI MODULE
         * Handles all DOM manipulations, event listeners, and UI state changes.
         * -----------------------------------------------------------------------------------
         */
        const UI = {
            elements: {
                views: document.querySelectorAll('.view'),
                // Add other frequently accessed elements here to cache them
                balanceDisplay: document.getElementById('balance-display'),
                addressDisplay: document.getElementById('address-display'),
                syncStatus: document.getElementById('sync-status'),
                transactionList: document.getElementById('transaction-list-ul'),
            },

            showView(viewId) {
                if (document.getElementById('send-view').classList.contains('active') && viewId !== 'send-view') {
                    this.stopScanner();
                }
                if (State.activePollingTimer) {
                    clearInterval(State.activePollingTimer);
                    State.activePollingTimer = null;
                }
                this.elements.views.forEach(v => v.classList.remove('active'));
                const viewElement = document.getElementById(viewId);
                if (viewElement) viewElement.classList.add('active');
            },
            
            setLoader(loaderId, isLoading) {
                document.getElementById(loaderId).classList.toggle('hidden', !isLoading);
            },
            
            setStatus(elementId, message, type = 'info') {
                const el = document.getElementById(elementId);
                if (el) el.innerHTML = `<span class="${type}">${message}</span>`;
            },
            
            resetViewInputs(viewId) {
                 const view = document.getElementById(viewId);
                 if (!view) return;
                 view.querySelectorAll('input, textarea').forEach(input => {
                     if (input.type !== 'file') input.value = '';
                 });
                 const statusBox = view.querySelector('.status-box');
                 if (statusBox) statusBox.innerHTML = '';
            },
            
            abbreviateAddress(address) {
                if (!address) return '';
                return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
            },

            async renderWalletView() {
                this.elements.balanceDisplay.textContent = 'Loading...';
                this.elements.addressDisplay.textContent = this.abbreviateAddress(State.wallet.address);
                this.showView('wallet-view');
                
                this.elements.syncStatus.innerHTML = '<span class="info">Syncing with ledger...</span>';
                try {
                    const newTxCount = await Wallet.syncWithLedger();
                    const balance = Wallet.calculateBalance();
                    this.elements.balanceDisplay.textContent = `$${balance.toFixed(2)}`;
                    this.renderTransactionHistory();
                    
                    if (newTxCount > 0) {
                        this.elements.syncStatus.innerHTML = `<span class="success">Synced! ${newTxCount} new transaction(s) found.</span>`;
                    } else {
                        this.elements.syncStatus.innerHTML = '<span class="success">Wallet is up to date.</span>';
                    }
                } catch (error) {
                    console.error("Failed to sync:", error);
                    this.elements.syncStatus.innerHTML = '<span class="error">Could not sync with ledger.</span>';
                    this.elements.balanceDisplay.textContent = 'Error';
                }
                setTimeout(() => { if (this.elements.syncStatus) this.elements.syncStatus.innerHTML = ''; }, 4000);
            },
            
            renderTransactionHistory() {
                this.elements.transactionList.innerHTML = '';
                if (!State.userStore || !State.userStore.chain) return;

                const transactions = State.userStore.chain
                    .filter(tx => ['send', 'receive', 'charge'].includes(tx.type) && tx.status === 'completed')
                    .slice(-10).reverse();

                if (transactions.length === 0) {
                    this.elements.transactionList.innerHTML = '<li class="no-transactions">No transactions found.</li>';
                    return;
                }

                transactions.forEach(tx => {
                    const item = document.createElement('li');
                    item.className = 'transaction-item';
                    item.style.cursor = 'pointer';
                    const isSent = tx.type === 'send';
                    const typeText = isSent ? 'Sent' : (tx.type === 'charge' ? 'Charge' : 'Received');
                    const typeClass = isSent ? 'sent' : 'received';
                    const totalAmount = tx.amount || 0;
                    const date = new Date(tx.timestamp).toLocaleString('en-US');

                    item.innerHTML = `<div class="transaction-details"><span class="transaction-type ${typeClass}">${typeText}</span><span class="transaction-date">${date}</span></div><span class="transaction-amount ${typeClass}">${isSent ? '-' : '+'}$${totalAmount.toFixed(2)}</span>`;
                    item.addEventListener('click', () => this.showTransactionDetails(tx));
                    this.elements.transactionList.appendChild(item);
                });
            },

            showTransactionDetails(tx) {
                const modal = document.getElementById('transaction-detail-modal');
                document.getElementById('detail-status').textContent = tx.status || 'N/A';
                document.getElementById('detail-type').textContent = tx.type || 'N/A';
                document.getElementById('detail-datetime').textContent = new Date(tx.timestamp).toLocaleString('en-US', { dateStyle: 'long', timeStyle: 'medium' });
                document.getElementById('detail-amount').textContent = `$${(tx.amount || 0).toFixed(2)}`;
                document.getElementById('detail-fee').textContent = `$${(tx.fee || 0).toFixed(2)}`;
                document.getElementById('detail-from').textContent = tx.from || 'N/A';
                document.getElementById('detail-to').textContent = tx.to || 'N/A';
                document.getElementById('detail-hash').textContent = tx.hash || 'N/A';
                modal.style.display = 'flex';
                document.getElementById('close-modal-button').onclick = () => { modal.style.display = 'none'; };
                document.getElementById('download-tx-button').onclick = () => {
                    const contentToCapture = document.getElementById('modal-details-content');
                    html2canvas(contentToCapture, { scale: 2 }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = `transaction_${tx.hash.substring(0, 10)}.jpg`;
                        link.href = canvas.toDataURL('image/jpeg', 0.9);
                        link.click();
                    });
                };
            },
            
            generateQrCode(data, containerId) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';
                const qr = qrcode(0, 'L');
                qr.addData(data);
                qr.make();
                container.innerHTML = qr.createImgTag(6, 10);
            },
            
            stopScanner() {
                if (State.cameraStream) {
                    State.cameraStream.getTracks().forEach(track => track.stop());
                    State.cameraStream = null;
                }
                State.isScannerActive = false;
            },
            
            async startScanner() {
                if (State.isScannerActive) return;
                State.isScannerActive = true;
                const video = document.getElementById('qr-video');
                const loadingMessage = document.getElementById('loading-message');
                const canvasElement = document.getElementById('qr-canvas');
                const canvas = canvasElement.getContext('2d');

                this.setStatus('send-status', '');
                loadingMessage.style.display = 'flex';
                loadingMessage.textContent = 'Requesting camera access...';

                try {
                    State.cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    video.srcObject = State.cameraStream;
                    await video.play();
                    loadingMessage.style.display = 'none';
                    requestAnimationFrame(tick);
                } catch (err) {
                    console.error("Camera Error:", err);
                    loadingMessage.textContent = "Could not access camera.";
                    this.setStatus('send-status', `Camera access is required.`, 'error');
                    State.isScannerActive = false;
                }
                
                const self = this;
                function tick() {
                    if (!State.isScannerActive) return;
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvasElement.height = video.videoHeight;
                        canvasElement.width = video.videoWidth;
                        canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                        const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });

                        if (code) {
                            self.stopScanner();
                            self.setStatus('send-status', 'QR Code Detected! Processing...', 'info');
                            App.handleScannedQR(code.data);
                            return;
                        }
                    }
                    requestAnimationFrame(tick);
                }
            }
        };

        /**
         * -----------------------------------------------------------------------------------
         * APP MODULE
         * Main application controller, handles initialization and event binding.
         * -----------------------------------------------------------------------------------
         */
        const App = {
            async init() {
                const cryptoReady = await Crypto.init();
                if (!cryptoReady) return;

                if (Wallet.exists()) {
                    UI.showView('login-view');
                } else {
                    UI.showView('onboarding-view');
                }
                this.bindEventListeners();
            },
            
            async handleScannedQR(data) {
                let isPaymentRequest = false;
                try {
                    const request = JSON.parse(data);
                    if (request.type === 'AURA_PAYMENT_REQUEST' && request.amount && request.receiverAddress) {
                        isPaymentRequest = true;
                        if (Date.now() > request.expiresAt) throw new Error("This payment request has expired.");
                        if (await Ledger.hasBeenSpent(request.linkedTxHash)) throw new Error("This payment request has already been paid.");
                        
                        State.activePaymentRequest = request;
                        State.activeManualSend = null;
                        this.prepareConfirmationView(request.amount, request.receiverAddress);

                    }
                } catch (e) {
                     if (e instanceof Error) UI.setStatus('send-status', e.message, 'error');
                }

                if (!isPaymentRequest) {
                    if (ethers.isAddress(data)) {
                        document.getElementById('send-address-input').value = data;
                        UI.setStatus('send-status', 'Recipient address scanned! Please enter amount.', 'success');
                        document.getElementById('send-amount-input').focus();
                    } else {
                        UI.setStatus('send-status', 'Invalid QR Code.', 'error');
                        setTimeout(() => UI.startScanner(), 2000);
                    }
                }
            },
            
            prepareConfirmationView(amount, recipientAddress) {
                const fee = amount * Config.APP_CONSTANTS.FEE_PERCENTAGE;
                const total = amount + fee;
                document.getElementById('confirm-amount-display').innerHTML = `Amount: $${amount.toFixed(2)}<br><span style="font-size: 14px; color: #555;">Fee (${(Config.APP_CONSTANTS.FEE_PERCENTAGE*100).toFixed(1)}%): +$${fee.toFixed(2)}</span><br><strong style="font-size: 18px;">Total: $${total.toFixed(2)}</strong>`;
                document.getElementById('confirm-recipient-address-display').textContent = recipientAddress;
                UI.showView('send-confirm-view');
            },

            bindEventListeners() {
                // Navigation
                document.getElementById('go-to-create-wallet').addEventListener('click', () => UI.showView('create-wallet-view'));
                document.getElementById('go-to-restore-wallet').addEventListener('click', () => UI.showView('restore-wallet-view'));
                document.getElementById('back-from-create').addEventListener('click', () => { UI.resetViewInputs('create-wallet-view'); UI.showView('onboarding-view'); });
                document.getElementById('back-from-restore').addEventListener('click', () => { UI.resetViewInputs('restore-wallet-view'); UI.showView('onboarding-view'); });
                document.getElementById('back-from-charge').addEventListener('click', () => UI.showView('wallet-view'));
                document.getElementById('back-from-receive').addEventListener('click', () => UI.showView('wallet-view'));
                document.getElementById('back-from-send').addEventListener('click', () => { UI.resetViewInputs('send-view'); UI.showView('wallet-view'); });
                document.getElementById('back-from-send-confirm').addEventListener('click', () => UI.showView('send-view'));
                document.getElementById('back-from-qr-display').addEventListener('click', () => UI.showView('wallet-view'));

                // Wallet Actions
                document.getElementById('create-wallet-button').addEventListener('click', this.onCreateWallet);
                document.getElementById('seed-phrase-confirm-button').addEventListener('click', this.onConfirmSeedPhrase);
                document.getElementById('restore-wallet-button').addEventListener('click', this.onRestoreWallet);
                document.getElementById('login-button').addEventListener('click', this.onLogin);
                document.getElementById('logout-button').addEventListener('click', this.onLogout);
                document.getElementById('reset-app-button').addEventListener('click', this.onResetApp);

                // Main View Buttons
                document.getElementById('copy-address-button').addEventListener('click', this.onCopyAddress);
                document.getElementById('show-receive-view-button').addEventListener('click', this.onShowReceiveView);
                document.getElementById('show-send-view-button').addEventListener('click', this.onShowSendView);
                document.getElementById('show-charge-view-button').addEventListener('click', this.onShowChargeView);

                // Sending Flow
                document.getElementById('send-manual-button').addEventListener('click', this.onManualSend);
                document.getElementById('confirm-payment-button').addEventListener('click', this.onConfirmPayment);
                
                // Receiving Flow
                document.getElementById('create-request-qr-button').addEventListener('click', this.onCreatePaymentRequest);
                
                // Charging Flow
                document.getElementById('banknote-image-input').addEventListener('change', this.onBanknoteUpload);
                document.getElementById('confirm-charge-button').addEventListener('click', this.onConfirmCharge);
            },

            // Event Handlers
            async onCreateWallet() {
                const pass = document.getElementById('create-password-input').value;
                const confirmPass = document.getElementById('confirm-password-input').value;
                if (pass.length < 8) { UI.setStatus('create-status', 'Password must be at least 8 characters.', 'error'); return; }
                if (pass !== confirmPass) { UI.setStatus('create-status', 'Passwords do not match.', 'error'); return; }
                
                UI.setLoader('create-loader', true);
                const { mnemonic } = Wallet.create(pass);
                document.getElementById('seed-phrase-display').textContent = mnemonic;
                UI.showView('seed-phrase-view');
                UI.setLoader('create-loader', false);
            },
            
            async onConfirmSeedPhrase() {
                await UI.renderWalletView();
                document.getElementById('seed-phrase-display').textContent = '';
                UI.resetViewInputs('create-wallet-view');
            },

            async onRestoreWallet() {
                const mnemonic = document.getElementById('restore-seed-input').value.trim();
                const pass = document.getElementById('restore-password-input').value.trim();
                if (mnemonic.split(' ').length !== 12) { UI.setStatus('restore-status', 'Recovery phrase must be 12 words.', 'error'); return; }
                if (pass.length < 8) { UI.setStatus('restore-status', 'Password must be at least 8 characters.', 'error'); return; }

                UI.setLoader('restore-loader', true);
                const success = await Wallet.restore(mnemonic, pass);
                if (success) {
                    await UI.renderWalletView();
                } else {
                    UI.setStatus('restore-status', 'Restore failed. Invalid phrase.', 'error');
                }
                UI.setLoader('restore-loader', false);
                UI.resetViewInputs('restore-wallet-view');
            },
            
            async onLogin(event) {
                const button = event.target;
                button.disabled = true;
                UI.setLoader('login-loader', true);
                UI.setStatus('login-status', 'Decrypting wallet...', 'info');

                const pass = document.getElementById('login-password-input').value;
                const success = await Wallet.login(pass);

                if (success) {
                    await UI.renderWalletView();
                    UI.resetViewInputs('login-view');
                } else {
                    if (State.isLockedOut) {
                        UI.setStatus('login-status', 'Too many failed attempts. Please wait 30 seconds.', 'error');
                    } else {
                        const attemptsLeft = Config.APP_CONSTANTS.MAX_LOGIN_ATTEMPTS - State.failedLoginAttempts;
                        UI.setStatus('login-status', `Invalid password. (${attemptsLeft} attempts remaining)`, 'error');
                    }
                }
                if (!State.isLockedOut) button.disabled = false;
                UI.setLoader('login-loader', false);
            },
            
            onLogout() {
                Wallet.logout();
                UI.showView('login-view');
            },
            
            onResetApp() {
                if (confirm('Are you sure? All wallet data will be erased from this browser.')) {
                    Wallet.erase();
                }
            },

            onCopyAddress(event) {
                const button = event.target;
                navigator.clipboard.writeText(State.wallet.address).then(() => {
                    button.textContent = 'Copied!';
                    setTimeout(() => { button.textContent = 'Copy'; }, 1500);
                });
            },

            onShowReceiveView() {
                UI.resetViewInputs('receive-view');
                document.getElementById('full-receive-address').textContent = State.wallet.address;
                UI.generateQrCode(State.wallet.address, 'static-qr-code');
                UI.showView('receive-view');
            },

            onShowSendView() {
                UI.resetViewInputs('send-view');
                UI.showView('send-view');
                UI.startScanner();
            },
            
            onShowChargeView() {
                UI.resetViewInputs('charge-view');
                document.getElementById('banknote-image-input').disabled = true;
                document.getElementById('charge-confirmation').style.display = 'none';
                
                if (State.masterPublicKey) {
                    UI.setStatus('key-status', 'Bank public key loaded.', 'success');
                    document.getElementById('banknote-image-input').disabled = false;
                } else {
                    UI.setStatus('key-status', 'Bank public key not available.', 'error');
                }
                UI.showView('charge-view');
            },

            onManualSend() {
                const recipientAddress = document.getElementById('send-address-input').value.trim();
                const amount = parseFloat(document.getElementById('send-amount-input').value);
                
                if (!ethers.isAddress(recipientAddress)) { UI.setStatus('send-status', 'Invalid recipient address.', 'error'); return; }
                if (isNaN(amount) || amount <= 0) { UI.setStatus('send-status', 'Please enter a valid amount.', 'error'); return; }
                if (State.currentBalance < (amount + (amount * Config.APP_CONSTANTS.FEE_PERCENTAGE))) { UI.setStatus('send-status', 'Insufficient funds.', 'error'); return; }
                
                State.activeManualSend = { address: recipientAddress, amount: amount };
                State.activePaymentRequest = null;
                this.prepareConfirmationView(amount, recipientAddress);
            },

            async onConfirmPayment(event) {
                const button = event.target;
                button.disabled = true;
                UI.setStatus('send-confirm-status', 'Processing payment...', 'info');

                try {
                    // Refresh balance to prevent race conditions
                    Wallet.calculateBalance();
                    
                    let success = false, message = '';
                    if (State.activePaymentRequest) {
                        await Wallet.processPayment(State.activePaymentRequest);
                        message = `Payment of $${State.activePaymentRequest.amount.toFixed(2)} sent!`;
                        success = true;
                    } else if (State.activeManualSend) {
                        await Wallet.directSend(State.activeManualSend.address, State.activeManualSend.amount);
                        message = `Payment of $${State.activeManualSend.amount.toFixed(2)} sent!`;
                        success = true;
                    } else { throw new Error("No active payment request."); }
                    
                    if (success) {
                        UI.setStatus('send-confirm-status', message, 'success');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        State.activePaymentRequest = null;
                        State.activeManualSend = null;
                        await UI.renderWalletView();
                    }
                } catch (err) {
                    UI.setStatus('send-confirm-status', `Payment Failed: ${err.message}`, 'error');
                } finally {
                    button.disabled = false;
                }
            },
            
            onCreatePaymentRequest() {
                const amount = parseFloat(document.getElementById('request-amount-input').value);
                if (isNaN(amount) || amount <= 0) { UI.setStatus('receive-status', 'Please enter a valid amount.', 'error'); return; }
                
                const request = Wallet.createPaymentRequest(amount);
                document.getElementById('qr-display-title').textContent = 'Payment Request';
                document.getElementById('qr-display-instruction').textContent = `Show this QR to the sender to pay $${amount.toFixed(2)}.`;
                UI.generateQrCode(JSON.stringify(request), 'qr-display-box');
                document.getElementById('waiting-on-payment').style.display = 'block';
                document.querySelector('#waiting-on-payment .loader').style.display = 'block';
                UI.setStatus('final-status-message', 'Waiting for sender to pay...', 'info');
                
                UI.showView('qr-display-view');

                let timeLeft = Config.APP_CONSTANTS.PAYMENT_REQUEST_EXPIRY;
                const timerEl = document.getElementById('payment-timer');
                const updateTimer = () => {
                    timeLeft -= 1000;
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000).toString().padStart(2, '0');
                    timerEl.textContent = `Expires in: ${minutes}:${seconds}`;
                    if (timeLeft <= 0) {
                        clearInterval(State.activePollingTimer);
                        State.activePollingTimer = null;
                        UI.setStatus('final-status-message', 'Payment request expired.', 'error');
                        document.querySelector('#waiting-on-payment .loader').style.display = 'none';
                    }
                };
                updateTimer();
                
                State.activePollingTimer = setInterval(async () => {
                    updateTimer();
                    if (timeLeft <= 0) return;
                    try {
                        const confirmation = await Ledger.findConfirmation(request.linkedTxHash);
                        if (confirmation) {
                            clearInterval(State.activePollingTimer);
                            State.activePollingTimer = null;
                            timerEl.style.display = 'none';
                            UI.setStatus('final-status-message', 'Payment detected! Finalizing...', 'info');
                            
                            if (await Wallet.finalizePayment(confirmation)) {
                                UI.setStatus('final-status-message', `Success! $${Number(confirmation.amount).toFixed(2)} received.`, 'success');
                                document.querySelector('#waiting-on-payment .loader').style.display = 'none';
                                setTimeout(() => UI.renderWalletView(), 2000);
                            } else {
                                UI.setStatus('final-status-message', `Finalization failed.`, 'error');
                            }
                        }
                    } catch (err) {
                        console.error("Polling error:", err);
                        UI.setStatus('final-status-message', `Network error while checking for payment.`, 'error');
                        clearInterval(State.activePollingTimer);
                    }
                }, Config.APP_CONSTANTS.POLLING_INTERVAL);
            },
            
            async onBanknoteUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                document.getElementById('charge-confirmation').style.display = 'none';
                UI.setStatus('validation-status', 'Preparing image...', 'info');
                
                try {
                    const imageToData = (url) => new Promise((res, rej) => {
                        const i = new Image();
                        i.onload = () => {
                            const c = document.createElement('canvas');
                            c.width = i.width; c.height = i.height;
                            const ctx = c.getContext('2d');
                            ctx.drawImage(i, 0, 0);
                            res(ctx.getImageData(0, 0, i.width, i.height));
                        };
                        i.onerror = rej;
                        i.src = url;
                    });

                    const fileReader = new FileReader();
                    const resizedDataUrl = await new Promise((res, rej) => {
                        fileReader.onload = e => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                let { width, height } = img;
                                if (width > height) {
                                    if (width > Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION) { height *= Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION / width; width = Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION; }
                                } else {
                                    if (height > Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION) { width *= Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION / height; height = Config.BANKNOTE_CONSTANTS.MAX_IMAGE_DIMENSION; }
                                }
                                canvas.width = width; canvas.height = height;
                                canvas.getContext('2d').drawImage(img, 0, 0, width, height);
                                res(canvas.toDataURL('image/jpeg'));
                            };
                            img.onerror = rej;
                            img.src = e.target.result;
                        };
                        fileReader.onerror = rej;
                        fileReader.readAsDataURL(file);
                    });

                    const imageData = await imageToData(resizedDataUrl);
                    const payload = await Crypto.banknote.decodeQrGrid(imageData, (status) => UI.setStatus('validation-status', status, 'info'));
                    
                    UI.setStatus('validation-status', 'Scan complete. Verifying signatures...', 'info');
                    const banknoteData = Crypto.banknote.parsePayload(payload);

                    if (await Ledger.hasBeenSpent(banknoteData.serial)) {
                        throw new Error("This banknote has already been spent.");
                    }
                    
                    const isSigOneValid = await Crypto.verifySignature(banknoteData.signatureOne, Crypto.banknote.getStandardizedDataForSigning(banknoteData), banknoteData.ephemeralPublicKey);
                    if (!isSigOneValid) throw new Error("Signature validation failed (internal).");
                    
                    const isSigTwoValid = await Crypto.verifySignature(banknoteData.signatureTwo, Crypto.banknote.getStandardizedDataForMasterSig(banknoteData), State.masterPublicKey);
                    if (!isSigTwoValid) throw new Error("Signature validation failed (issuer).");
                    
                    UI.setStatus('validation-status', 'Banknote is valid!', 'success');
                    document.getElementById('validated-amount').textContent = `$${banknoteData.amount.toFixed(2)}`;
                    const confirmBtn = document.getElementById('confirm-charge-button');
                    confirmBtn.dataset.amount = banknoteData.amount;
                    confirmBtn.dataset.serial = banknoteData.serial;
                    document.getElementById('charge-confirmation').style.display = 'block';

                } catch (err) {
                    UI.setStatus('validation-status', `Validation Failed: ${err.message}`, 'error');
                } finally {
                    event.target.value = '';
                }
            },
            
            async onConfirmCharge(event) {
                const button = event.target;
                button.disabled = true;
                
                const amount = parseFloat(button.dataset.amount);
                const serial = button.dataset.serial;
                
                UI.setStatus('validation-status', 'Recording banknote on public ledger...', 'info');
                
                try {
                    await Wallet.processBanknoteCharge(amount, serial);
                    alert(`$${amount.toFixed(2)} added successfully.`);
                    await UI.renderWalletView();
                } catch (err) {
                    console.error("Charge failed:", err);
                    UI.setStatus('validation-status', `Charge Failed: ${err.message}`, 'error');
                    button.disabled = false;
                }
            }
        };

        // Initialize the application once the DOM is fully loaded.
        document.addEventListener('DOMContentLoaded', () => App.init());

    </script>
</body>
</html>
